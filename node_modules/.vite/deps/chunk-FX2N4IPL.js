import {
  ConnectorUtil,
  WalletUtil
} from "./chunk-WRLUCSPR.js";
import {
  CaipNetworksUtil,
  ConstantsUtil as ConstantsUtil3,
  ErrorUtil,
  HelpersUtil,
  LoggerUtil,
  PresetsUtil,
  ProviderUtil
} from "./chunk-WWYKUH53.js";
import {
  W3mFrameHelpers,
  W3mFrameProvider
} from "./chunk-ADEMSHQQ.js";
import {
  EnsController,
  OnRampController,
  SIWXUtil,
  decode,
  encode,
  require_blakejs,
  setColorTheme,
  setThemeVariables
} from "./chunk-QNIZUP7E.js";
import {
  A,
  C,
  E,
  IEvents,
  Po,
  Qe,
  Qo,
  bases,
  destr,
  detect,
  esm_default,
  esm_exports,
  f,
  f2,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  getBigIntRpcId,
  i,
  import_pino,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  k,
  o,
  payloadId,
  r,
  require_cjs,
  require_cjs2,
  require_cjs3,
  safeJsonParse,
  safeJsonStringify,
  sn,
  y
} from "./chunk-3XXDLP5Z.js";
import {
  base32
} from "./chunk-AL7AZVTW.js";
import {
  clear,
  createStore,
  del,
  get,
  keys,
  set
} from "./chunk-ANJCMEYS.js";
import {
  require_events
} from "./chunk-SPJEADIR.js";
import {
  Chi,
  HashMD,
  Maj
} from "./chunk-JSOOL3TP.js";
import {
  BaseError,
  LruMap,
  checksumAddress,
  concat,
  defineFormatter,
  from,
  fromBoolean,
  fromBytes,
  fromNumber,
  fromString,
  fromString2,
  hexToBigInt,
  hexToNumber,
  isHex,
  keccak256,
  keccak_256,
  numberToHex,
  padLeft,
  padRight,
  size,
  size2,
  toHex as toHex2
} from "./chunk-ERP5CZPH.js";
import {
  clean,
  createHasher,
  rotl
} from "./chunk-TM73R3C3.js";
import {
  AccountController,
  AlertController,
  ApiController,
  AssetUtil,
  BlockchainApiController,
  ChainController,
  ConnectionController,
  ConnectionControllerUtil,
  ConnectorController,
  ConstantsUtil,
  ConstantsUtil2,
  CoreHelperUtil,
  EventsController,
  ModalController,
  NetworkUtil,
  OptionsController,
  ParseUtil,
  PublicStateController,
  RouterController,
  SendController,
  SnackController,
  StorageUtil,
  ThemeController,
  W3mFrameRpcConstants,
  getActiveCaipNetwork,
  getPreferredAccountType,
  getW3mThemeVariables
} from "./chunk-3UWUCAPZ.js";
import {
  toHex
} from "./chunk-LTYKXCV2.js";
import {
  __toESM
} from "./chunk-64NT3AJW.js";

// node_modules/@reown/appkit/dist/esm/src/networks/utils.js
function defineChain(chain) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...chain
  };
}

// node_modules/@reown/appkit/dist/esm/src/networks/solana/solana.js
var solana = defineChain({
  id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  name: "Solana",
  network: "solana-mainnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: false,
  chainNamespace: "solana",
  caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"
});

// node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaDevnet.js
var solanaDevnet = defineChain({
  id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  name: "Solana Devnet",
  network: "solana-devnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"
});

// node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaTestnet.js
var solanaTestnet = defineChain({
  id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  name: "Solana Testnet",
  network: "solana-testnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"
});

// node_modules/@reown/appkit/dist/esm/src/networks/bitcoin.js
var bitcoin = defineChain({
  id: "000000000019d6689c085ae165831e93",
  caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
  chainNamespace: "bip122",
  name: "Bitcoin",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  }
});
var bitcoinTestnet = defineChain({
  id: "000000000933ea01ad0ee984209779ba",
  caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
  chainNamespace: "bip122",
  name: "Bitcoin Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  testnet: true
});
var bitcoinSignet = defineChain({
  id: "00000008819873e925422c1ff0f99f7c",
  caipNetworkId: "bip122:00000008819873e925422c1ff0f99f7c",
  chainNamespace: "bip122",
  name: "Bitcoin Signet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  testnet: true
});

// node_modules/@reown/appkit/dist/esm/src/utils/HelpersUtil.js
var DEFAULT_METHODS = {
  solana: [
    "solana_signMessage",
    "solana_signTransaction",
    "solana_requestAccounts",
    "solana_getAccounts",
    "solana_signAllTransactions",
    "solana_signAndSendTransaction"
  ],
  eip155: [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    // EIP-5792
    "wallet_getCallsStatus",
    "wallet_showCallsStatus",
    "wallet_sendCalls",
    "wallet_getCapabilities",
    // EIP-7715
    "wallet_grantPermissions",
    "wallet_revokePermissions",
    //EIP-7811
    "wallet_getAssets"
  ],
  bip122: ["sendTransfer", "signMessage", "signPsbt", "getAccountAddresses"]
};
var WcHelpersUtil = {
  getMethodsByChainNamespace(chainNamespace) {
    return DEFAULT_METHODS[chainNamespace] || [];
  },
  createDefaultNamespace(chainNamespace) {
    return {
      methods: this.getMethodsByChainNamespace(chainNamespace),
      events: ["accountsChanged", "chainChanged"],
      chains: [],
      rpcMap: {}
    };
  },
  applyNamespaceOverrides(baseNamespaces, overrides) {
    if (!overrides) {
      return { ...baseNamespaces };
    }
    const result = { ...baseNamespaces };
    const namespacesToOverride = /* @__PURE__ */ new Set();
    if (overrides.methods) {
      Object.keys(overrides.methods).forEach((ns3) => namespacesToOverride.add(ns3));
    }
    if (overrides.chains) {
      Object.keys(overrides.chains).forEach((ns3) => namespacesToOverride.add(ns3));
    }
    if (overrides.events) {
      Object.keys(overrides.events).forEach((ns3) => namespacesToOverride.add(ns3));
    }
    if (overrides.rpcMap) {
      Object.keys(overrides.rpcMap).forEach((chainId) => {
        const [ns3] = chainId.split(":");
        if (ns3) {
          namespacesToOverride.add(ns3);
        }
      });
    }
    namespacesToOverride.forEach((ns3) => {
      if (!result[ns3]) {
        result[ns3] = this.createDefaultNamespace(ns3);
      }
    });
    if (overrides.methods) {
      Object.entries(overrides.methods).forEach(([ns3, methods]) => {
        if (result[ns3]) {
          result[ns3].methods = methods;
        }
      });
    }
    if (overrides.chains) {
      Object.entries(overrides.chains).forEach(([ns3, chains]) => {
        if (result[ns3]) {
          result[ns3].chains = chains;
        }
      });
    }
    if (overrides.events) {
      Object.entries(overrides.events).forEach(([ns3, events]) => {
        if (result[ns3]) {
          result[ns3].events = events;
        }
      });
    }
    if (overrides.rpcMap) {
      const processedNamespaces = /* @__PURE__ */ new Set();
      Object.entries(overrides.rpcMap).forEach(([chainId, rpcUrl]) => {
        const [ns3, id] = chainId.split(":");
        if (!ns3 || !id || !result[ns3]) {
          return;
        }
        if (!result[ns3].rpcMap) {
          result[ns3].rpcMap = {};
        }
        if (!processedNamespaces.has(ns3)) {
          result[ns3].rpcMap = {};
          processedNamespaces.add(ns3);
        }
        result[ns3].rpcMap[id] = rpcUrl;
      });
    }
    return result;
  },
  createNamespaces(caipNetworks, configOverride) {
    const defaultNamespaces = caipNetworks.reduce((acc, chain) => {
      const { id, chainNamespace, rpcUrls } = chain;
      const rpcUrl = rpcUrls.default.http[0];
      if (!acc[chainNamespace]) {
        acc[chainNamespace] = this.createDefaultNamespace(chainNamespace);
      }
      const caipNetworkId = `${chainNamespace}:${id}`;
      const namespace = acc[chainNamespace];
      namespace.chains.push(caipNetworkId);
      switch (caipNetworkId) {
        case solana.caipNetworkId:
          namespace.chains.push(solana.deprecatedCaipNetworkId);
          break;
        case solanaDevnet.caipNetworkId:
          namespace.chains.push(solanaDevnet.deprecatedCaipNetworkId);
          break;
        default:
      }
      if ((namespace == null ? void 0 : namespace.rpcMap) && rpcUrl) {
        namespace.rpcMap[id] = rpcUrl;
      }
      return acc;
    }, {});
    return this.applyNamespaceOverrides(defaultNamespaces, configOverride);
  },
  resolveReownName: async (name) => {
    var _a2;
    const wcNameAddress = await EnsController.resolveName(name);
    const networkNameAddresses = Object.values(wcNameAddress == null ? void 0 : wcNameAddress.addresses) || [];
    return ((_a2 = networkNameAddresses[0]) == null ? void 0 : _a2.address) || false;
  },
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const [chainNamespace, chainId] = account.split(":");
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  },
  isSessionEventData(data) {
    return typeof data === "object" && data !== null && "id" in data && "topic" in data && "params" in data && typeof data.params === "object" && data.params !== null && "chainId" in data.params && "event" in data.params && typeof data.params.event === "object" && data.params.event !== null;
  },
  isOriginAllowed(currentOrigin, allowedPatterns, defaultAllowedOrigins) {
    for (const pattern of [...allowedPatterns, ...defaultAllowedOrigins]) {
      if (pattern.includes("*")) {
        const escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
        const regexString = `^${escapedPattern.replace(/\\\*/gu, ".*")}$`;
        const regex = new RegExp(regexString, "u");
        if (regex.test(currentOrigin)) {
          return true;
        }
      } else {
        try {
          if (new URL(pattern).origin === currentOrigin) {
            return true;
          }
        } catch (e) {
          if (pattern === currentOrigin) {
            return true;
          }
        }
      }
    }
    return false;
  },
  listenWcProvider({ universalProvider, namespace, onConnect, onDisconnect, onAccountsChanged, onChainChanged, onDisplayUri }) {
    if (onConnect) {
      universalProvider.on("connect", () => {
        const accounts = WcHelpersUtil.getWalletConnectAccounts(universalProvider, namespace);
        onConnect(accounts);
      });
    }
    if (onDisconnect) {
      universalProvider.on("disconnect", () => {
        onDisconnect();
      });
    }
    if (onAccountsChanged) {
      universalProvider.on("accountsChanged", (accounts) => {
        var _a2, _b, _c2, _d, _e4;
        try {
          const allAccounts = ((_c2 = (_b = (_a2 = universalProvider.session) == null ? void 0 : _a2.namespaces) == null ? void 0 : _b[namespace]) == null ? void 0 : _c2.accounts) || [];
          const defaultChain = (_e4 = (_d = universalProvider.rpcProviders) == null ? void 0 : _d[namespace]) == null ? void 0 : _e4.getDefaultChain();
          const parsedAccounts = accounts.map((account) => {
            const caipAccount = allAccounts.find((acc) => acc.includes(`${namespace}:${defaultChain}:${account}`));
            if (!caipAccount) {
              return void 0;
            }
            const { chainId, chainNamespace } = ParseUtil.parseCaipAddress(caipAccount);
            return {
              address: account,
              chainId,
              chainNamespace
            };
          }).filter((account) => account !== void 0);
          if (parsedAccounts.length > 0) {
            onAccountsChanged(parsedAccounts);
          }
        } catch (error) {
          console.warn("Failed to parse accounts for namespace on accountsChanged event", namespace, accounts, error);
        }
      });
    }
    if (onChainChanged) {
      universalProvider.on("chainChanged", (chainId) => {
        onChainChanged(chainId);
      });
    }
    if (onDisplayUri) {
      universalProvider.on("display_uri", (uri) => {
        onDisplayUri(uri);
      });
    }
  },
  getWalletConnectAccounts(universalProvider, namespace) {
    var _a2, _b, _c2, _d;
    const accountsAdded = /* @__PURE__ */ new Set();
    const accounts = (_d = (_c2 = (_b = (_a2 = universalProvider == null ? void 0 : universalProvider.session) == null ? void 0 : _a2.namespaces) == null ? void 0 : _b[namespace]) == null ? void 0 : _c2.accounts) == null ? void 0 : _d.map((account) => ParseUtil.parseCaipAddress(account)).filter(({ address }) => {
      if (accountsAdded.has(address.toLowerCase())) {
        return false;
      }
      accountsAdded.add(address.toLowerCase());
      return true;
    });
    if (accounts && accounts.length > 0) {
      return accounts;
    }
    return [];
  }
};

// node_modules/@reown/appkit/dist/esm/src/utils/ConstantsUtil.js
var WcConstantsUtil = {
  ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
  ERROR_CODE_DEFAULT: 5e3,
  ERROR_INVALID_CHAIN_ID: 32603,
  DEFAULT_ALLOWED_ANCESTORS: [
    "http://localhost:*",
    "https://localhost:*",
    "http://127.0.0.1:*",
    "https://127.0.0.1:*",
    "https://*.pages.dev",
    "https://*.vercel.app",
    "https://*.ngrok-free.app",
    "https://secure-mobile.walletconnect.com",
    "https://secure-mobile.walletconnect.org"
  ]
};

// node_modules/@reown/appkit/dist/esm/src/auth-provider/W3MFrameProviderSingleton.js
var W3mFrameProviderSingleton = class _W3mFrameProviderSingleton {
  // eslint-disable-next-line @typescript-eslint/no-empty-function -- This is a singleton
  constructor() {
  }
  static getInstance({ projectId, chainId, enableLogger, onTimeout, abortController, getActiveCaipNetwork: getActiveCaipNetwork2, getCaipNetworks }) {
    var _a2;
    if (!_W3mFrameProviderSingleton.instance) {
      _W3mFrameProviderSingleton.instance = new W3mFrameProvider({
        projectId,
        chainId,
        enableLogger,
        onTimeout,
        abortController,
        getActiveCaipNetwork: getActiveCaipNetwork2,
        getCaipNetworks,
        enableCloudAuthAccount: Boolean((_a2 = OptionsController.state.remoteFeatures) == null ? void 0 : _a2.emailCapture)
      });
    }
    return _W3mFrameProviderSingleton.instance;
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/core/dist/index.es.js
var import_events3 = __toESM(require_events());

// node_modules/@reown/appkit/node_modules/unstorage/dist/shared/unstorage.zVDD2mZo.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c4) => c4.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey(key) {
  var _a2;
  if (!key) {
    return "";
  }
  return ((_a2 = key.split("?")[0]) == null ? void 0 : _a2.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base) {
  base = normalizeKey(base);
  return base ? base + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base) {
  if (base) {
    return key.startsWith(base) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

// node_modules/@reown/appkit/node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base of context.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r2) => r2.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r2) => r2.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      var _a2;
      base = normalizeBaseKey(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!((_a2 = mount.driver.flags) == null ? void 0 : _a2.maxDepth)) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p2) => fullKey.startsWith(p2))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p2) => !p2.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base)
      );
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey(base);
      await Promise.all(
        getMounts(base, false).map(async (m2) => {
          if (m2.driver.clear) {
            return asyncCall(m2.driver.clear, m2.relativeBase, opts);
          }
          if (m2.driver.removeItem) {
            const keys2 = await m2.driver.getKeys(m2.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m2.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey(base);
      if (base && context.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context.mountpoints.push(base);
        context.mountpoints.sort((a2, b3) => b3.length - a2.length);
      }
      context.mounts[base] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {
          context.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      var _a2, _b;
      base = normalizeBaseKey(base);
      if (!base || !context.mounts[base]) {
        return;
      }
      if (context.watching && base in context.unwatch) {
        (_b = (_a2 = context.unwatch)[base]) == null ? void 0 : _b.call(_a2);
        delete context.unwatch[base];
      }
      if (_dispose) {
        await dispose(context.mounts[base]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base);
      delete context.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m2 = getMount(key);
      return {
        driver: m2.driver,
        base: m2.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m2) => ({
        driver: m2.driver,
        base: m2.mountpoint
      }));
    },
    // Aliases
    keys: (base, opts = {}) => storage.getKeys(base, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/@reown/appkit/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x = "idb-keyval";
var z = (i3 = {}) => {
  const t = i3.base && i3.base.length > 0 ? `${i3.base}:` : "", e = (s) => t + s;
  let n2;
  return i3.dbName && i3.storeName && (n2 = createStore(i3.dbName, i3.storeName)), { name: x, options: i3, async hasItem(s) {
    return !(typeof await get(e(s), n2) > "u");
  }, async getItem(s) {
    return await get(e(s), n2) ?? null;
  }, setItem(s, a2) {
    return set(e(s), a2, n2);
  }, removeItem(s) {
    return del(e(s), n2);
  }, getKeys() {
    return keys(n2);
  }, clear() {
    return clear(n2);
  } };
};
var D = "WALLET_CONNECT_V2_INDEXED_DB";
var E2 = "keyvaluestorage";
var _ = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z({ dbName: D, storeName: E2 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e = await this.indexedDb.getItem(t);
    if (e !== null) return e;
  }
  async setItem(t, e) {
    await this.indexedDb.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i3;
  function t() {
  }
  i3 = t, i3.prototype.getItem = function(e) {
    return this.hasOwnProperty(e) ? String(this[e]) : null;
  }, i3.prototype.setItem = function(e, n2) {
    this[e] = String(n2);
  }, i3.prototype.removeItem = function(e) {
    delete this[e];
  }, i3.prototype.clear = function() {
    const e = this;
    Object.keys(e).forEach(function(n2) {
      e[n2] = void 0, delete e[n2];
    });
  }, i3.prototype.key = function(e) {
    return e = e || 0, Object.keys(this)[e];
  }, i3.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l < "u" && l.localStorage ? c.exports = l.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
})();
function k2(i3) {
  var t;
  return [i3[0], safeJsonParse((t = i3[1]) != null ? t : "")];
}
var K = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k2);
  }
  async getItem(t) {
    const e = this.localStorage.getItem(t);
    if (e !== null) return safeJsonParse(e);
  }
  async setItem(t, e) {
    this.localStorage.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N = "wc_storage_version";
var y2 = 1;
var O = async (i3, t, e) => {
  const n2 = N, s = await t.getItem(n2);
  if (s && s >= y2) {
    e(t);
    return;
  }
  const a2 = await i3.getKeys();
  if (!a2.length) {
    e(t);
    return;
  }
  const m2 = [];
  for (; a2.length; ) {
    const r2 = a2.shift();
    if (!r2) continue;
    const o2 = r2.toLowerCase();
    if (o2.includes("wc@") || o2.includes("walletconnect") || o2.includes("wc_") || o2.includes("wallet_connect")) {
      const f7 = await i3.getItem(r2);
      await t.setItem(r2, f7), m2.push(r2);
    }
  }
  await t.setItem(n2, y2), e(t), j(i3, m2);
};
var j = async (i3, t) => {
  t.length && t.forEach(async (e) => {
    await i3.removeItem(e);
  });
};
var h = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e) => {
      this.storage = e, this.initialized = true;
    };
    const t = new K();
    this.storage = t;
    try {
      const e = new _();
      O(t, e, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e) {
    return await this.initialize(), this.storage.setItem(t, e);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e = setInterval(() => {
        this.initialized && (clearInterval(e), t());
      }, 20);
    });
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/types/dist/index.es.js
var import_events2 = __toESM(require_events());
var a = Object.defineProperty;
var u = (e, s, r2) => s in e ? a(e, s, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s] = r2;
var c2 = (e, s, r2) => u(e, typeof s != "symbol" ? s + "" : s, r2);
var h2 = class extends IEvents {
  constructor(s) {
    super(), this.opts = s, c2(this, "protocol", "wc"), c2(this, "version", 2);
  }
};
var p = Object.defineProperty;
var b = (e, s, r2) => s in e ? p(e, s, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s] = r2;
var v = (e, s, r2) => b(e, typeof s != "symbol" ? s + "" : s, r2);
var I = class extends IEvents {
  constructor(s, r2) {
    super(), this.core = s, this.logger = r2, v(this, "records", /* @__PURE__ */ new Map());
  }
};
var y3 = class {
  constructor(s, r2) {
    this.logger = s, this.core = r2;
  }
};
var m = class extends IEvents {
  constructor(s, r2) {
    super(), this.relayer = s, this.logger = r2;
  }
};
var d = class extends IEvents {
  constructor(s) {
    super();
  }
};
var f3 = class {
  constructor(s, r2, t, q3) {
    this.core = s, this.logger = r2, this.name = t;
  }
};
var P = class extends IEvents {
  constructor(s, r2) {
    super(), this.relayer = s, this.logger = r2;
  }
};
var S = class extends IEvents {
  constructor(s, r2) {
    super(), this.core = s, this.logger = r2;
  }
};
var M = class {
  constructor(s, r2, t) {
    this.core = s, this.logger = r2, this.store = t;
  }
};
var O2 = class {
  constructor(s, r2) {
    this.projectId = s, this.logger = r2;
  }
};
var R = class {
  constructor(s, r2, t) {
    this.core = s, this.logger = r2, this.telemetryEnabled = t;
  }
};
var T = Object.defineProperty;
var k3 = (e, s, r2) => s in e ? T(e, s, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s] = r2;
var i2 = (e, s, r2) => k3(e, typeof s != "symbol" ? s + "" : s, r2);
var J = class {
  constructor(s) {
    this.opts = s, i2(this, "protocol", "wc"), i2(this, "version", 2);
  }
};
var V = class {
  constructor(s) {
    this.client = s;
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
function publicKeyToAddress(publicKey) {
  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverPublicKey.js
async function recoverPublicKey({ hash, signature }) {
  const hashHex = isHex(hash) ? hash : toHex2(hash);
  const { secp256k1: secp256k12 } = await import("./secp256k1-66HVVEOW.js");
  const signature_ = (() => {
    if (typeof signature === "object" && "r" in signature && "s" in signature) {
      const { r: r2, s, v: v3, yParity } = signature;
      const yParityOrV2 = Number(yParity ?? v3);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k12.Signature(hexToBigInt(r2), hexToBigInt(s)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature) ? signature : toHex2(signature);
    if (size(signatureHex) !== 65)
      throw new Error("invalid signature length");
    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress({ hash, signature }) {
  return publicKeyToAddress(await recoverPublicKey({ hash, signature }));
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [
      address,
      typeof blockNumber === "bigint" ? numberToHex(blockNumber) : blockTag
    ]
  }, {
    dedupe: Boolean(blockNumber)
  });
  return hexToNumber(count);
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendCalls.js
var fallbackTransactionErrorMagicIdentifier = numberToHex(0, {
  size: 32
});

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache = new LruMap(8192);

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/@reown/appkit/node_modules/@noble/hashes/esm/legacy.js
var SHA1_IV = Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = new Uint32Array(80);
var SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    this.A = SHA1_IV[0] | 0;
    this.B = SHA1_IV[1] | 0;
    this.C = SHA1_IV[2] | 0;
    this.D = SHA1_IV[3] | 0;
    this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: A4, B: B3, C: C4, D: D4, E: E4 } = this;
    return [A4, B3, C4, D4, E4];
  }
  set(A4, B3, C4, D4, E4) {
    this.A = A4 | 0;
    this.B = B3 | 0;
    this.C = C4 | 0;
    this.D = D4 | 0;
    this.E = E4 | 0;
  }
  process(view, offset) {
    for (let i3 = 0; i3 < 16; i3++, offset += 4)
      SHA1_W[i3] = view.getUint32(offset, false);
    for (let i3 = 16; i3 < 80; i3++)
      SHA1_W[i3] = rotl(SHA1_W[i3 - 3] ^ SHA1_W[i3 - 8] ^ SHA1_W[i3 - 14] ^ SHA1_W[i3 - 16], 1);
    let { A: A4, B: B3, C: C4, D: D4, E: E4 } = this;
    for (let i3 = 0; i3 < 80; i3++) {
      let F4, K5;
      if (i3 < 20) {
        F4 = Chi(B3, C4, D4);
        K5 = 1518500249;
      } else if (i3 < 40) {
        F4 = B3 ^ C4 ^ D4;
        K5 = 1859775393;
      } else if (i3 < 60) {
        F4 = Maj(B3, C4, D4);
        K5 = 2400959708;
      } else {
        F4 = B3 ^ C4 ^ D4;
        K5 = 3395469782;
      }
      const T3 = rotl(A4, 5) + F4 + E4 + K5 + SHA1_W[i3] | 0;
      E4 = D4;
      D4 = C4;
      C4 = rotl(B3, 30);
      B3 = A4;
      A4 = T3;
    }
    A4 = A4 + this.A | 0;
    B3 = B3 + this.B | 0;
    C4 = C4 + this.C | 0;
    D4 = D4 + this.D | 0;
    E4 = E4 + this.E | 0;
    this.set(A4, B3, C4, D4, E4);
  }
  roundClean() {
    clean(SHA1_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var sha1 = createHasher(() => new SHA1());
var p32 = Math.pow(2, 32);
var K2 = Array.from({ length: 64 }, (_2, i3) => Math.floor(p32 * Math.abs(Math.sin(i3 + 1))));
var MD5_IV = SHA1_IV.slice(0, 4);
var MD5_W = new Uint32Array(16);
var MD5 = class extends HashMD {
  constructor() {
    super(64, 16, 8, true);
    this.A = MD5_IV[0] | 0;
    this.B = MD5_IV[1] | 0;
    this.C = MD5_IV[2] | 0;
    this.D = MD5_IV[3] | 0;
  }
  get() {
    const { A: A4, B: B3, C: C4, D: D4 } = this;
    return [A4, B3, C4, D4];
  }
  set(A4, B3, C4, D4) {
    this.A = A4 | 0;
    this.B = B3 | 0;
    this.C = C4 | 0;
    this.D = D4 | 0;
  }
  process(view, offset) {
    for (let i3 = 0; i3 < 16; i3++, offset += 4)
      MD5_W[i3] = view.getUint32(offset, true);
    let { A: A4, B: B3, C: C4, D: D4 } = this;
    for (let i3 = 0; i3 < 64; i3++) {
      let F4, g2, s;
      if (i3 < 16) {
        F4 = Chi(B3, C4, D4);
        g2 = i3;
        s = [7, 12, 17, 22];
      } else if (i3 < 32) {
        F4 = Chi(D4, B3, C4);
        g2 = (5 * i3 + 1) % 16;
        s = [5, 9, 14, 20];
      } else if (i3 < 48) {
        F4 = B3 ^ C4 ^ D4;
        g2 = (3 * i3 + 5) % 16;
        s = [4, 11, 16, 23];
      } else {
        F4 = C4 ^ (B3 | ~D4);
        g2 = 7 * i3 % 16;
        s = [6, 10, 15, 21];
      }
      F4 = F4 + A4 + K2[i3] + MD5_W[g2];
      A4 = D4;
      D4 = C4;
      C4 = B3;
      B3 = B3 + rotl(F4, s[i3 % 4]);
    }
    A4 = A4 + this.A | 0;
    B3 = B3 + this.B | 0;
    C4 = C4 + this.C | 0;
    D4 = D4 + this.D | 0;
    this.set(A4, B3, C4, D4);
  }
  roundClean() {
    clean(MD5_W);
  }
  destroy() {
    this.set(0, 0, 0, 0);
    clean(this.buffer);
  }
};
var md5 = createHasher(() => new MD5());
var Rho160 = Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_2, i3) => i3)))();
var Pi160 = (() => Id160.map((i3) => (9 * i3 + 5) % 16))();
var idxLR = (() => {
  const L2 = [Id160];
  const R4 = [Pi160];
  const res = [L2, R4];
  for (let i3 = 0; i3 < 4; i3++)
    for (let j3 of res)
      j3.push(j3[i3].map((k4) => Rho160[k4]));
  return res;
})();
var idxL = (() => idxLR[0])();
var idxR = (() => idxLR[1])();
var shifts160 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i3) => Uint8Array.from(i3));
var shiftsL160 = idxL.map((idx, i3) => idx.map((j3) => shifts160[i3][j3]));
var shiftsR160 = idxR.map((idx, i3) => idx.map((j3) => shifts160[i3][j3]));
var Kl160 = Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x4, y5, z3) {
  if (group === 0)
    return x4 ^ y5 ^ z3;
  if (group === 1)
    return x4 & y5 | ~x4 & z3;
  if (group === 2)
    return (x4 | ~y5) ^ z3;
  if (group === 3)
    return x4 & z3 | y5 & ~z3;
  return x4 ^ (y5 | ~z3);
}
var BUF_160 = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3: h32, h4 } = this;
    return [h0, h1, h22, h32, h4];
  }
  set(h0, h1, h22, h32, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h32 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i3 = 0; i3 < 16; i3++, offset += 4)
      BUF_160[i3] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar2 = al, bl = this.h1 | 0, br3 = bl, cl = this.h2 | 0, cr3 = cl, dl = this.h3 | 0, dr3 = dl, el = this.h4 | 0, er2 = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr3 = idxR[group];
      const sl = shiftsL160[group], sr2 = shiftsR160[group];
      for (let i3 = 0; i3 < 16; i3++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i3]] + hbl, sl[i3]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i3 = 0; i3 < 16; i3++) {
        const tr2 = rotl(ar2 + ripemd_f(rGroup, br3, cr3, dr3) + BUF_160[rr3[i3]] + hbr, sr2[i3]) + er2 | 0;
        ar2 = er2, er2 = dr3, dr3 = rotl(cr3, 10) | 0, cr3 = br3, br3 = tr2;
      }
    }
    this.set(this.h1 + cl + dr3 | 0, this.h2 + dl + er2 | 0, this.h3 + el + ar2 | 0, this.h4 + al + br3 | 0, this.h0 + bl + cr3 | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = createHasher(() => new RIPEMD160());

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager = createNonceManager({
  source: jsonRpc()
});

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Hash.js
function keccak2562(value, options = {}) {
  const { as: as3 = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const bytes = keccak_256(from(value));
  if (as3 === "Bytes")
    return bytes;
  return fromBytes(bytes);
}

// node_modules/@reown/appkit/node_modules/ox/_esm/core/internal/lru.js
var LruMap2 = class extends Map {
  constructor(size4) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size4;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== void 0) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Caches.js
var caches = {
  checksum: new LruMap2(8192)
};
var checksum = caches.checksum;

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Address.js
var addressRegex = /^0x[a-fA-F0-9]{40}$/;
function assert(value, options = {}) {
  const { strict = true } = options;
  if (!addressRegex.test(value))
    throw new InvalidAddressError2({
      address: value,
      cause: new InvalidInputError()
    });
  if (strict) {
    if (value.toLowerCase() === value)
      return;
    if (checksum2(value) !== value)
      throw new InvalidAddressError2({
        address: value,
        cause: new InvalidChecksumError()
      });
  }
}
function checksum2(address) {
  if (checksum.has(address))
    return checksum.get(address);
  assert(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash = keccak2562(fromString(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i3 = 0; i3 < 40; i3 += 2) {
    if (hash[i3 >> 1] >> 4 >= 8 && characters[i3]) {
      characters[i3] = characters[i3].toUpperCase();
    }
    if ((hash[i3 >> 1] & 15) >= 8 && characters[i3 + 1]) {
      characters[i3 + 1] = characters[i3 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum.set(address, result);
  return result;
}
var InvalidAddressError2 = class extends BaseError {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError = class extends BaseError {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError = class extends BaseError {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Solidity.js
var arrayRegex2 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt8 = 2n ** (8n - 1n) - 1n;
var maxInt16 = 2n ** (16n - 1n) - 1n;
var maxInt24 = 2n ** (24n - 1n) - 1n;
var maxInt32 = 2n ** (32n - 1n) - 1n;
var maxInt40 = 2n ** (40n - 1n) - 1n;
var maxInt48 = 2n ** (48n - 1n) - 1n;
var maxInt56 = 2n ** (56n - 1n) - 1n;
var maxInt64 = 2n ** (64n - 1n) - 1n;
var maxInt72 = 2n ** (72n - 1n) - 1n;
var maxInt80 = 2n ** (80n - 1n) - 1n;
var maxInt88 = 2n ** (88n - 1n) - 1n;
var maxInt96 = 2n ** (96n - 1n) - 1n;
var maxInt104 = 2n ** (104n - 1n) - 1n;
var maxInt112 = 2n ** (112n - 1n) - 1n;
var maxInt120 = 2n ** (120n - 1n) - 1n;
var maxInt128 = 2n ** (128n - 1n) - 1n;
var maxInt136 = 2n ** (136n - 1n) - 1n;
var maxInt144 = 2n ** (144n - 1n) - 1n;
var maxInt152 = 2n ** (152n - 1n) - 1n;
var maxInt160 = 2n ** (160n - 1n) - 1n;
var maxInt168 = 2n ** (168n - 1n) - 1n;
var maxInt176 = 2n ** (176n - 1n) - 1n;
var maxInt184 = 2n ** (184n - 1n) - 1n;
var maxInt192 = 2n ** (192n - 1n) - 1n;
var maxInt200 = 2n ** (200n - 1n) - 1n;
var maxInt208 = 2n ** (208n - 1n) - 1n;
var maxInt216 = 2n ** (216n - 1n) - 1n;
var maxInt224 = 2n ** (224n - 1n) - 1n;
var maxInt232 = 2n ** (232n - 1n) - 1n;
var maxInt240 = 2n ** (240n - 1n) - 1n;
var maxInt248 = 2n ** (248n - 1n) - 1n;
var maxInt256 = 2n ** (256n - 1n) - 1n;
var minInt8 = -(2n ** (8n - 1n));
var minInt16 = -(2n ** (16n - 1n));
var minInt24 = -(2n ** (24n - 1n));
var minInt32 = -(2n ** (32n - 1n));
var minInt40 = -(2n ** (40n - 1n));
var minInt48 = -(2n ** (48n - 1n));
var minInt56 = -(2n ** (56n - 1n));
var minInt64 = -(2n ** (64n - 1n));
var minInt72 = -(2n ** (72n - 1n));
var minInt80 = -(2n ** (80n - 1n));
var minInt88 = -(2n ** (88n - 1n));
var minInt96 = -(2n ** (96n - 1n));
var minInt104 = -(2n ** (104n - 1n));
var minInt112 = -(2n ** (112n - 1n));
var minInt120 = -(2n ** (120n - 1n));
var minInt128 = -(2n ** (128n - 1n));
var minInt136 = -(2n ** (136n - 1n));
var minInt144 = -(2n ** (144n - 1n));
var minInt152 = -(2n ** (152n - 1n));
var minInt160 = -(2n ** (160n - 1n));
var minInt168 = -(2n ** (168n - 1n));
var minInt176 = -(2n ** (176n - 1n));
var minInt184 = -(2n ** (184n - 1n));
var minInt192 = -(2n ** (192n - 1n));
var minInt200 = -(2n ** (200n - 1n));
var minInt208 = -(2n ** (208n - 1n));
var minInt216 = -(2n ** (216n - 1n));
var minInt224 = -(2n ** (224n - 1n));
var minInt232 = -(2n ** (232n - 1n));
var minInt240 = -(2n ** (240n - 1n));
var minInt248 = -(2n ** (248n - 1n));
var minInt256 = -(2n ** (256n - 1n));
var maxUint8 = 2n ** 8n - 1n;
var maxUint16 = 2n ** 16n - 1n;
var maxUint24 = 2n ** 24n - 1n;
var maxUint32 = 2n ** 32n - 1n;
var maxUint40 = 2n ** 40n - 1n;
var maxUint48 = 2n ** 48n - 1n;
var maxUint56 = 2n ** 56n - 1n;
var maxUint64 = 2n ** 64n - 1n;
var maxUint72 = 2n ** 72n - 1n;
var maxUint80 = 2n ** 80n - 1n;
var maxUint88 = 2n ** 88n - 1n;
var maxUint96 = 2n ** 96n - 1n;
var maxUint104 = 2n ** 104n - 1n;
var maxUint112 = 2n ** 112n - 1n;
var maxUint120 = 2n ** 120n - 1n;
var maxUint128 = 2n ** 128n - 1n;
var maxUint136 = 2n ** 136n - 1n;
var maxUint144 = 2n ** 144n - 1n;
var maxUint152 = 2n ** 152n - 1n;
var maxUint160 = 2n ** 160n - 1n;
var maxUint168 = 2n ** 168n - 1n;
var maxUint176 = 2n ** 176n - 1n;
var maxUint184 = 2n ** 184n - 1n;
var maxUint192 = 2n ** 192n - 1n;
var maxUint200 = 2n ** 200n - 1n;
var maxUint208 = 2n ** 208n - 1n;
var maxUint216 = 2n ** 216n - 1n;
var maxUint224 = 2n ** 224n - 1n;
var maxUint232 = 2n ** 232n - 1n;
var maxUint240 = 2n ** 240n - 1n;
var maxUint248 = 2n ** 248n - 1n;
var maxUint2562 = 2n ** 256n - 1n;

// node_modules/@reown/appkit/node_modules/ox/_esm/core/internal/cursor.js
var staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError2({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length, size4) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length);
    this.position += size4 ?? length;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
var NegativeOffsetError = class extends BaseError {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError2 = class extends BaseError {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError = class extends BaseError {
  constructor({ count, limit }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/ox/_esm/core/AbiParameters.js
function encodePacked2(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i3 = 0; i3 < types.length; i3++) {
    const type = types[i3];
    const value = values[i3];
    data.push(encodePacked2.encode(type, value));
  }
  return concat(...data);
}
(function(encodePacked3) {
  function encode5(type, value, isArray = false) {
    if (type === "address") {
      const address = value;
      assert(address);
      return padLeft(address.toLowerCase(), isArray ? 32 : 0);
    }
    if (type === "string")
      return fromString2(value);
    if (type === "bytes")
      return value;
    if (type === "bool")
      return padLeft(fromBoolean(value), isArray ? 32 : 1);
    const intMatch = type.match(integerRegex2);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size4 = Number.parseInt(bits) / 8;
      return fromNumber(value, {
        size: isArray ? 32 : size4,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(bytesRegex2);
    if (bytesMatch) {
      const [_type, size4] = bytesMatch;
      if (Number.parseInt(size4) !== (value.length - 2) / 2)
        throw new BytesSizeMismatchError2({
          expectedSize: Number.parseInt(size4),
          value
        });
      return padRight(value, isArray ? 32 : 0);
    }
    const arrayMatch = type.match(arrayRegex2);
    if (arrayMatch && Array.isArray(value)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i3 = 0; i3 < value.length; i3++) {
        data.push(encode5(childType, value[i3], true));
      }
      if (data.length === 0)
        return "0x";
      return concat(...data);
    }
    throw new InvalidTypeError(type);
  }
  encodePacked3.encode = encode5;
})(encodePacked2 || (encodePacked2 = {}));
var BytesSizeMismatchError2 = class extends BaseError {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size2(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError = class extends BaseError {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidTypeError = class extends BaseError {
  constructor(type) {
    super(`Type \`${type}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/@reown/appkit/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size4 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size4));
  }
  return new Uint8Array(size4);
}

// node_modules/@reown/appkit/node_modules/uint8arrays/esm/src/concat.js
function concat3(arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}

// node_modules/@reown/appkit/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name, prefix, encode5, decode3) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode: encode5
    },
    decoder: { decode: decode3 }
  };
}
var string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i3 = 0; i3 < buf.length; i3++) {
    string2 += String.fromCharCode(buf[i3]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i3 = 0; i3 < str.length; i3++) {
    buf[i3] = str.charCodeAt(i3);
  }
  return buf;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/@reown/appkit/node_modules/uint8arrays/esm/src/from-string.js
function fromString3(string2, encoding = "utf8") {
  const base = bases_default[encoding];
  if (!base) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base.decoder.decode(`${base.prefix}${string2}`);
}

// node_modules/@reown/appkit/node_modules/uint8arrays/esm/src/to-string.js
function toString2(array, encoding = "utf8") {
  const base = bases_default[encoding];
  if (!base) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base.encoder.encode(array).substring(1);
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/dist/index.es.js
var import_blakejs = __toESM(require_blakejs());
var xe = ":";
function Fe(t) {
  const [e, n2] = t.split(xe);
  return { namespace: e, reference: n2 };
}
function ve(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
var $s = Object.defineProperty;
var Cs = Object.defineProperties;
var Ls = Object.getOwnPropertyDescriptors;
var Jn = Object.getOwnPropertySymbols;
var js = Object.prototype.hasOwnProperty;
var ks = Object.prototype.propertyIsEnumerable;
var Ze = (t, e, n2) => e in t ? $s(t, e, { enumerable: true, configurable: true, writable: true, value: n2 }) : t[e] = n2;
var Qn = (t, e) => {
  for (var n2 in e || (e = {})) js.call(e, n2) && Ze(t, n2, e[n2]);
  if (Jn) for (var n2 of Jn(e)) ks.call(e, n2) && Ze(t, n2, e[n2]);
  return t;
};
var Ps = (t, e) => Cs(t, Ls(e));
var tr = (t, e, n2) => Ze(t, typeof e != "symbol" ? e + "" : e, n2);
var er = "ReactNative";
var J2 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var rr = "js";
function Ye() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function Bt() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === er;
}
function Ms() {
  return Bt() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function Vs() {
  return Bt() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function zt() {
  return !Ye() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function Pt() {
  return Bt() ? J2.reactNative : Ye() ? J2.node : zt() ? J2.browser : J2.unknown;
}
function qs() {
  var t;
  try {
    return Bt() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0;
  } catch {
    return;
  }
}
function or(t, e) {
  const n2 = new URLSearchParams(t);
  for (const r2 of Object.keys(e).sort()) if (e.hasOwnProperty(r2)) {
    const o2 = e[r2];
    o2 !== void 0 && n2.set(r2, o2);
  }
  return n2.toString();
}
function Ks(t) {
  var e, n2;
  const r2 = sr();
  try {
    return t != null && t.url && r2.url && new URL(t.url).host !== new URL(r2.url).host && (console.warn(`The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${r2.url}. This is probably unintended and can lead to issues.`), t.url = r2.url), (e = t == null ? void 0 : t.icons) != null && e.length && t.icons.length > 0 && (t.icons = t.icons.filter((o2) => o2 !== "")), Ps(Qn(Qn({}, r2), t), { url: (t == null ? void 0 : t.url) || r2.url, name: (t == null ? void 0 : t.name) || r2.name, description: (t == null ? void 0 : t.description) || r2.description, icons: (n2 = t == null ? void 0 : t.icons) != null && n2.length && t.icons.length > 0 ? t.icons : r2.icons });
  } catch (o2) {
    return console.warn("Error populating app metadata", o2), t || r2;
  }
}
function sr() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function ir() {
  if (Pt() === J2.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: n2, Version: r2 } = global.Platform;
    return [n2, r2].join("-");
  }
  const t = detect();
  if (t === null) return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-");
}
function fr() {
  var t;
  const e = Pt();
  return e === J2.browser ? [e, ((t = (0, import_window_getters.getLocation)()) == null ? void 0 : t.host) || "unknown"].join(":") : e;
}
function cr(t, e, n2) {
  const r2 = ir(), o2 = fr();
  return [[t, e].join("-"), [rr, n2].join("-"), r2, o2].join("/");
}
function zs({ protocol: t, version: e, relayUrl: n2, sdkVersion: r2, auth: o2, projectId: s, useOnCloseEvent: i3, bundleId: f7, packageName: a2 }) {
  const l4 = n2.split("?"), c4 = cr(t, e, r2), u3 = { auth: o2, ua: c4, projectId: s, useOnCloseEvent: i3 || void 0, packageName: a2 || void 0, bundleId: f7 || void 0 }, h4 = or(l4[1] || "", u3);
  return l4[0] + "?" + h4;
}
function It(t, e) {
  return t.filter((n2) => e.includes(n2)).length === t.length;
}
function Ys(t) {
  return Object.fromEntries(t.entries());
}
function Xs(t) {
  return new Map(Object.entries(t));
}
function ei(t = import_time.FIVE_MINUTES, e) {
  const n2 = (0, import_time.toMiliseconds)(t || import_time.FIVE_MINUTES);
  let r2, o2, s, i3;
  return { resolve: (f7) => {
    s && r2 && (clearTimeout(s), r2(f7), i3 = Promise.resolve(f7));
  }, reject: (f7) => {
    s && o2 && (clearTimeout(s), o2(f7));
  }, done: () => new Promise((f7, a2) => {
    if (i3) return f7(i3);
    s = setTimeout(() => {
      const l4 = new Error(e);
      i3 = Promise.reject(l4), a2(l4);
    }, n2), r2 = f7, o2 = a2;
  }) };
}
function ni(t, e, n2) {
  return new Promise(async (r2, o2) => {
    const s = setTimeout(() => o2(new Error(n2)), e);
    try {
      const i3 = await t;
      r2(i3);
    } catch (i3) {
      o2(i3);
    }
    clearTimeout(s);
  });
}
function Xe(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function ri(t) {
  return Xe("topic", t);
}
function oi(t) {
  return Xe("id", t);
}
function si(t) {
  const [e, n2] = t.split(":"), r2 = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof n2 == "string") r2.topic = n2;
  else if (e === "id" && Number.isInteger(Number(n2))) r2.id = Number(n2);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${n2}`);
  return r2;
}
function ii(t, e) {
  return (0, import_time.fromMiliseconds)((e || Date.now()) + (0, import_time.toMiliseconds)(t));
}
function fi(t) {
  return Date.now() >= (0, import_time.toMiliseconds)(t);
}
function ci(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
function ct(t = [], e = []) {
  return [.../* @__PURE__ */ new Set([...t, ...e])];
}
async function ai({ id: t, topic: e, wcDeepLink: n2 }) {
  var r2;
  try {
    if (!n2) return;
    const o2 = typeof n2 == "string" ? JSON.parse(n2) : n2, s = o2 == null ? void 0 : o2.href;
    if (typeof s != "string") return;
    const i3 = dr(s, t, e), f7 = Pt();
    if (f7 === J2.browser) {
      if (!((r2 = (0, import_window_getters.getDocument)()) != null && r2.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      hr(i3);
    } else f7 === J2.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(i3);
  } catch (o2) {
    console.error(o2);
  }
}
function dr(t, e, n2) {
  const r2 = `requestId=${e}&sessionTopic=${n2}`;
  t.endsWith("/") && (t = t.slice(0, -1));
  let o2 = `${t}`;
  if (t.startsWith("https://t.me")) {
    const s = t.includes("?") ? "&startapp=" : "?startapp=";
    o2 = `${o2}${s}${br(r2, true)}`;
  } else o2 = `${o2}/wc?${r2}`;
  return o2;
}
function hr(t) {
  let e = "_self";
  gr() ? e = "_top" : (pr() || t.startsWith("https://") || t.startsWith("http://")) && (e = "_blank"), window.open(t, e, "noreferrer noopener");
}
async function ui(t, e) {
  let n2 = "";
  try {
    if (zt() && (n2 = localStorage.getItem(e), n2)) return n2;
    n2 = await t.getItem(e);
  } catch (r2) {
    console.error(r2);
  }
  return n2;
}
function li(t, e) {
  if (!t.includes(e)) return null;
  const n2 = t.split(/([&,?,=])/), r2 = n2.indexOf(e);
  return n2[r2 + 2];
}
function di() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
    const e = Math.random() * 16 | 0;
    return (t === "x" ? e : e & 3 | 8).toString(16);
  });
}
function hi() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function pr() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function gr() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function br(t, e = false) {
  const n2 = Buffer.from(t).toString("base64");
  return e ? n2.replace(/[=]/g, "") : n2;
}
function Qe2(t) {
  return Buffer.from(t, "base64").toString("utf-8");
}
function pi(t) {
  return new Promise((e) => setTimeout(e, t));
}
var gi = class {
  constructor({ limit: e }) {
    tr(this, "limit"), tr(this, "set"), this.limit = e, this.set = /* @__PURE__ */ new Set();
  }
  add(e) {
    if (!this.set.has(e)) {
      if (this.set.size >= this.limit) {
        const n2 = this.set.values().next().value;
        n2 && this.set.delete(n2);
      }
      this.set.add(e);
    }
  }
  has(e) {
    return this.set.has(e);
  }
};
var Be = BigInt(2 ** 32 - 1);
var yr = BigInt(32);
function mr(t, e = false) {
  return e ? { h: Number(t & Be), l: Number(t >> yr & Be) } : { h: Number(t >> yr & Be) | 0, l: Number(t & Be) | 0 };
}
function wr(t, e = false) {
  const n2 = t.length;
  let r2 = new Uint32Array(n2), o2 = new Uint32Array(n2);
  for (let s = 0; s < n2; s++) {
    const { h: i3, l: f7 } = mr(t[s], e);
    [r2[s], o2[s]] = [i3, f7];
  }
  return [r2, o2];
}
var xr = (t, e, n2) => t >>> n2;
var vr = (t, e, n2) => t << 32 - n2 | e >>> n2;
var At = (t, e, n2) => t >>> n2 | e << 32 - n2;
var St = (t, e, n2) => t << 32 - n2 | e >>> n2;
var se = (t, e, n2) => t << 64 - n2 | e >>> n2 - 32;
var ie = (t, e, n2) => t >>> n2 - 32 | e << 64 - n2;
var bi = (t, e) => e;
var yi = (t, e) => t;
var mi = (t, e, n2) => t << n2 | e >>> 32 - n2;
var wi = (t, e, n2) => e << n2 | t >>> 32 - n2;
var xi = (t, e, n2) => e << n2 - 32 | t >>> 64 - n2;
var vi = (t, e, n2) => t << n2 - 32 | e >>> 64 - n2;
function dt(t, e, n2, r2) {
  const o2 = (e >>> 0) + (r2 >>> 0);
  return { h: t + n2 + (o2 / 2 ** 32 | 0) | 0, l: o2 | 0 };
}
var tn = (t, e, n2) => (t >>> 0) + (e >>> 0) + (n2 >>> 0);
var en = (t, e, n2, r2) => e + n2 + r2 + (t / 2 ** 32 | 0) | 0;
var Ei = (t, e, n2, r2) => (t >>> 0) + (e >>> 0) + (n2 >>> 0) + (r2 >>> 0);
var Bi = (t, e, n2, r2, o2) => e + n2 + r2 + o2 + (t / 2 ** 32 | 0) | 0;
var Ii = (t, e, n2, r2, o2) => (t >>> 0) + (e >>> 0) + (n2 >>> 0) + (r2 >>> 0) + (o2 >>> 0);
var Ai = (t, e, n2, r2, o2, s) => e + n2 + r2 + o2 + s + (t / 2 ** 32 | 0) | 0;
var Gt = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function nn(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function mt(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function at(t, ...e) {
  if (!nn(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function rn(t) {
  if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
  mt(t.outputLen), mt(t.blockLen);
}
function Nt(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function on(t, e) {
  at(t);
  const n2 = e.outputLen;
  if (t.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
function fe(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function ut(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
function sn2(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function gt(t, e) {
  return t << 32 - e | t >>> e;
}
var Er = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Br(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
var wt = Er ? (t) => t : (t) => Br(t);
function Si(t) {
  for (let e = 0; e < t.length; e++) t[e] = Br(t[e]);
  return t;
}
var Ot = Er ? (t) => t : Si;
var Ir = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function";
var Ni = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function ce(t) {
  if (at(t), Ir) return t.toHex();
  let e = "";
  for (let n2 = 0; n2 < t.length; n2++) e += Ni[t[n2]];
  return e;
}
var xt = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Ar(t) {
  if (t >= xt._0 && t <= xt._9) return t - xt._0;
  if (t >= xt.A && t <= xt.F) return t - (xt.A - 10);
  if (t >= xt.a && t <= xt.f) return t - (xt.a - 10);
}
function fn(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  if (Ir) return Uint8Array.fromHex(t);
  const e = t.length, n2 = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const r2 = new Uint8Array(n2);
  for (let o2 = 0, s = 0; o2 < n2; o2++, s += 2) {
    const i3 = Ar(t.charCodeAt(s)), f7 = Ar(t.charCodeAt(s + 1));
    if (i3 === void 0 || f7 === void 0) {
      const a2 = t[s] + t[s + 1];
      throw new Error('hex string expected, got non-hex character "' + a2 + '" at index ' + s);
    }
    r2[o2] = i3 * 16 + f7;
  }
  return r2;
}
function Oi(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function ht(t) {
  return typeof t == "string" && (t = Oi(t)), at(t), t;
}
function Ht(...t) {
  let e = 0;
  for (let r2 = 0; r2 < t.length; r2++) {
    const o2 = t[r2];
    at(o2), e += o2.length;
  }
  const n2 = new Uint8Array(e);
  for (let r2 = 0, o2 = 0; r2 < t.length; r2++) {
    const s = t[r2];
    n2.set(s, o2), o2 += s.length;
  }
  return n2;
}
var Ie = class {
};
function ae(t) {
  const e = (r2) => t().update(ht(r2)).digest(), n2 = t();
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = () => t(), e;
}
function Ui(t) {
  const e = (r2, o2) => t(o2).update(ht(r2)).digest(), n2 = t({});
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = (r2) => t(r2), e;
}
function Zt(t = 32) {
  if (Gt && typeof Gt.getRandomValues == "function") return Gt.getRandomValues(new Uint8Array(t));
  if (Gt && typeof Gt.randomBytes == "function") return Uint8Array.from(Gt.randomBytes(t));
  throw new Error("crypto.getRandomValues must be defined");
}
var _i = BigInt(0);
var ue = BigInt(1);
var Ti = BigInt(2);
var Ri = BigInt(7);
var $i = BigInt(256);
var Ci = BigInt(113);
var Sr = [];
var Nr = [];
var Or = [];
for (let t = 0, e = ue, n2 = 1, r2 = 0; t < 24; t++) {
  [n2, r2] = [r2, (2 * n2 + 3 * r2) % 5], Sr.push(2 * (5 * r2 + n2)), Nr.push((t + 1) * (t + 2) / 2 % 64);
  let o2 = _i;
  for (let s = 0; s < 7; s++) e = (e << ue ^ (e >> Ri) * Ci) % $i, e & Ti && (o2 ^= ue << (ue << BigInt(s)) - ue);
  Or.push(o2);
}
var Ur = wr(Or, true);
var Li = Ur[0];
var ji = Ur[1];
var _r = (t, e, n2) => n2 > 32 ? xi(t, e, n2) : mi(t, e, n2);
var Tr = (t, e, n2) => n2 > 32 ? vi(t, e, n2) : wi(t, e, n2);
function ki(t, e = 24) {
  const n2 = new Uint32Array(10);
  for (let r2 = 24 - e; r2 < 24; r2++) {
    for (let i3 = 0; i3 < 10; i3++) n2[i3] = t[i3] ^ t[i3 + 10] ^ t[i3 + 20] ^ t[i3 + 30] ^ t[i3 + 40];
    for (let i3 = 0; i3 < 10; i3 += 2) {
      const f7 = (i3 + 8) % 10, a2 = (i3 + 2) % 10, l4 = n2[a2], c4 = n2[a2 + 1], u3 = _r(l4, c4, 1) ^ n2[f7], h4 = Tr(l4, c4, 1) ^ n2[f7 + 1];
      for (let g2 = 0; g2 < 50; g2 += 10) t[i3 + g2] ^= u3, t[i3 + g2 + 1] ^= h4;
    }
    let o2 = t[2], s = t[3];
    for (let i3 = 0; i3 < 24; i3++) {
      const f7 = Nr[i3], a2 = _r(o2, s, f7), l4 = Tr(o2, s, f7), c4 = Sr[i3];
      o2 = t[c4], s = t[c4 + 1], t[c4] = a2, t[c4 + 1] = l4;
    }
    for (let i3 = 0; i3 < 50; i3 += 10) {
      for (let f7 = 0; f7 < 10; f7++) n2[f7] = t[i3 + f7];
      for (let f7 = 0; f7 < 10; f7++) t[i3 + f7] ^= ~n2[(f7 + 2) % 10] & n2[(f7 + 4) % 10];
    }
    t[0] ^= Li[r2], t[1] ^= ji[r2];
  }
  ut(n2);
}
var qn = class _qn extends Ie {
  constructor(e, n2, r2, o2 = false, s = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e, this.suffix = n2, this.outputLen = r2, this.enableXOF = o2, this.rounds = s, mt(r2), !(0 < e && e < 200)) throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = fe(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Ot(this.state32), ki(this.state32, this.rounds), Ot(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Nt(this), e = ht(e), at(e);
    const { blockLen: n2, state: r2 } = this, o2 = e.length;
    for (let s = 0; s < o2; ) {
      const i3 = Math.min(n2 - this.pos, o2 - s);
      for (let f7 = 0; f7 < i3; f7++) r2[this.pos++] ^= e[s++];
      this.pos === n2 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e, suffix: n2, pos: r2, blockLen: o2 } = this;
    e[r2] ^= n2, (n2 & 128) !== 0 && r2 === o2 - 1 && this.keccak(), e[o2 - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Nt(this, false), at(e), this.finish();
    const n2 = this.state, { blockLen: r2 } = this;
    for (let o2 = 0, s = e.length; o2 < s; ) {
      this.posOut >= r2 && this.keccak();
      const i3 = Math.min(r2 - this.posOut, s - o2);
      e.set(n2.subarray(this.posOut, this.posOut + i3), o2), this.posOut += i3, o2 += i3;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return mt(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (on(e, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, ut(this.state);
  }
  _cloneInto(e) {
    const { blockLen: n2, suffix: r2, outputLen: o2, rounds: s, enableXOF: i3 } = this;
    return e || (e = new _qn(n2, r2, o2, i3, s)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s, e.suffix = r2, e.outputLen = o2, e.enableXOF = i3, e.destroyed = this.destroyed, e;
  }
};
var Pi = (t, e, n2) => ae(() => new qn(e, t, n2));
var Hi = Pi(1, 136, 256 / 8);
function Di(t, e, n2, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n2, r2);
  const o2 = BigInt(32), s = BigInt(4294967295), i3 = Number(n2 >> o2 & s), f7 = Number(n2 & s), a2 = r2 ? 4 : 0, l4 = r2 ? 0 : 4;
  t.setUint32(e + a2, i3, r2), t.setUint32(e + l4, f7, r2);
}
function Mi(t, e, n2) {
  return t & e ^ ~t & n2;
}
function Vi(t, e, n2) {
  return t & e ^ t & n2 ^ e & n2;
}
var Rr = class extends Ie {
  constructor(e, n2, r2, o2) {
    super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e, this.outputLen = n2, this.padOffset = r2, this.isLE = o2, this.buffer = new Uint8Array(e), this.view = sn2(this.buffer);
  }
  update(e) {
    Nt(this), e = ht(e), at(e);
    const { view: n2, buffer: r2, blockLen: o2 } = this, s = e.length;
    for (let i3 = 0; i3 < s; ) {
      const f7 = Math.min(o2 - this.pos, s - i3);
      if (f7 === o2) {
        const a2 = sn2(e);
        for (; o2 <= s - i3; i3 += o2) this.process(a2, i3);
        continue;
      }
      r2.set(e.subarray(i3, i3 + f7), this.pos), this.pos += f7, i3 += f7, this.pos === o2 && (this.process(n2, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Nt(this), on(e, this), this.finished = true;
    const { buffer: n2, view: r2, blockLen: o2, isLE: s } = this;
    let { pos: i3 } = this;
    n2[i3++] = 128, ut(this.buffer.subarray(i3)), this.padOffset > o2 - i3 && (this.process(r2, 0), i3 = 0);
    for (let u3 = i3; u3 < o2; u3++) n2[u3] = 0;
    Di(r2, o2 - 8, BigInt(this.length * 8), s), this.process(r2, 0);
    const f7 = sn2(e), a2 = this.outputLen;
    if (a2 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l4 = a2 / 4, c4 = this.get();
    if (l4 > c4.length) throw new Error("_sha2: outputLen bigger than state");
    for (let u3 = 0; u3 < l4; u3++) f7.setUint32(4 * u3, c4[u3], s);
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n2, buffer: r2, length: o2, finished: s, destroyed: i3, pos: f7 } = this;
    return e.destroyed = i3, e.finished = s, e.length = o2, e.pos = f7, o2 % n2 && e.buffer.set(r2), e;
  }
  clone() {
    return this._cloneInto();
  }
};
var Ut = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var W = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]);
var Y = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]);
var qi = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var _t = new Uint32Array(64);
var Ki = class extends Rr {
  constructor(e = 32) {
    super(64, e, 8, false), this.A = Ut[0] | 0, this.B = Ut[1] | 0, this.C = Ut[2] | 0, this.D = Ut[3] | 0, this.E = Ut[4] | 0, this.F = Ut[5] | 0, this.G = Ut[6] | 0, this.H = Ut[7] | 0;
  }
  get() {
    const { A: e, B: n2, C: r2, D: o2, E: s, F: i3, G: f7, H: a2 } = this;
    return [e, n2, r2, o2, s, i3, f7, a2];
  }
  set(e, n2, r2, o2, s, i3, f7, a2) {
    this.A = e | 0, this.B = n2 | 0, this.C = r2 | 0, this.D = o2 | 0, this.E = s | 0, this.F = i3 | 0, this.G = f7 | 0, this.H = a2 | 0;
  }
  process(e, n2) {
    for (let u3 = 0; u3 < 16; u3++, n2 += 4) _t[u3] = e.getUint32(n2, false);
    for (let u3 = 16; u3 < 64; u3++) {
      const h4 = _t[u3 - 15], g2 = _t[u3 - 2], w = gt(h4, 7) ^ gt(h4, 18) ^ h4 >>> 3, y5 = gt(g2, 17) ^ gt(g2, 19) ^ g2 >>> 10;
      _t[u3] = y5 + _t[u3 - 7] + w + _t[u3 - 16] | 0;
    }
    let { A: r2, B: o2, C: s, D: i3, E: f7, F: a2, G: l4, H: c4 } = this;
    for (let u3 = 0; u3 < 64; u3++) {
      const h4 = gt(f7, 6) ^ gt(f7, 11) ^ gt(f7, 25), g2 = c4 + h4 + Mi(f7, a2, l4) + qi[u3] + _t[u3] | 0, y5 = (gt(r2, 2) ^ gt(r2, 13) ^ gt(r2, 22)) + Vi(r2, o2, s) | 0;
      c4 = l4, l4 = a2, a2 = f7, f7 = i3 + g2 | 0, i3 = s, s = o2, o2 = r2, r2 = g2 + y5 | 0;
    }
    r2 = r2 + this.A | 0, o2 = o2 + this.B | 0, s = s + this.C | 0, i3 = i3 + this.D | 0, f7 = f7 + this.E | 0, a2 = a2 + this.F | 0, l4 = l4 + this.G | 0, c4 = c4 + this.H | 0, this.set(r2, o2, s, i3, f7, a2, l4, c4);
  }
  roundClean() {
    ut(_t);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), ut(this.buffer);
  }
};
var $r = wr(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t) => BigInt(t)));
var Fi = $r[0];
var zi = $r[1];
var Tt = new Uint32Array(80);
var Rt = new Uint32Array(80);
var cn = class extends Rr {
  constructor(e = 64) {
    super(128, e, 16, false), this.Ah = Y[0] | 0, this.Al = Y[1] | 0, this.Bh = Y[2] | 0, this.Bl = Y[3] | 0, this.Ch = Y[4] | 0, this.Cl = Y[5] | 0, this.Dh = Y[6] | 0, this.Dl = Y[7] | 0, this.Eh = Y[8] | 0, this.El = Y[9] | 0, this.Fh = Y[10] | 0, this.Fl = Y[11] | 0, this.Gh = Y[12] | 0, this.Gl = Y[13] | 0, this.Hh = Y[14] | 0, this.Hl = Y[15] | 0;
  }
  get() {
    const { Ah: e, Al: n2, Bh: r2, Bl: o2, Ch: s, Cl: i3, Dh: f7, Dl: a2, Eh: l4, El: c4, Fh: u3, Fl: h4, Gh: g2, Gl: w, Hh: y5, Hl: x4 } = this;
    return [e, n2, r2, o2, s, i3, f7, a2, l4, c4, u3, h4, g2, w, y5, x4];
  }
  set(e, n2, r2, o2, s, i3, f7, a2, l4, c4, u3, h4, g2, w, y5, x4) {
    this.Ah = e | 0, this.Al = n2 | 0, this.Bh = r2 | 0, this.Bl = o2 | 0, this.Ch = s | 0, this.Cl = i3 | 0, this.Dh = f7 | 0, this.Dl = a2 | 0, this.Eh = l4 | 0, this.El = c4 | 0, this.Fh = u3 | 0, this.Fl = h4 | 0, this.Gh = g2 | 0, this.Gl = w | 0, this.Hh = y5 | 0, this.Hl = x4 | 0;
  }
  process(e, n2) {
    for (let L2 = 0; L2 < 16; L2++, n2 += 4) Tt[L2] = e.getUint32(n2), Rt[L2] = e.getUint32(n2 += 4);
    for (let L2 = 16; L2 < 80; L2++) {
      const V5 = Tt[L2 - 15] | 0, _2 = Rt[L2 - 15] | 0, k4 = At(V5, _2, 1) ^ At(V5, _2, 8) ^ xr(V5, _2, 7), j3 = St(V5, _2, 1) ^ St(V5, _2, 8) ^ vr(V5, _2, 7), $3 = Tt[L2 - 2] | 0, d3 = Rt[L2 - 2] | 0, m2 = At($3, d3, 19) ^ se($3, d3, 61) ^ xr($3, d3, 6), p2 = St($3, d3, 19) ^ ie($3, d3, 61) ^ vr($3, d3, 6), b3 = Ei(j3, p2, Rt[L2 - 7], Rt[L2 - 16]), v3 = Bi(b3, k4, m2, Tt[L2 - 7], Tt[L2 - 16]);
      Tt[L2] = v3 | 0, Rt[L2] = b3 | 0;
    }
    let { Ah: r2, Al: o2, Bh: s, Bl: i3, Ch: f7, Cl: a2, Dh: l4, Dl: c4, Eh: u3, El: h4, Fh: g2, Fl: w, Gh: y5, Gl: x4, Hh: R4, Hl: M5 } = this;
    for (let L2 = 0; L2 < 80; L2++) {
      const V5 = At(u3, h4, 14) ^ At(u3, h4, 18) ^ se(u3, h4, 41), _2 = St(u3, h4, 14) ^ St(u3, h4, 18) ^ ie(u3, h4, 41), k4 = u3 & g2 ^ ~u3 & y5, j3 = h4 & w ^ ~h4 & x4, $3 = Ii(M5, _2, j3, zi[L2], Rt[L2]), d3 = Ai($3, R4, V5, k4, Fi[L2], Tt[L2]), m2 = $3 | 0, p2 = At(r2, o2, 28) ^ se(r2, o2, 34) ^ se(r2, o2, 39), b3 = St(r2, o2, 28) ^ ie(r2, o2, 34) ^ ie(r2, o2, 39), v3 = r2 & s ^ r2 & f7 ^ s & f7, B3 = o2 & i3 ^ o2 & a2 ^ i3 & a2;
      R4 = y5 | 0, M5 = x4 | 0, y5 = g2 | 0, x4 = w | 0, g2 = u3 | 0, w = h4 | 0, { h: u3, l: h4 } = dt(l4 | 0, c4 | 0, d3 | 0, m2 | 0), l4 = f7 | 0, c4 = a2 | 0, f7 = s | 0, a2 = i3 | 0, s = r2 | 0, i3 = o2 | 0;
      const E4 = tn(m2, b3, B3);
      r2 = en(E4, d3, p2, v3), o2 = E4 | 0;
    }
    ({ h: r2, l: o2 } = dt(this.Ah | 0, this.Al | 0, r2 | 0, o2 | 0)), { h: s, l: i3 } = dt(this.Bh | 0, this.Bl | 0, s | 0, i3 | 0), { h: f7, l: a2 } = dt(this.Ch | 0, this.Cl | 0, f7 | 0, a2 | 0), { h: l4, l: c4 } = dt(this.Dh | 0, this.Dl | 0, l4 | 0, c4 | 0), { h: u3, l: h4 } = dt(this.Eh | 0, this.El | 0, u3 | 0, h4 | 0), { h: g2, l: w } = dt(this.Fh | 0, this.Fl | 0, g2 | 0, w | 0), { h: y5, l: x4 } = dt(this.Gh | 0, this.Gl | 0, y5 | 0, x4 | 0), { h: R4, l: M5 } = dt(this.Hh | 0, this.Hl | 0, R4 | 0, M5 | 0), this.set(r2, o2, s, i3, f7, a2, l4, c4, u3, h4, g2, w, y5, x4, R4, M5);
  }
  roundClean() {
    ut(Tt, Rt);
  }
  destroy() {
    ut(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Gi = class extends cn {
  constructor() {
    super(48), this.Ah = W[0] | 0, this.Al = W[1] | 0, this.Bh = W[2] | 0, this.Bl = W[3] | 0, this.Ch = W[4] | 0, this.Cl = W[5] | 0, this.Dh = W[6] | 0, this.Dl = W[7] | 0, this.Eh = W[8] | 0, this.El = W[9] | 0, this.Fh = W[10] | 0, this.Fl = W[11] | 0, this.Gh = W[12] | 0, this.Gl = W[13] | 0, this.Hh = W[14] | 0, this.Hl = W[15] | 0;
  }
};
var X = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
var Zi = class extends cn {
  constructor() {
    super(32), this.Ah = X[0] | 0, this.Al = X[1] | 0, this.Bh = X[2] | 0, this.Bl = X[3] | 0, this.Ch = X[4] | 0, this.Cl = X[5] | 0, this.Dh = X[6] | 0, this.Dl = X[7] | 0, this.Eh = X[8] | 0, this.El = X[9] | 0, this.Fh = X[10] | 0, this.Fl = X[11] | 0, this.Gh = X[12] | 0, this.Gl = X[13] | 0, this.Hh = X[14] | 0, this.Hl = X[15] | 0;
  }
};
var Ae = ae(() => new Ki());
var Wi = ae(() => new cn());
var Yi = ae(() => new Gi());
var Xi = ae(() => new Zi());
var Ji = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]);
var F = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]);
var N2 = new Uint32Array(32);
function $t(t, e, n2, r2, o2, s) {
  const i3 = o2[s], f7 = o2[s + 1];
  let a2 = N2[2 * t], l4 = N2[2 * t + 1], c4 = N2[2 * e], u3 = N2[2 * e + 1], h4 = N2[2 * n2], g2 = N2[2 * n2 + 1], w = N2[2 * r2], y5 = N2[2 * r2 + 1], x4 = tn(a2, c4, i3);
  l4 = en(x4, l4, u3, f7), a2 = x4 | 0, { Dh: y5, Dl: w } = { Dh: y5 ^ l4, Dl: w ^ a2 }, { Dh: y5, Dl: w } = { Dh: bi(y5, w), Dl: yi(y5) }, { h: g2, l: h4 } = dt(g2, h4, y5, w), { Bh: u3, Bl: c4 } = { Bh: u3 ^ g2, Bl: c4 ^ h4 }, { Bh: u3, Bl: c4 } = { Bh: At(u3, c4, 24), Bl: St(u3, c4, 24) }, N2[2 * t] = a2, N2[2 * t + 1] = l4, N2[2 * e] = c4, N2[2 * e + 1] = u3, N2[2 * n2] = h4, N2[2 * n2 + 1] = g2, N2[2 * r2] = w, N2[2 * r2 + 1] = y5;
}
function Ct(t, e, n2, r2, o2, s) {
  const i3 = o2[s], f7 = o2[s + 1];
  let a2 = N2[2 * t], l4 = N2[2 * t + 1], c4 = N2[2 * e], u3 = N2[2 * e + 1], h4 = N2[2 * n2], g2 = N2[2 * n2 + 1], w = N2[2 * r2], y5 = N2[2 * r2 + 1], x4 = tn(a2, c4, i3);
  l4 = en(x4, l4, u3, f7), a2 = x4 | 0, { Dh: y5, Dl: w } = { Dh: y5 ^ l4, Dl: w ^ a2 }, { Dh: y5, Dl: w } = { Dh: At(y5, w, 16), Dl: St(y5, w, 16) }, { h: g2, l: h4 } = dt(g2, h4, y5, w), { Bh: u3, Bl: c4 } = { Bh: u3 ^ g2, Bl: c4 ^ h4 }, { Bh: u3, Bl: c4 } = { Bh: se(u3, c4, 63), Bl: ie(u3, c4, 63) }, N2[2 * t] = a2, N2[2 * t + 1] = l4, N2[2 * e] = c4, N2[2 * e + 1] = u3, N2[2 * n2] = h4, N2[2 * n2 + 1] = g2, N2[2 * r2] = w, N2[2 * r2 + 1] = y5;
}
function Qi(t, e = {}, n2, r2, o2) {
  if (mt(n2), t < 0 || t > n2) throw new Error("outputLen bigger than keyLen");
  const { key: s, salt: i3, personalization: f7 } = e;
  if (s !== void 0 && (s.length < 1 || s.length > n2)) throw new Error("key length must be undefined or 1.." + n2);
  if (i3 !== void 0 && i3.length !== r2) throw new Error("salt must be undefined or " + r2);
  if (f7 !== void 0 && f7.length !== o2) throw new Error("personalization must be undefined or " + o2);
}
var tf = class extends Ie {
  constructor(e, n2) {
    super(), this.finished = false, this.destroyed = false, this.length = 0, this.pos = 0, mt(e), mt(n2), this.blockLen = e, this.outputLen = n2, this.buffer = new Uint8Array(e), this.buffer32 = fe(this.buffer);
  }
  update(e) {
    Nt(this), e = ht(e), at(e);
    const { blockLen: n2, buffer: r2, buffer32: o2 } = this, s = e.length, i3 = e.byteOffset, f7 = e.buffer;
    for (let a2 = 0; a2 < s; ) {
      this.pos === n2 && (Ot(o2), this.compress(o2, 0, false), Ot(o2), this.pos = 0);
      const l4 = Math.min(n2 - this.pos, s - a2), c4 = i3 + a2;
      if (l4 === n2 && !(c4 % 4) && a2 + l4 < s) {
        const u3 = new Uint32Array(f7, c4, Math.floor((s - a2) / 4));
        Ot(u3);
        for (let h4 = 0; a2 + n2 < s; h4 += o2.length, a2 += n2) this.length += n2, this.compress(u3, h4, false);
        Ot(u3);
        continue;
      }
      r2.set(e.subarray(a2, a2 + l4), this.pos), this.pos += l4, this.length += l4, a2 += l4;
    }
    return this;
  }
  digestInto(e) {
    Nt(this), on(e, this);
    const { pos: n2, buffer32: r2 } = this;
    this.finished = true, ut(this.buffer.subarray(n2)), Ot(r2), this.compress(r2, 0, true), Ot(r2);
    const o2 = fe(e);
    this.get().forEach((s, i3) => o2[i3] = wt(s));
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
  _cloneInto(e) {
    const { buffer: n2, length: r2, finished: o2, destroyed: s, outputLen: i3, pos: f7 } = this;
    return e || (e = new this.constructor({ dkLen: i3 })), e.set(...this.get()), e.buffer.set(n2), e.destroyed = s, e.finished = o2, e.length = r2, e.pos = f7, e.outputLen = i3, e;
  }
  clone() {
    return this._cloneInto();
  }
};
var ef = class extends tf {
  constructor(e = {}) {
    const n2 = e.dkLen === void 0 ? 64 : e.dkLen;
    super(128, n2), this.v0l = F[0] | 0, this.v0h = F[1] | 0, this.v1l = F[2] | 0, this.v1h = F[3] | 0, this.v2l = F[4] | 0, this.v2h = F[5] | 0, this.v3l = F[6] | 0, this.v3h = F[7] | 0, this.v4l = F[8] | 0, this.v4h = F[9] | 0, this.v5l = F[10] | 0, this.v5h = F[11] | 0, this.v6l = F[12] | 0, this.v6h = F[13] | 0, this.v7l = F[14] | 0, this.v7h = F[15] | 0, Qi(n2, e, 64, 16, 16);
    let { key: r2, personalization: o2, salt: s } = e, i3 = 0;
    if (r2 !== void 0 && (r2 = ht(r2), i3 = r2.length), this.v0l ^= this.outputLen | i3 << 8 | 65536 | 1 << 24, s !== void 0) {
      s = ht(s);
      const f7 = fe(s);
      this.v4l ^= wt(f7[0]), this.v4h ^= wt(f7[1]), this.v5l ^= wt(f7[2]), this.v5h ^= wt(f7[3]);
    }
    if (o2 !== void 0) {
      o2 = ht(o2);
      const f7 = fe(o2);
      this.v6l ^= wt(f7[0]), this.v6h ^= wt(f7[1]), this.v7l ^= wt(f7[2]), this.v7h ^= wt(f7[3]);
    }
    if (r2 !== void 0) {
      const f7 = new Uint8Array(this.blockLen);
      f7.set(r2), this.update(f7);
    }
  }
  get() {
    let { v0l: e, v0h: n2, v1l: r2, v1h: o2, v2l: s, v2h: i3, v3l: f7, v3h: a2, v4l: l4, v4h: c4, v5l: u3, v5h: h4, v6l: g2, v6h: w, v7l: y5, v7h: x4 } = this;
    return [e, n2, r2, o2, s, i3, f7, a2, l4, c4, u3, h4, g2, w, y5, x4];
  }
  set(e, n2, r2, o2, s, i3, f7, a2, l4, c4, u3, h4, g2, w, y5, x4) {
    this.v0l = e | 0, this.v0h = n2 | 0, this.v1l = r2 | 0, this.v1h = o2 | 0, this.v2l = s | 0, this.v2h = i3 | 0, this.v3l = f7 | 0, this.v3h = a2 | 0, this.v4l = l4 | 0, this.v4h = c4 | 0, this.v5l = u3 | 0, this.v5h = h4 | 0, this.v6l = g2 | 0, this.v6h = w | 0, this.v7l = y5 | 0, this.v7h = x4 | 0;
  }
  compress(e, n2, r2) {
    this.get().forEach((a2, l4) => N2[l4] = a2), N2.set(F, 16);
    let { h: o2, l: s } = mr(BigInt(this.length));
    N2[24] = F[8] ^ s, N2[25] = F[9] ^ o2, r2 && (N2[28] = ~N2[28], N2[29] = ~N2[29]);
    let i3 = 0;
    const f7 = Ji;
    for (let a2 = 0; a2 < 12; a2++) $t(0, 4, 8, 12, e, n2 + 2 * f7[i3++]), Ct(0, 4, 8, 12, e, n2 + 2 * f7[i3++]), $t(1, 5, 9, 13, e, n2 + 2 * f7[i3++]), Ct(1, 5, 9, 13, e, n2 + 2 * f7[i3++]), $t(2, 6, 10, 14, e, n2 + 2 * f7[i3++]), Ct(2, 6, 10, 14, e, n2 + 2 * f7[i3++]), $t(3, 7, 11, 15, e, n2 + 2 * f7[i3++]), Ct(3, 7, 11, 15, e, n2 + 2 * f7[i3++]), $t(0, 5, 10, 15, e, n2 + 2 * f7[i3++]), Ct(0, 5, 10, 15, e, n2 + 2 * f7[i3++]), $t(1, 6, 11, 12, e, n2 + 2 * f7[i3++]), Ct(1, 6, 11, 12, e, n2 + 2 * f7[i3++]), $t(2, 7, 8, 13, e, n2 + 2 * f7[i3++]), Ct(2, 7, 8, 13, e, n2 + 2 * f7[i3++]), $t(3, 4, 9, 14, e, n2 + 2 * f7[i3++]), Ct(3, 4, 9, 14, e, n2 + 2 * f7[i3++]);
    this.v0l ^= N2[0] ^ N2[16], this.v0h ^= N2[1] ^ N2[17], this.v1l ^= N2[2] ^ N2[18], this.v1h ^= N2[3] ^ N2[19], this.v2l ^= N2[4] ^ N2[20], this.v2h ^= N2[5] ^ N2[21], this.v3l ^= N2[6] ^ N2[22], this.v3h ^= N2[7] ^ N2[23], this.v4l ^= N2[8] ^ N2[24], this.v4h ^= N2[9] ^ N2[25], this.v5l ^= N2[10] ^ N2[26], this.v5h ^= N2[11] ^ N2[27], this.v6l ^= N2[12] ^ N2[28], this.v6h ^= N2[13] ^ N2[29], this.v7l ^= N2[14] ^ N2[30], this.v7h ^= N2[15] ^ N2[31], ut(N2);
  }
  destroy() {
    this.destroyed = true, ut(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var nf = Ui((t) => new ef(t));
var rf = "https://rpc.walletconnect.org/v1";
function an(t) {
  const e = `Ethereum Signed Message:
${t.length}`, n2 = new TextEncoder().encode(e + t);
  return "0x" + Buffer.from(Hi(n2)).toString("hex");
}
async function Cr(t, e, n2, r2, o2, s) {
  switch (n2.t) {
    case "eip191":
      return await Lr(t, e, n2.s);
    case "eip1271":
      return await jr(t, e, n2.s, r2, o2, s);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n2.t}`);
  }
}
async function Lr(t, e, n2) {
  return (await recoverAddress({ hash: an(e), signature: n2 })).toLowerCase() === t.toLowerCase();
}
async function jr(t, e, n2, r2, o2, s) {
  const i3 = Fe(r2);
  if (!i3.namespace || !i3.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r2}`);
  try {
    const f7 = "0x1626ba7e", a2 = "0000000000000000000000000000000000000000000000000000000000000040", l4 = n2.substring(2), c4 = (l4.length / 2).toString(16).padStart(64, "0"), u3 = (e.startsWith("0x") ? e : an(e)).substring(2), h4 = f7 + u3 + a2 + c4 + l4, g2 = await fetch(`${s || rf}/?chainId=${r2}&projectId=${o2}`, { headers: { "Content-Type": "application/json" }, method: "POST", body: JSON.stringify({ id: of(), jsonrpc: "2.0", method: "eth_call", params: [{ to: t, data: h4 }, "latest"] }) }), { result: w } = await g2.json();
    return w ? w.slice(0, f7.length).toLowerCase() === f7.toLowerCase() : false;
  } catch (f7) {
    return console.error("isValidEip1271Signature: ", f7), false;
  }
}
function of() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function sf(t) {
  const e = atob(t), n2 = new Uint8Array(e.length);
  for (let i3 = 0; i3 < e.length; i3++) n2[i3] = e.charCodeAt(i3);
  const r2 = n2[0];
  if (r2 === 0) throw new Error("No signatures found");
  const o2 = 1 + r2 * 64;
  if (n2.length < o2) throw new Error("Transaction data too short for claimed signature count");
  if (n2.length < 100) throw new Error("Transaction too short");
  const s = Buffer.from(t, "base64").slice(1, 65);
  return esm_default.encode(s);
}
function ff(t) {
  const e = new Uint8Array(Buffer.from(t, "base64")), n2 = Array.from("TransactionData::").map((s) => s.charCodeAt(0)), r2 = new Uint8Array(n2.length + e.length);
  r2.set(n2), r2.set(e, n2.length);
  const o2 = nf(r2, { dkLen: 32 });
  return esm_default.encode(o2);
}
function cf(t) {
  const e = new Uint8Array(Ae(kr(t)));
  return esm_default.encode(e);
}
function kr(t) {
  if (t instanceof Uint8Array) return t;
  if (Array.isArray(t)) return new Uint8Array(t);
  if (typeof t == "object" && t != null && t.data) return new Uint8Array(Object.values(t.data));
  if (typeof t == "object" && t) return new Uint8Array(Object.values(t));
  throw new Error("getNearUint8ArrayFromBytes: Unexpected result type from bytes array");
}
function af(t) {
  const e = Buffer.from(t, "base64"), n2 = decode(e).txn;
  if (!n2) throw new Error("Invalid signed transaction: missing 'txn' field");
  const r2 = encode(n2), o2 = Buffer.from("TX"), s = Buffer.concat([o2, Buffer.from(r2)]), i3 = Xi(s);
  return base32.encode(i3).replace(/=+$/, "");
}
function un(t) {
  const e = [];
  let n2 = BigInt(t);
  for (; n2 >= BigInt(128); ) e.push(Number(n2 & BigInt(127) | BigInt(128))), n2 >>= BigInt(7);
  return e.push(Number(n2)), Buffer.from(e);
}
function uf(t) {
  const e = Buffer.from(t.signed.bodyBytes, "base64"), n2 = Buffer.from(t.signed.authInfoBytes, "base64"), r2 = Buffer.from(t.signature.signature, "base64"), o2 = [];
  o2.push(Buffer.from([10])), o2.push(un(e.length)), o2.push(e), o2.push(Buffer.from([18])), o2.push(un(n2.length)), o2.push(n2), o2.push(Buffer.from([26])), o2.push(un(r2.length)), o2.push(r2);
  const s = Buffer.concat(o2), i3 = Ae(s);
  return Buffer.from(i3).toString("hex").toUpperCase();
}
var lf = Object.defineProperty;
var df = Object.defineProperties;
var hf = Object.getOwnPropertyDescriptors;
var Pr = Object.getOwnPropertySymbols;
var pf = Object.prototype.hasOwnProperty;
var gf = Object.prototype.propertyIsEnumerable;
var Hr = (t, e, n2) => e in t ? lf(t, e, { enumerable: true, configurable: true, writable: true, value: n2 }) : t[e] = n2;
var ln = (t, e) => {
  for (var n2 in e || (e = {})) pf.call(e, n2) && Hr(t, n2, e[n2]);
  if (Pr) for (var n2 of Pr(e)) gf.call(e, n2) && Hr(t, n2, e[n2]);
  return t;
};
var Dr = (t, e) => df(t, hf(e));
var bf = "did:pkh:";
var Se = (t) => t == null ? void 0 : t.split(":");
var Mr = (t) => {
  const e = t && Se(t);
  if (e) return t.includes(bf) ? e[3] : e[1];
};
var Vr = (t) => {
  const e = t && Se(t);
  if (e) return e[2] + ":" + e[3];
};
var dn = (t) => {
  const e = t && Se(t);
  if (e) return e.pop();
};
async function yf(t) {
  const { cacao: e, projectId: n2 } = t, { s: r2, p: o2 } = e, s = qr(o2, o2.iss), i3 = dn(o2.iss);
  return await Cr(i3, s, r2, Vr(o2.iss), n2);
}
var qr = (t, e) => {
  const n2 = `${t.domain} wants you to sign in with your Ethereum account:`, r2 = dn(e);
  if (!t.aud && !t.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let o2 = t.statement || void 0;
  const s = `URI: ${t.aud || t.uri}`, i3 = `Version: ${t.version}`, f7 = `Chain ID: ${Mr(e)}`, a2 = `Nonce: ${t.nonce}`, l4 = `Issued At: ${t.iat}`, c4 = t.exp ? `Expiration Time: ${t.exp}` : void 0, u3 = t.nbf ? `Not Before: ${t.nbf}` : void 0, h4 = t.requestId ? `Request ID: ${t.requestId}` : void 0, g2 = t.resources ? `Resources:${t.resources.map((y5) => `
- ${y5}`).join("")}` : void 0, w = Oe(t.resources);
  if (w) {
    const y5 = Lt(w);
    o2 = gn(o2, y5);
  }
  return [n2, r2, "", o2, "", s, i3, f7, a2, l4, c4, u3, h4, g2].filter((y5) => y5 != null).join(`
`);
};
function Gr(t) {
  return Buffer.from(JSON.stringify(t)).toString("base64");
}
function Zr(t) {
  return JSON.parse(Buffer.from(t, "base64").toString("utf-8"));
}
function bt(t) {
  if (!t) throw new Error("No recap provided, value is undefined");
  if (!t.att) throw new Error("No `att` property found");
  const e = Object.keys(t.att);
  if (!(e != null && e.length)) throw new Error("No resources found in `att` property");
  e.forEach((n2) => {
    const r2 = t.att[n2];
    if (Array.isArray(r2)) throw new Error(`Resource must be an object: ${n2}`);
    if (typeof r2 != "object") throw new Error(`Resource must be an object: ${n2}`);
    if (!Object.keys(r2).length) throw new Error(`Resource object is empty: ${n2}`);
    Object.keys(r2).forEach((o2) => {
      const s = r2[o2];
      if (!Array.isArray(s)) throw new Error(`Ability limits ${o2} must be an array of objects, found: ${s}`);
      if (!s.length) throw new Error(`Value of ${o2} is empty array, must be an array with objects`);
      s.forEach((i3) => {
        if (typeof i3 != "object") throw new Error(`Ability limits (${o2}) must be an array of objects, found: ${i3}`);
      });
    });
  });
}
function Wr(t, e, n2, r2 = {}) {
  return n2 == null ? void 0 : n2.sort((o2, s) => o2.localeCompare(s)), { att: { [t]: hn(e, n2, r2) } };
}
function hn(t, e, n2 = {}) {
  e = e == null ? void 0 : e.sort((o2, s) => o2.localeCompare(s));
  const r2 = e.map((o2) => ({ [`${t}/${o2}`]: [n2] }));
  return Object.assign({}, ...r2);
}
function Ne(t) {
  return bt(t), `urn:recap:${Gr(t).replace(/=/g, "")}`;
}
function Lt(t) {
  const e = Zr(t.replace("urn:recap:", ""));
  return bt(e), e;
}
function Ef(t, e, n2) {
  const r2 = Wr(t, e, n2);
  return Ne(r2);
}
function pn(t) {
  return t && t.includes("urn:recap:");
}
function Bf(t, e) {
  const n2 = Lt(t), r2 = Lt(e), o2 = Xr(n2, r2);
  return Ne(o2);
}
function Xr(t, e) {
  bt(t), bt(e);
  const n2 = Object.keys(t.att).concat(Object.keys(e.att)).sort((o2, s) => o2.localeCompare(s)), r2 = { att: {} };
  return n2.forEach((o2) => {
    var s, i3;
    Object.keys(((s = t.att) == null ? void 0 : s[o2]) || {}).concat(Object.keys(((i3 = e.att) == null ? void 0 : i3[o2]) || {})).sort((f7, a2) => f7.localeCompare(a2)).forEach((f7) => {
      var a2, l4;
      r2.att[o2] = Dr(ln({}, r2.att[o2]), { [f7]: ((a2 = t.att[o2]) == null ? void 0 : a2[f7]) || ((l4 = e.att[o2]) == null ? void 0 : l4[f7]) });
    });
  }), r2;
}
function gn(t = "", e) {
  bt(e);
  const n2 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t.includes(n2)) return t;
  const r2 = [];
  let o2 = 0;
  Object.keys(e.att).forEach((f7) => {
    const a2 = Object.keys(e.att[f7]).map((u3) => ({ ability: u3.split("/")[0], action: u3.split("/")[1] }));
    a2.sort((u3, h4) => u3.action.localeCompare(h4.action));
    const l4 = {};
    a2.forEach((u3) => {
      l4[u3.ability] || (l4[u3.ability] = []), l4[u3.ability].push(u3.action);
    });
    const c4 = Object.keys(l4).map((u3) => (o2++, `(${o2}) '${u3}': '${l4[u3].join("', '")}' for '${f7}'.`));
    r2.push(c4.join(", ").replace(".,", "."));
  });
  const s = r2.join(" "), i3 = `${n2}${s}`;
  return `${t ? t + " " : ""}${i3}`;
}
function If(t) {
  var e;
  const n2 = Lt(t);
  bt(n2);
  const r2 = (e = n2.att) == null ? void 0 : e.eip155;
  return r2 ? Object.keys(r2).map((o2) => o2.split("/")[1]) : [];
}
function Af(t) {
  const e = Lt(t);
  bt(e);
  const n2 = [];
  return Object.values(e.att).forEach((r2) => {
    Object.values(r2).forEach((o2) => {
      var s;
      (s = o2 == null ? void 0 : o2[0]) != null && s.chains && n2.push(o2[0].chains);
    });
  }), [...new Set(n2.flat())];
}
function Oe(t) {
  if (!t) return;
  const e = t == null ? void 0 : t[t.length - 1];
  return pn(e) ? e : void 0;
}
function Qr(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function bn(t) {
  if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
}
function yn(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function nt(t, ...e) {
  if (!Qr(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function to(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function Sf(t, e) {
  nt(t);
  const n2 = e.outputLen;
  if (t.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
function jt(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function Wt(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
function Nf(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
var Of = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Uf(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function mn(t) {
  if (typeof t == "string") t = Uf(t);
  else if (Qr(t)) t = wn(t);
  else throw new Error("Uint8Array expected, got " + typeof t);
  return t;
}
function _f(t, e) {
  if (e == null || typeof e != "object") throw new Error("options must be defined");
  return Object.assign(t, e);
}
function Tf(t, e) {
  if (t.length !== e.length) return false;
  let n2 = 0;
  for (let r2 = 0; r2 < t.length; r2++) n2 |= t[r2] ^ e[r2];
  return n2 === 0;
}
var Rf = (t, e) => {
  function n2(r2, ...o2) {
    if (nt(r2), !Of) throw new Error("Non little-endian hardware is not yet supported");
    if (t.nonceLength !== void 0) {
      const c4 = o2[0];
      if (!c4) throw new Error("nonce / iv required");
      t.varSizeNonce ? nt(c4) : nt(c4, t.nonceLength);
    }
    const s = t.tagLength;
    s && o2[1] !== void 0 && nt(o2[1]);
    const i3 = e(r2, ...o2), f7 = (c4, u3) => {
      if (u3 !== void 0) {
        if (c4 !== 2) throw new Error("cipher output not supported");
        nt(u3);
      }
    };
    let a2 = false;
    return { encrypt(c4, u3) {
      if (a2) throw new Error("cannot encrypt() twice with same key + nonce");
      return a2 = true, nt(c4), f7(i3.encrypt.length, u3), i3.encrypt(c4, u3);
    }, decrypt(c4, u3) {
      if (nt(c4), s && c4.length < s) throw new Error("invalid ciphertext length: smaller than tagLength=" + s);
      return f7(i3.decrypt.length, u3), i3.decrypt(c4, u3);
    } };
  }
  return Object.assign(n2, t), n2;
};
function eo(t, e, n2 = true) {
  if (e === void 0) return new Uint8Array(t);
  if (e.length !== t) throw new Error("invalid output length, expected " + t + ", got: " + e.length);
  if (n2 && !Cf(e)) throw new Error("invalid output, must be aligned");
  return e;
}
function no(t, e, n2, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n2, r2);
  const o2 = BigInt(32), s = BigInt(4294967295), i3 = Number(n2 >> o2 & s), f7 = Number(n2 & s), a2 = r2 ? 4 : 0, l4 = r2 ? 0 : 4;
  t.setUint32(e + a2, i3, r2), t.setUint32(e + l4, f7, r2);
}
function $f(t, e, n2) {
  bn(n2);
  const r2 = new Uint8Array(16), o2 = Nf(r2);
  return no(o2, 0, BigInt(e), n2), no(o2, 8, BigInt(t), n2), r2;
}
function Cf(t) {
  return t.byteOffset % 4 === 0;
}
function wn(t) {
  return Uint8Array.from(t);
}
var ro = (t) => Uint8Array.from(t.split("").map((e) => e.charCodeAt(0)));
var Lf = ro("expand 16-byte k");
var jf = ro("expand 32-byte k");
var kf = jt(Lf);
var Pf = jt(jf);
function D2(t, e) {
  return t << e | t >>> 32 - e;
}
function xn(t) {
  return t.byteOffset % 4 === 0;
}
var Ue = 64;
var Hf = 16;
var oo = 2 ** 32 - 1;
var so = new Uint32Array();
function Df(t, e, n2, r2, o2, s, i3, f7) {
  const a2 = o2.length, l4 = new Uint8Array(Ue), c4 = jt(l4), u3 = xn(o2) && xn(s), h4 = u3 ? jt(o2) : so, g2 = u3 ? jt(s) : so;
  for (let w = 0; w < a2; i3++) {
    if (t(e, n2, r2, c4, i3, f7), i3 >= oo) throw new Error("arx: counter overflow");
    const y5 = Math.min(Ue, a2 - w);
    if (u3 && y5 === Ue) {
      const x4 = w / 4;
      if (w % 4 !== 0) throw new Error("arx: invalid block position");
      for (let R4 = 0, M5; R4 < Hf; R4++) M5 = x4 + R4, g2[M5] = h4[M5] ^ c4[R4];
      w += Ue;
      continue;
    }
    for (let x4 = 0, R4; x4 < y5; x4++) R4 = w + x4, s[R4] = o2[R4] ^ l4[x4];
    w += y5;
  }
}
function Mf(t, e) {
  const { allowShortKeys: n2, extendNonceFn: r2, counterLength: o2, counterRight: s, rounds: i3 } = _f({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e);
  if (typeof t != "function") throw new Error("core must be a function");
  return yn(o2), yn(i3), bn(s), bn(n2), (f7, a2, l4, c4, u3 = 0) => {
    nt(f7), nt(a2), nt(l4);
    const h4 = l4.length;
    if (c4 === void 0 && (c4 = new Uint8Array(h4)), nt(c4), yn(u3), u3 < 0 || u3 >= oo) throw new Error("arx: counter overflow");
    if (c4.length < h4) throw new Error(`arx: output (${c4.length}) is shorter than data (${h4})`);
    const g2 = [];
    let w = f7.length, y5, x4;
    if (w === 32) g2.push(y5 = wn(f7)), x4 = Pf;
    else if (w === 16 && n2) y5 = new Uint8Array(32), y5.set(f7), y5.set(f7, 16), x4 = kf, g2.push(y5);
    else throw new Error(`arx: invalid 32-byte key, got length=${w}`);
    xn(a2) || g2.push(a2 = wn(a2));
    const R4 = jt(y5);
    if (r2) {
      if (a2.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r2(x4, R4, jt(a2.subarray(0, 16)), R4), a2 = a2.subarray(16);
    }
    const M5 = 16 - o2;
    if (M5 !== a2.length) throw new Error(`arx: nonce must be ${M5} or 16 bytes`);
    if (M5 !== 12) {
      const V5 = new Uint8Array(12);
      V5.set(a2, s ? 0 : 12 - a2.length), a2 = V5, g2.push(a2);
    }
    const L2 = jt(a2);
    return Df(t, x4, R4, L2, l4, c4, u3, i3), Wt(...g2), c4;
  };
}
var G = (t, e) => t[e++] & 255 | (t[e++] & 255) << 8;
var Vf = class {
  constructor(e) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e = mn(e), nt(e, 32);
    const n2 = G(e, 0), r2 = G(e, 2), o2 = G(e, 4), s = G(e, 6), i3 = G(e, 8), f7 = G(e, 10), a2 = G(e, 12), l4 = G(e, 14);
    this.r[0] = n2 & 8191, this.r[1] = (n2 >>> 13 | r2 << 3) & 8191, this.r[2] = (r2 >>> 10 | o2 << 6) & 7939, this.r[3] = (o2 >>> 7 | s << 9) & 8191, this.r[4] = (s >>> 4 | i3 << 12) & 255, this.r[5] = i3 >>> 1 & 8190, this.r[6] = (i3 >>> 14 | f7 << 2) & 8191, this.r[7] = (f7 >>> 11 | a2 << 5) & 8065, this.r[8] = (a2 >>> 8 | l4 << 8) & 8191, this.r[9] = l4 >>> 5 & 127;
    for (let c4 = 0; c4 < 8; c4++) this.pad[c4] = G(e, 16 + 2 * c4);
  }
  process(e, n2, r2 = false) {
    const o2 = r2 ? 0 : 2048, { h: s, r: i3 } = this, f7 = i3[0], a2 = i3[1], l4 = i3[2], c4 = i3[3], u3 = i3[4], h4 = i3[5], g2 = i3[6], w = i3[7], y5 = i3[8], x4 = i3[9], R4 = G(e, n2 + 0), M5 = G(e, n2 + 2), L2 = G(e, n2 + 4), V5 = G(e, n2 + 6), _2 = G(e, n2 + 8), k4 = G(e, n2 + 10), j3 = G(e, n2 + 12), $3 = G(e, n2 + 14);
    let d3 = s[0] + (R4 & 8191), m2 = s[1] + ((R4 >>> 13 | M5 << 3) & 8191), p2 = s[2] + ((M5 >>> 10 | L2 << 6) & 8191), b3 = s[3] + ((L2 >>> 7 | V5 << 9) & 8191), v3 = s[4] + ((V5 >>> 4 | _2 << 12) & 8191), B3 = s[5] + (_2 >>> 1 & 8191), E4 = s[6] + ((_2 >>> 14 | k4 << 2) & 8191), I3 = s[7] + ((k4 >>> 11 | j3 << 5) & 8191), S3 = s[8] + ((j3 >>> 8 | $3 << 8) & 8191), O5 = s[9] + ($3 >>> 5 | o2), A4 = 0, T3 = A4 + d3 * f7 + m2 * (5 * x4) + p2 * (5 * y5) + b3 * (5 * w) + v3 * (5 * g2);
    A4 = T3 >>> 13, T3 &= 8191, T3 += B3 * (5 * h4) + E4 * (5 * u3) + I3 * (5 * c4) + S3 * (5 * l4) + O5 * (5 * a2), A4 += T3 >>> 13, T3 &= 8191;
    let U4 = A4 + d3 * a2 + m2 * f7 + p2 * (5 * x4) + b3 * (5 * y5) + v3 * (5 * w);
    A4 = U4 >>> 13, U4 &= 8191, U4 += B3 * (5 * g2) + E4 * (5 * h4) + I3 * (5 * u3) + S3 * (5 * c4) + O5 * (5 * l4), A4 += U4 >>> 13, U4 &= 8191;
    let C4 = A4 + d3 * l4 + m2 * a2 + p2 * f7 + b3 * (5 * x4) + v3 * (5 * y5);
    A4 = C4 >>> 13, C4 &= 8191, C4 += B3 * (5 * w) + E4 * (5 * g2) + I3 * (5 * h4) + S3 * (5 * u3) + O5 * (5 * c4), A4 += C4 >>> 13, C4 &= 8191;
    let H2 = A4 + d3 * c4 + m2 * l4 + p2 * a2 + b3 * f7 + v3 * (5 * x4);
    A4 = H2 >>> 13, H2 &= 8191, H2 += B3 * (5 * y5) + E4 * (5 * w) + I3 * (5 * g2) + S3 * (5 * h4) + O5 * (5 * u3), A4 += H2 >>> 13, H2 &= 8191;
    let q3 = A4 + d3 * u3 + m2 * c4 + p2 * l4 + b3 * a2 + v3 * f7;
    A4 = q3 >>> 13, q3 &= 8191, q3 += B3 * (5 * x4) + E4 * (5 * y5) + I3 * (5 * w) + S3 * (5 * g2) + O5 * (5 * h4), A4 += q3 >>> 13, q3 &= 8191;
    let P4 = A4 + d3 * h4 + m2 * u3 + p2 * c4 + b3 * l4 + v3 * a2;
    A4 = P4 >>> 13, P4 &= 8191, P4 += B3 * f7 + E4 * (5 * x4) + I3 * (5 * y5) + S3 * (5 * w) + O5 * (5 * g2), A4 += P4 >>> 13, P4 &= 8191;
    let K5 = A4 + d3 * g2 + m2 * h4 + p2 * u3 + b3 * c4 + v3 * l4;
    A4 = K5 >>> 13, K5 &= 8191, K5 += B3 * a2 + E4 * f7 + I3 * (5 * x4) + S3 * (5 * y5) + O5 * (5 * w), A4 += K5 >>> 13, K5 &= 8191;
    let et2 = A4 + d3 * w + m2 * g2 + p2 * h4 + b3 * u3 + v3 * c4;
    A4 = et2 >>> 13, et2 &= 8191, et2 += B3 * l4 + E4 * a2 + I3 * f7 + S3 * (5 * x4) + O5 * (5 * y5), A4 += et2 >>> 13, et2 &= 8191;
    let Z2 = A4 + d3 * y5 + m2 * w + p2 * g2 + b3 * h4 + v3 * u3;
    A4 = Z2 >>> 13, Z2 &= 8191, Z2 += B3 * c4 + E4 * l4 + I3 * a2 + S3 * f7 + O5 * (5 * x4), A4 += Z2 >>> 13, Z2 &= 8191;
    let z3 = A4 + d3 * x4 + m2 * y5 + p2 * w + b3 * g2 + v3 * h4;
    A4 = z3 >>> 13, z3 &= 8191, z3 += B3 * u3 + E4 * c4 + I3 * l4 + S3 * a2 + O5 * f7, A4 += z3 >>> 13, z3 &= 8191, A4 = (A4 << 2) + A4 | 0, A4 = A4 + T3 | 0, T3 = A4 & 8191, A4 = A4 >>> 13, U4 += A4, s[0] = T3, s[1] = U4, s[2] = C4, s[3] = H2, s[4] = q3, s[5] = P4, s[6] = K5, s[7] = et2, s[8] = Z2, s[9] = z3;
  }
  finalize() {
    const { h: e, pad: n2 } = this, r2 = new Uint16Array(10);
    let o2 = e[1] >>> 13;
    e[1] &= 8191;
    for (let f7 = 2; f7 < 10; f7++) e[f7] += o2, o2 = e[f7] >>> 13, e[f7] &= 8191;
    e[0] += o2 * 5, o2 = e[0] >>> 13, e[0] &= 8191, e[1] += o2, o2 = e[1] >>> 13, e[1] &= 8191, e[2] += o2, r2[0] = e[0] + 5, o2 = r2[0] >>> 13, r2[0] &= 8191;
    for (let f7 = 1; f7 < 10; f7++) r2[f7] = e[f7] + o2, o2 = r2[f7] >>> 13, r2[f7] &= 8191;
    r2[9] -= 8192;
    let s = (o2 ^ 1) - 1;
    for (let f7 = 0; f7 < 10; f7++) r2[f7] &= s;
    s = ~s;
    for (let f7 = 0; f7 < 10; f7++) e[f7] = e[f7] & s | r2[f7];
    e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
    let i3 = e[0] + n2[0];
    e[0] = i3 & 65535;
    for (let f7 = 1; f7 < 8; f7++) i3 = (e[f7] + n2[f7] | 0) + (i3 >>> 16) | 0, e[f7] = i3 & 65535;
    Wt(r2);
  }
  update(e) {
    to(this), e = mn(e), nt(e);
    const { buffer: n2, blockLen: r2 } = this, o2 = e.length;
    for (let s = 0; s < o2; ) {
      const i3 = Math.min(r2 - this.pos, o2 - s);
      if (i3 === r2) {
        for (; r2 <= o2 - s; s += r2) this.process(e, s);
        continue;
      }
      n2.set(e.subarray(s, s + i3), this.pos), this.pos += i3, s += i3, this.pos === r2 && (this.process(n2, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Wt(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e) {
    to(this), Sf(e, this), this.finished = true;
    const { buffer: n2, h: r2 } = this;
    let { pos: o2 } = this;
    if (o2) {
      for (n2[o2++] = 1; o2 < 16; o2++) n2[o2] = 0;
      this.process(n2, 0, true);
    }
    this.finalize();
    let s = 0;
    for (let i3 = 0; i3 < 8; i3++) e[s++] = r2[i3] >>> 0, e[s++] = r2[i3] >>> 8;
    return e;
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
};
function qf(t) {
  const e = (r2, o2) => t(o2).update(mn(r2)).digest(), n2 = t(new Uint8Array(32));
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = (r2) => t(r2), e;
}
var Kf = qf((t) => new Vf(t));
function Ff(t, e, n2, r2, o2, s = 20) {
  let i3 = t[0], f7 = t[1], a2 = t[2], l4 = t[3], c4 = e[0], u3 = e[1], h4 = e[2], g2 = e[3], w = e[4], y5 = e[5], x4 = e[6], R4 = e[7], M5 = o2, L2 = n2[0], V5 = n2[1], _2 = n2[2], k4 = i3, j3 = f7, $3 = a2, d3 = l4, m2 = c4, p2 = u3, b3 = h4, v3 = g2, B3 = w, E4 = y5, I3 = x4, S3 = R4, O5 = M5, A4 = L2, T3 = V5, U4 = _2;
  for (let H2 = 0; H2 < s; H2 += 2) k4 = k4 + m2 | 0, O5 = D2(O5 ^ k4, 16), B3 = B3 + O5 | 0, m2 = D2(m2 ^ B3, 12), k4 = k4 + m2 | 0, O5 = D2(O5 ^ k4, 8), B3 = B3 + O5 | 0, m2 = D2(m2 ^ B3, 7), j3 = j3 + p2 | 0, A4 = D2(A4 ^ j3, 16), E4 = E4 + A4 | 0, p2 = D2(p2 ^ E4, 12), j3 = j3 + p2 | 0, A4 = D2(A4 ^ j3, 8), E4 = E4 + A4 | 0, p2 = D2(p2 ^ E4, 7), $3 = $3 + b3 | 0, T3 = D2(T3 ^ $3, 16), I3 = I3 + T3 | 0, b3 = D2(b3 ^ I3, 12), $3 = $3 + b3 | 0, T3 = D2(T3 ^ $3, 8), I3 = I3 + T3 | 0, b3 = D2(b3 ^ I3, 7), d3 = d3 + v3 | 0, U4 = D2(U4 ^ d3, 16), S3 = S3 + U4 | 0, v3 = D2(v3 ^ S3, 12), d3 = d3 + v3 | 0, U4 = D2(U4 ^ d3, 8), S3 = S3 + U4 | 0, v3 = D2(v3 ^ S3, 7), k4 = k4 + p2 | 0, U4 = D2(U4 ^ k4, 16), I3 = I3 + U4 | 0, p2 = D2(p2 ^ I3, 12), k4 = k4 + p2 | 0, U4 = D2(U4 ^ k4, 8), I3 = I3 + U4 | 0, p2 = D2(p2 ^ I3, 7), j3 = j3 + b3 | 0, O5 = D2(O5 ^ j3, 16), S3 = S3 + O5 | 0, b3 = D2(b3 ^ S3, 12), j3 = j3 + b3 | 0, O5 = D2(O5 ^ j3, 8), S3 = S3 + O5 | 0, b3 = D2(b3 ^ S3, 7), $3 = $3 + v3 | 0, A4 = D2(A4 ^ $3, 16), B3 = B3 + A4 | 0, v3 = D2(v3 ^ B3, 12), $3 = $3 + v3 | 0, A4 = D2(A4 ^ $3, 8), B3 = B3 + A4 | 0, v3 = D2(v3 ^ B3, 7), d3 = d3 + m2 | 0, T3 = D2(T3 ^ d3, 16), E4 = E4 + T3 | 0, m2 = D2(m2 ^ E4, 12), d3 = d3 + m2 | 0, T3 = D2(T3 ^ d3, 8), E4 = E4 + T3 | 0, m2 = D2(m2 ^ E4, 7);
  let C4 = 0;
  r2[C4++] = i3 + k4 | 0, r2[C4++] = f7 + j3 | 0, r2[C4++] = a2 + $3 | 0, r2[C4++] = l4 + d3 | 0, r2[C4++] = c4 + m2 | 0, r2[C4++] = u3 + p2 | 0, r2[C4++] = h4 + b3 | 0, r2[C4++] = g2 + v3 | 0, r2[C4++] = w + B3 | 0, r2[C4++] = y5 + E4 | 0, r2[C4++] = x4 + I3 | 0, r2[C4++] = R4 + S3 | 0, r2[C4++] = M5 + O5 | 0, r2[C4++] = L2 + A4 | 0, r2[C4++] = V5 + T3 | 0, r2[C4++] = _2 + U4 | 0;
}
var zf = Mf(Ff, { counterRight: false, counterLength: 4, allowShortKeys: false });
var Gf = new Uint8Array(16);
var io = (t, e) => {
  t.update(e);
  const n2 = e.length % 16;
  n2 && t.update(Gf.subarray(n2));
};
var Zf = new Uint8Array(32);
function fo(t, e, n2, r2, o2) {
  const s = t(e, n2, Zf), i3 = Kf.create(s);
  o2 && io(i3, o2), io(i3, r2);
  const f7 = $f(r2.length, o2 ? o2.length : 0, true);
  i3.update(f7);
  const a2 = i3.digest();
  return Wt(s, f7), a2;
}
var Wf = (t) => (e, n2, r2) => ({ encrypt(s, i3) {
  const f7 = s.length;
  i3 = eo(f7 + 16, i3, false), i3.set(s);
  const a2 = i3.subarray(0, -16);
  t(e, n2, a2, a2, 1);
  const l4 = fo(t, e, n2, a2, r2);
  return i3.set(l4, f7), Wt(l4), i3;
}, decrypt(s, i3) {
  i3 = eo(s.length - 16, i3, false);
  const f7 = s.subarray(0, -16), a2 = s.subarray(-16), l4 = fo(t, e, n2, f7, r2);
  if (!Tf(a2, l4)) throw new Error("invalid tag");
  return i3.set(s.subarray(0, -16)), t(e, n2, i3, i3, 1), Wt(l4), i3;
} });
var co = Rf({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Wf(zf));
var ao = class extends Ie {
  constructor(e, n2) {
    super(), this.finished = false, this.destroyed = false, rn(e);
    const r2 = ht(n2);
    if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o2 = this.blockLen, s = new Uint8Array(o2);
    s.set(r2.length > o2 ? e.create().update(r2).digest() : r2);
    for (let i3 = 0; i3 < s.length; i3++) s[i3] ^= 54;
    this.iHash.update(s), this.oHash = e.create();
    for (let i3 = 0; i3 < s.length; i3++) s[i3] ^= 106;
    this.oHash.update(s), ut(s);
  }
  update(e) {
    return Nt(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Nt(this), at(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n2, iHash: r2, finished: o2, destroyed: s, blockLen: i3, outputLen: f7 } = this;
    return e = e, e.finished = o2, e.destroyed = s, e.blockLen = i3, e.outputLen = f7, e.oHash = n2._cloneInto(e.oHash), e.iHash = r2._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var _e = (t, e, n2) => new ao(t, e).update(n2).digest();
_e.create = (t, e) => new ao(t, e);
function Yf(t, e, n2) {
  return rn(t), n2 === void 0 && (n2 = new Uint8Array(t.outputLen)), _e(t, ht(n2), ht(e));
}
var vn = Uint8Array.from([0]);
var uo = Uint8Array.of();
function Xf(t, e, n2, r2 = 32) {
  rn(t), mt(r2);
  const o2 = t.outputLen;
  if (r2 > 255 * o2) throw new Error("Length should be <= 255*HashLen");
  const s = Math.ceil(r2 / o2);
  n2 === void 0 && (n2 = uo);
  const i3 = new Uint8Array(s * o2), f7 = _e.create(t, e), a2 = f7._cloneInto(), l4 = new Uint8Array(f7.outputLen);
  for (let c4 = 0; c4 < s; c4++) vn[0] = c4 + 1, a2.update(c4 === 0 ? uo : l4).update(n2).update(vn).digestInto(l4), i3.set(l4, o2 * c4), f7._cloneInto(a2);
  return f7.destroy(), a2.destroy(), ut(l4, vn), i3.slice(0, r2);
}
var Jf = (t, e, n2, r2, o2) => Xf(t, Yf(t, e, n2), r2, o2);
var Te = Ae;
var En = BigInt(0);
var Bn = BigInt(1);
function Re(t, e) {
  if (typeof e != "boolean") throw new Error(t + " boolean expected, got " + e);
}
function $e(t) {
  const e = t.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function lo(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  return t === "" ? En : BigInt("0x" + t);
}
function Ce(t) {
  return lo(ce(t));
}
function Le(t) {
  return at(t), lo(ce(Uint8Array.from(t).reverse()));
}
function In(t, e) {
  return fn(t.toString(16).padStart(e * 2, "0"));
}
function An(t, e) {
  return In(t, e).reverse();
}
function rt(t, e, n2) {
  let r2;
  if (typeof e == "string") try {
    r2 = fn(e);
  } catch (s) {
    throw new Error(t + " must be hex string or Uint8Array, cause: " + s);
  }
  else if (nn(e)) r2 = Uint8Array.from(e);
  else throw new Error(t + " must be hex string or Uint8Array");
  const o2 = r2.length;
  if (typeof n2 == "number" && o2 !== n2) throw new Error(t + " of length " + n2 + " expected, got " + o2);
  return r2;
}
var Sn = (t) => typeof t == "bigint" && En <= t;
function Qf(t, e, n2) {
  return Sn(t) && Sn(e) && Sn(n2) && e <= t && t < n2;
}
function Nn(t, e, n2, r2) {
  if (!Qf(e, n2, r2)) throw new Error("expected valid " + t + ": " + n2 + " <= n < " + r2 + ", got " + e);
}
function tc(t) {
  let e;
  for (e = 0; t > En; t >>= Bn, e += 1) ;
  return e;
}
var je = (t) => (Bn << BigInt(t)) - Bn;
function ec(t, e, n2) {
  if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
  if (typeof n2 != "function") throw new Error("hmacFn must be a function");
  const r2 = (g2) => new Uint8Array(g2), o2 = (g2) => Uint8Array.of(g2);
  let s = r2(t), i3 = r2(t), f7 = 0;
  const a2 = () => {
    s.fill(1), i3.fill(0), f7 = 0;
  }, l4 = (...g2) => n2(i3, s, ...g2), c4 = (g2 = r2(0)) => {
    i3 = l4(o2(0), g2), s = l4(), g2.length !== 0 && (i3 = l4(o2(1), g2), s = l4());
  }, u3 = () => {
    if (f7++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let g2 = 0;
    const w = [];
    for (; g2 < e; ) {
      s = l4();
      const y5 = s.slice();
      w.push(y5), g2 += s.length;
    }
    return Ht(...w);
  };
  return (g2, w) => {
    a2(), c4(g2);
    let y5;
    for (; !(y5 = w(u3())); ) c4();
    return a2(), y5;
  };
}
function ke(t, e, n2 = {}) {
  if (!t || typeof t != "object") throw new Error("expected valid options object");
  function r2(o2, s, i3) {
    const f7 = t[o2];
    if (i3 && f7 === void 0) return;
    const a2 = typeof f7;
    if (a2 !== s || f7 === null) throw new Error(`param "${o2}" is invalid: expected ${s}, got ${a2}`);
  }
  Object.entries(e).forEach(([o2, s]) => r2(o2, s, false)), Object.entries(n2).forEach(([o2, s]) => r2(o2, s, true));
}
function ho(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n2, ...r2) => {
    const o2 = e.get(n2);
    if (o2 !== void 0) return o2;
    const s = t(n2, ...r2);
    return e.set(n2, s), s;
  };
}
var ot = BigInt(0);
var Q = BigInt(1);
var Dt = BigInt(2);
var nc = BigInt(3);
var po = BigInt(4);
var go = BigInt(5);
var bo = BigInt(8);
function lt(t, e) {
  const n2 = t % e;
  return n2 >= ot ? n2 : e + n2;
}
function pt(t, e, n2) {
  let r2 = t;
  for (; e-- > ot; ) r2 *= r2, r2 %= n2;
  return r2;
}
function yo(t, e) {
  if (t === ot) throw new Error("invert: expected non-zero number");
  if (e <= ot) throw new Error("invert: expected positive modulus, got " + e);
  let n2 = lt(t, e), r2 = e, o2 = ot, s = Q;
  for (; n2 !== ot; ) {
    const f7 = r2 / n2, a2 = r2 % n2, l4 = o2 - s * f7;
    r2 = n2, n2 = a2, o2 = s, s = l4;
  }
  if (r2 !== Q) throw new Error("invert: does not exist");
  return lt(o2, e);
}
function mo(t, e) {
  const n2 = (t.ORDER + Q) / po, r2 = t.pow(e, n2);
  if (!t.eql(t.sqr(r2), e)) throw new Error("Cannot find square root");
  return r2;
}
function rc(t, e) {
  const n2 = (t.ORDER - go) / bo, r2 = t.mul(e, Dt), o2 = t.pow(r2, n2), s = t.mul(e, o2), i3 = t.mul(t.mul(s, Dt), o2), f7 = t.mul(s, t.sub(i3, t.ONE));
  if (!t.eql(t.sqr(f7), e)) throw new Error("Cannot find square root");
  return f7;
}
function oc(t) {
  if (t < BigInt(3)) throw new Error("sqrt is not defined for small field");
  let e = t - Q, n2 = 0;
  for (; e % Dt === ot; ) e /= Dt, n2++;
  let r2 = Dt;
  const o2 = Yt(t);
  for (; xo(o2, r2) === 1; ) if (r2++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
  if (n2 === 1) return mo;
  let s = o2.pow(r2, e);
  const i3 = (e + Q) / Dt;
  return function(a2, l4) {
    if (a2.is0(l4)) return l4;
    if (xo(a2, l4) !== 1) throw new Error("Cannot find square root");
    let c4 = n2, u3 = a2.mul(a2.ONE, s), h4 = a2.pow(l4, e), g2 = a2.pow(l4, i3);
    for (; !a2.eql(h4, a2.ONE); ) {
      if (a2.is0(h4)) return a2.ZERO;
      let w = 1, y5 = a2.sqr(h4);
      for (; !a2.eql(y5, a2.ONE); ) if (w++, y5 = a2.sqr(y5), w === c4) throw new Error("Cannot find square root");
      const x4 = Q << BigInt(c4 - w - 1), R4 = a2.pow(u3, x4);
      c4 = w, u3 = a2.sqr(R4), h4 = a2.mul(h4, u3), g2 = a2.mul(g2, R4);
    }
    return g2;
  };
}
function sc(t) {
  return t % po === nc ? mo : t % bo === go ? rc : oc(t);
}
var ic = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function fc(t) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }, n2 = ic.reduce((r2, o2) => (r2[o2] = "function", r2), e);
  return ke(t, n2), t;
}
function cc(t, e, n2) {
  if (n2 < ot) throw new Error("invalid exponent, negatives unsupported");
  if (n2 === ot) return t.ONE;
  if (n2 === Q) return e;
  let r2 = t.ONE, o2 = e;
  for (; n2 > ot; ) n2 & Q && (r2 = t.mul(r2, o2)), o2 = t.sqr(o2), n2 >>= Q;
  return r2;
}
function wo(t, e, n2 = false) {
  const r2 = new Array(e.length).fill(n2 ? t.ZERO : void 0), o2 = e.reduce((i3, f7, a2) => t.is0(f7) ? i3 : (r2[a2] = i3, t.mul(i3, f7)), t.ONE), s = t.inv(o2);
  return e.reduceRight((i3, f7, a2) => t.is0(f7) ? i3 : (r2[a2] = t.mul(i3, r2[a2]), t.mul(i3, f7)), s), r2;
}
function xo(t, e) {
  const n2 = (t.ORDER - Q) / Dt, r2 = t.pow(e, n2), o2 = t.eql(r2, t.ONE), s = t.eql(r2, t.ZERO), i3 = t.eql(r2, t.neg(t.ONE));
  if (!o2 && !s && !i3) throw new Error("invalid Legendre symbol result");
  return o2 ? 1 : s ? 0 : -1;
}
function ac(t, e) {
  e !== void 0 && mt(e);
  const n2 = e !== void 0 ? e : t.toString(2).length, r2 = Math.ceil(n2 / 8);
  return { nBitLength: n2, nByteLength: r2 };
}
function Yt(t, e, n2 = false, r2 = {}) {
  if (t <= ot) throw new Error("invalid field: expected ORDER > 0, got " + t);
  let o2, s;
  if (typeof e == "object" && e != null) {
    if (r2.sqrt || n2) throw new Error("cannot specify opts in two arguments");
    const c4 = e;
    c4.BITS && (o2 = c4.BITS), c4.sqrt && (s = c4.sqrt), typeof c4.isLE == "boolean" && (n2 = c4.isLE);
  } else typeof e == "number" && (o2 = e), r2.sqrt && (s = r2.sqrt);
  const { nBitLength: i3, nByteLength: f7 } = ac(t, o2);
  if (f7 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a2;
  const l4 = Object.freeze({ ORDER: t, isLE: n2, BITS: i3, BYTES: f7, MASK: je(i3), ZERO: ot, ONE: Q, create: (c4) => lt(c4, t), isValid: (c4) => {
    if (typeof c4 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c4);
    return ot <= c4 && c4 < t;
  }, is0: (c4) => c4 === ot, isValidNot0: (c4) => !l4.is0(c4) && l4.isValid(c4), isOdd: (c4) => (c4 & Q) === Q, neg: (c4) => lt(-c4, t), eql: (c4, u3) => c4 === u3, sqr: (c4) => lt(c4 * c4, t), add: (c4, u3) => lt(c4 + u3, t), sub: (c4, u3) => lt(c4 - u3, t), mul: (c4, u3) => lt(c4 * u3, t), pow: (c4, u3) => cc(l4, c4, u3), div: (c4, u3) => lt(c4 * yo(u3, t), t), sqrN: (c4) => c4 * c4, addN: (c4, u3) => c4 + u3, subN: (c4, u3) => c4 - u3, mulN: (c4, u3) => c4 * u3, inv: (c4) => yo(c4, t), sqrt: s || ((c4) => (a2 || (a2 = sc(t)), a2(l4, c4))), toBytes: (c4) => n2 ? An(c4, f7) : In(c4, f7), fromBytes: (c4) => {
    if (c4.length !== f7) throw new Error("Field.fromBytes: expected " + f7 + " bytes, got " + c4.length);
    return n2 ? Le(c4) : Ce(c4);
  }, invertBatch: (c4) => wo(l4, c4), cmov: (c4, u3, h4) => h4 ? u3 : c4 });
  return Object.freeze(l4);
}
function vo(t) {
  if (typeof t != "bigint") throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function Eo(t) {
  const e = vo(t);
  return e + Math.ceil(e / 2);
}
function uc(t, e, n2 = false) {
  const r2 = t.length, o2 = vo(e), s = Eo(e);
  if (r2 < 16 || r2 < s || r2 > 1024) throw new Error("expected " + s + "-1024 bytes of input, got " + r2);
  const i3 = n2 ? Le(t) : Ce(t), f7 = lt(i3, e - Q) + Q;
  return n2 ? An(f7, o2) : In(f7, o2);
}
var Xt = BigInt(0);
var Mt = BigInt(1);
function le(t, e) {
  const n2 = e.negate();
  return t ? n2 : e;
}
function lc(t, e, n2) {
  const r2 = e === "pz" ? (i3) => i3.pz : (i3) => i3.ez, o2 = wo(t.Fp, n2.map(r2));
  return n2.map((i3, f7) => i3.toAffine(o2[f7])).map(t.fromAffine);
}
function Bo(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function On(t, e) {
  Bo(t, e);
  const n2 = Math.ceil(e / t) + 1, r2 = 2 ** (t - 1), o2 = 2 ** t, s = je(t), i3 = BigInt(t);
  return { windows: n2, windowSize: r2, mask: s, maxNumber: o2, shiftBy: i3 };
}
function Io(t, e, n2) {
  const { windowSize: r2, mask: o2, maxNumber: s, shiftBy: i3 } = n2;
  let f7 = Number(t & o2), a2 = t >> i3;
  f7 > r2 && (f7 -= s, a2 += Mt);
  const l4 = e * r2, c4 = l4 + Math.abs(f7) - 1, u3 = f7 === 0, h4 = f7 < 0, g2 = e % 2 !== 0;
  return { nextN: a2, offset: c4, isZero: u3, isNeg: h4, isNegF: g2, offsetF: l4 };
}
function dc(t, e) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n2, r2) => {
    if (!(n2 instanceof e)) throw new Error("invalid point at index " + r2);
  });
}
function hc(t, e) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n2, r2) => {
    if (!e.isValid(n2)) throw new Error("invalid scalar at index " + r2);
  });
}
var Un = /* @__PURE__ */ new WeakMap();
var Ao = /* @__PURE__ */ new WeakMap();
function _n(t) {
  return Ao.get(t) || 1;
}
function So(t) {
  if (t !== Xt) throw new Error("invalid wNAF");
}
function pc(t, e) {
  return { constTimeNegate: le, hasPrecomputes(n2) {
    return _n(n2) !== 1;
  }, unsafeLadder(n2, r2, o2 = t.ZERO) {
    let s = n2;
    for (; r2 > Xt; ) r2 & Mt && (o2 = o2.add(s)), s = s.double(), r2 >>= Mt;
    return o2;
  }, precomputeWindow(n2, r2) {
    const { windows: o2, windowSize: s } = On(r2, e), i3 = [];
    let f7 = n2, a2 = f7;
    for (let l4 = 0; l4 < o2; l4++) {
      a2 = f7, i3.push(a2);
      for (let c4 = 1; c4 < s; c4++) a2 = a2.add(f7), i3.push(a2);
      f7 = a2.double();
    }
    return i3;
  }, wNAF(n2, r2, o2) {
    let s = t.ZERO, i3 = t.BASE;
    const f7 = On(n2, e);
    for (let a2 = 0; a2 < f7.windows; a2++) {
      const { nextN: l4, offset: c4, isZero: u3, isNeg: h4, isNegF: g2, offsetF: w } = Io(o2, a2, f7);
      o2 = l4, u3 ? i3 = i3.add(le(g2, r2[w])) : s = s.add(le(h4, r2[c4]));
    }
    return So(o2), { p: s, f: i3 };
  }, wNAFUnsafe(n2, r2, o2, s = t.ZERO) {
    const i3 = On(n2, e);
    for (let f7 = 0; f7 < i3.windows && o2 !== Xt; f7++) {
      const { nextN: a2, offset: l4, isZero: c4, isNeg: u3 } = Io(o2, f7, i3);
      if (o2 = a2, !c4) {
        const h4 = r2[l4];
        s = s.add(u3 ? h4.negate() : h4);
      }
    }
    return So(o2), s;
  }, getPrecomputes(n2, r2, o2) {
    let s = Un.get(r2);
    return s || (s = this.precomputeWindow(r2, n2), n2 !== 1 && (typeof o2 == "function" && (s = o2(s)), Un.set(r2, s))), s;
  }, wNAFCached(n2, r2, o2) {
    const s = _n(n2);
    return this.wNAF(s, this.getPrecomputes(s, n2, o2), r2);
  }, wNAFCachedUnsafe(n2, r2, o2, s) {
    const i3 = _n(n2);
    return i3 === 1 ? this.unsafeLadder(n2, r2, s) : this.wNAFUnsafe(i3, this.getPrecomputes(i3, n2, o2), r2, s);
  }, setWindowSize(n2, r2) {
    Bo(r2, e), Ao.set(n2, r2), Un.delete(n2);
  } };
}
function gc(t, e, n2, r2) {
  let o2 = e, s = t.ZERO, i3 = t.ZERO;
  for (; n2 > Xt || r2 > Xt; ) n2 & Mt && (s = s.add(o2)), r2 & Mt && (i3 = i3.add(o2)), o2 = o2.double(), n2 >>= Mt, r2 >>= Mt;
  return { p1: s, p2: i3 };
}
function bc(t, e, n2, r2) {
  dc(n2, t), hc(r2, e);
  const o2 = n2.length, s = r2.length;
  if (o2 !== s) throw new Error("arrays of points and scalars must have equal length");
  const i3 = t.ZERO, f7 = tc(BigInt(o2));
  let a2 = 1;
  f7 > 12 ? a2 = f7 - 3 : f7 > 4 ? a2 = f7 - 2 : f7 > 0 && (a2 = 2);
  const l4 = je(a2), c4 = new Array(Number(l4) + 1).fill(i3), u3 = Math.floor((e.BITS - 1) / a2) * a2;
  let h4 = i3;
  for (let g2 = u3; g2 >= 0; g2 -= a2) {
    c4.fill(i3);
    for (let y5 = 0; y5 < s; y5++) {
      const x4 = r2[y5], R4 = Number(x4 >> BigInt(g2) & l4);
      c4[R4] = c4[R4].add(n2[y5]);
    }
    let w = i3;
    for (let y5 = c4.length - 1, x4 = i3; y5 > 0; y5--) x4 = x4.add(c4[y5]), w = w.add(x4);
    if (h4 = h4.add(w), g2 !== 0) for (let y5 = 0; y5 < a2; y5++) h4 = h4.double();
  }
  return h4;
}
function No(t, e) {
  if (e) {
    if (e.ORDER !== t) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return fc(e), e;
  } else return Yt(t);
}
function yc(t, e, n2 = {}) {
  if (!e || typeof e != "object") throw new Error(`expected valid ${t} CURVE object`);
  for (const f7 of ["p", "n", "h"]) {
    const a2 = e[f7];
    if (!(typeof a2 == "bigint" && a2 > Xt)) throw new Error(`CURVE.${f7} must be positive bigint`);
  }
  const r2 = No(e.p, n2.Fp), o2 = No(e.n, n2.Fn), i3 = ["Gx", "Gy", "a", t === "weierstrass" ? "b" : "d"];
  for (const f7 of i3) if (!r2.isValid(e[f7])) throw new Error(`CURVE.${f7} must be valid field element of CURVE.Fp`);
  return { Fp: r2, Fn: o2 };
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var de = BigInt(0);
var Jt = BigInt(1);
var Pe = BigInt(2);
function mc(t) {
  return ke(t, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...t });
}
function wc(t) {
  const e = mc(t), { P: n2, type: r2, adjustScalarBytes: o2, powPminus2: s, randomBytes: i3 } = e, f7 = r2 === "x25519";
  if (!f7 && r2 !== "x448") throw new Error("invalid type");
  const a2 = i3 || Zt, l4 = f7 ? 255 : 448, c4 = f7 ? 32 : 56, u3 = BigInt(f7 ? 9 : 5), h4 = BigInt(f7 ? 121665 : 39081), g2 = f7 ? Pe ** BigInt(254) : Pe ** BigInt(447), w = f7 ? BigInt(8) * Pe ** BigInt(251) - Jt : BigInt(4) * Pe ** BigInt(445) - Jt, y5 = g2 + w + Jt, x4 = (d3) => lt(d3, n2), R4 = M5(u3);
  function M5(d3) {
    return An(x4(d3), c4);
  }
  function L2(d3) {
    const m2 = rt("u coordinate", d3, c4);
    return f7 && (m2[31] &= 127), x4(Le(m2));
  }
  function V5(d3) {
    return Le(o2(rt("scalar", d3, c4)));
  }
  function _2(d3, m2) {
    const p2 = $3(L2(m2), V5(d3));
    if (p2 === de) throw new Error("invalid private or public key received");
    return M5(p2);
  }
  function k4(d3) {
    return _2(d3, R4);
  }
  function j3(d3, m2, p2) {
    const b3 = x4(d3 * (m2 - p2));
    return m2 = x4(m2 - b3), p2 = x4(p2 + b3), { x_2: m2, x_3: p2 };
  }
  function $3(d3, m2) {
    Nn("u", d3, de, n2), Nn("scalar", m2, g2, y5);
    const p2 = m2, b3 = d3;
    let v3 = Jt, B3 = de, E4 = d3, I3 = Jt, S3 = de;
    for (let A4 = BigInt(l4 - 1); A4 >= de; A4--) {
      const T3 = p2 >> A4 & Jt;
      S3 ^= T3, { x_2: v3, x_3: E4 } = j3(S3, v3, E4), { x_2: B3, x_3: I3 } = j3(S3, B3, I3), S3 = T3;
      const U4 = v3 + B3, C4 = x4(U4 * U4), H2 = v3 - B3, q3 = x4(H2 * H2), P4 = C4 - q3, K5 = E4 + I3, et2 = E4 - I3, Z2 = x4(et2 * U4), z3 = x4(K5 * H2), Ft2 = Z2 + z3, yt3 = Z2 - z3;
      E4 = x4(Ft2 * Ft2), I3 = x4(b3 * x4(yt3 * yt3)), v3 = x4(C4 * q3), B3 = x4(P4 * (C4 + x4(h4 * P4)));
    }
    ({ x_2: v3, x_3: E4 } = j3(S3, v3, E4)), { x_2: B3, x_3: I3 } = j3(S3, B3, I3);
    const O5 = s(B3);
    return x4(v3 * O5);
  }
  return { scalarMult: _2, scalarMultBase: k4, getSharedSecret: (d3, m2) => _2(d3, m2), getPublicKey: (d3) => k4(d3), utils: { randomPrivateKey: () => a2(c4) }, GuBytes: R4.slice() };
}
BigInt(0);
var xc = BigInt(1);
var Oo = BigInt(2);
var vc = BigInt(3);
var Ec = BigInt(5);
var Bc = BigInt(8);
var Uo = { p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"), n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"), h: Bc, a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"), d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"), Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"), Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658") };
function Ic(t) {
  const e = BigInt(10), n2 = BigInt(20), r2 = BigInt(40), o2 = BigInt(80), s = Uo.p, f7 = t * t % s * t % s, a2 = pt(f7, Oo, s) * f7 % s, l4 = pt(a2, xc, s) * t % s, c4 = pt(l4, Ec, s) * l4 % s, u3 = pt(c4, e, s) * c4 % s, h4 = pt(u3, n2, s) * u3 % s, g2 = pt(h4, r2, s) * h4 % s, w = pt(g2, o2, s) * g2 % s, y5 = pt(w, o2, s) * g2 % s, x4 = pt(y5, e, s) * c4 % s;
  return { pow_p_5_8: pt(x4, Oo, s) * t % s, b2: f7 };
}
function Ac(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
var Tn = (() => {
  const t = Uo.p;
  return wc({ P: t, type: "x25519", powPminus2: (e) => {
    const { pow_p_5_8: n2, b2: r2 } = Ic(e);
    return lt(pt(n2, vc, t) * r2, t);
  }, adjustScalarBytes: Ac });
})();
function _o(t) {
  t.lowS !== void 0 && Re("lowS", t.lowS), t.prehash !== void 0 && Re("prehash", t.prehash);
}
var Sc = class extends Error {
  constructor(e = "") {
    super(e);
  }
};
var vt = { Err: Sc, _tlv: { encode: (t, e) => {
  const { Err: n2 } = vt;
  if (t < 0 || t > 256) throw new n2("tlv.encode: wrong tag");
  if (e.length & 1) throw new n2("tlv.encode: unpadded data");
  const r2 = e.length / 2, o2 = $e(r2);
  if (o2.length / 2 & 128) throw new n2("tlv.encode: long form length too big");
  const s = r2 > 127 ? $e(o2.length / 2 | 128) : "";
  return $e(t) + s + o2 + e;
}, decode(t, e) {
  const { Err: n2 } = vt;
  let r2 = 0;
  if (t < 0 || t > 256) throw new n2("tlv.encode: wrong tag");
  if (e.length < 2 || e[r2++] !== t) throw new n2("tlv.decode: wrong tlv");
  const o2 = e[r2++], s = !!(o2 & 128);
  let i3 = 0;
  if (!s) i3 = o2;
  else {
    const a2 = o2 & 127;
    if (!a2) throw new n2("tlv.decode(long): indefinite length not supported");
    if (a2 > 4) throw new n2("tlv.decode(long): byte length is too big");
    const l4 = e.subarray(r2, r2 + a2);
    if (l4.length !== a2) throw new n2("tlv.decode: length bytes not complete");
    if (l4[0] === 0) throw new n2("tlv.decode(long): zero leftmost byte");
    for (const c4 of l4) i3 = i3 << 8 | c4;
    if (r2 += a2, i3 < 128) throw new n2("tlv.decode(long): not minimal encoding");
  }
  const f7 = e.subarray(r2, r2 + i3);
  if (f7.length !== i3) throw new n2("tlv.decode: wrong value length");
  return { v: f7, l: e.subarray(r2 + i3) };
} }, _int: { encode(t) {
  const { Err: e } = vt;
  if (t < he) throw new e("integer: negative integers are not allowed");
  let n2 = $e(t);
  if (Number.parseInt(n2[0], 16) & 8 && (n2 = "00" + n2), n2.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
  return n2;
}, decode(t) {
  const { Err: e } = vt;
  if (t[0] & 128) throw new e("invalid signature integer: negative");
  if (t[0] === 0 && !(t[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
  return Ce(t);
} }, toSig(t) {
  const { Err: e, _int: n2, _tlv: r2 } = vt, o2 = rt("signature", t), { v: s, l: i3 } = r2.decode(48, o2);
  if (i3.length) throw new e("invalid signature: left bytes after parsing");
  const { v: f7, l: a2 } = r2.decode(2, s), { v: l4, l: c4 } = r2.decode(2, a2);
  if (c4.length) throw new e("invalid signature: left bytes after parsing");
  return { r: n2.decode(f7), s: n2.decode(l4) };
}, hexFromSig(t) {
  const { _tlv: e, _int: n2 } = vt, r2 = e.encode(2, n2.encode(t.r)), o2 = e.encode(2, n2.encode(t.s)), s = r2 + o2;
  return e.encode(48, s);
} };
var he = BigInt(0);
var pe = BigInt(1);
var Nc = BigInt(2);
var He = BigInt(3);
var Oc = BigInt(4);
function Uc(t, e, n2) {
  function r2(o2) {
    const s = t.sqr(o2), i3 = t.mul(s, o2);
    return t.add(t.add(i3, t.mul(o2, e)), n2);
  }
  return r2;
}
function To(t, e, n2) {
  const { BYTES: r2 } = t;
  function o2(s) {
    let i3;
    if (typeof s == "bigint") i3 = s;
    else {
      let f7 = rt("private key", s);
      if (e) {
        if (!e.includes(f7.length * 2)) throw new Error("invalid private key");
        const a2 = new Uint8Array(r2);
        a2.set(f7, a2.length - f7.length), f7 = a2;
      }
      try {
        i3 = t.fromBytes(f7);
      } catch {
        throw new Error(`invalid private key: expected ui8a of size ${r2}, got ${typeof s}`);
      }
    }
    if (n2 && (i3 = t.create(i3)), !t.isValidNot0(i3)) throw new Error("invalid private key: out of range [1..N-1]");
    return i3;
  }
  return o2;
}
function _c(t, e = {}) {
  const { Fp: n2, Fn: r2 } = yc("weierstrass", t, e), { h: o2, n: s } = t;
  ke(e, {}, { allowInfinityPoint: "boolean", clearCofactor: "function", isTorsionFree: "function", fromBytes: "function", toBytes: "function", endo: "object", wrapPrivateKey: "boolean" });
  const { endo: i3 } = e;
  if (i3 && (!n2.is0(t.a) || typeof i3.beta != "bigint" || typeof i3.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
  function f7() {
    if (!n2.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function a2($3, d3, m2) {
    const { x: p2, y: b3 } = d3.toAffine(), v3 = n2.toBytes(p2);
    if (Re("isCompressed", m2), m2) {
      f7();
      const B3 = !n2.isOdd(b3);
      return Ht(Ro(B3), v3);
    } else return Ht(Uint8Array.of(4), v3, n2.toBytes(b3));
  }
  function l4($3) {
    at($3);
    const d3 = n2.BYTES, m2 = d3 + 1, p2 = 2 * d3 + 1, b3 = $3.length, v3 = $3[0], B3 = $3.subarray(1);
    if (b3 === m2 && (v3 === 2 || v3 === 3)) {
      const E4 = n2.fromBytes(B3);
      if (!n2.isValid(E4)) throw new Error("bad point: is not on curve, wrong x");
      const I3 = h4(E4);
      let S3;
      try {
        S3 = n2.sqrt(I3);
      } catch (T3) {
        const U4 = T3 instanceof Error ? ": " + T3.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + U4);
      }
      f7();
      const O5 = n2.isOdd(S3);
      return (v3 & 1) === 1 !== O5 && (S3 = n2.neg(S3)), { x: E4, y: S3 };
    } else if (b3 === p2 && v3 === 4) {
      const E4 = n2.fromBytes(B3.subarray(d3 * 0, d3 * 1)), I3 = n2.fromBytes(B3.subarray(d3 * 1, d3 * 2));
      if (!g2(E4, I3)) throw new Error("bad point: is not on curve");
      return { x: E4, y: I3 };
    } else throw new Error(`bad point: got length ${b3}, expected compressed=${m2} or uncompressed=${p2}`);
  }
  const c4 = e.toBytes || a2, u3 = e.fromBytes || l4, h4 = Uc(n2, t.a, t.b);
  function g2($3, d3) {
    const m2 = n2.sqr(d3), p2 = h4($3);
    return n2.eql(m2, p2);
  }
  if (!g2(t.Gx, t.Gy)) throw new Error("bad curve params: generator point");
  const w = n2.mul(n2.pow(t.a, He), Oc), y5 = n2.mul(n2.sqr(t.b), BigInt(27));
  if (n2.is0(n2.add(w, y5))) throw new Error("bad curve params: a or b");
  function x4($3, d3, m2 = false) {
    if (!n2.isValid(d3) || m2 && n2.is0(d3)) throw new Error(`bad point coordinate ${$3}`);
    return d3;
  }
  function R4($3) {
    if (!($3 instanceof _2)) throw new Error("ProjectivePoint expected");
  }
  const M5 = ho(($3, d3) => {
    const { px: m2, py: p2, pz: b3 } = $3;
    if (n2.eql(b3, n2.ONE)) return { x: m2, y: p2 };
    const v3 = $3.is0();
    d3 == null && (d3 = v3 ? n2.ONE : n2.inv(b3));
    const B3 = n2.mul(m2, d3), E4 = n2.mul(p2, d3), I3 = n2.mul(b3, d3);
    if (v3) return { x: n2.ZERO, y: n2.ZERO };
    if (!n2.eql(I3, n2.ONE)) throw new Error("invZ was invalid");
    return { x: B3, y: E4 };
  }), L2 = ho(($3) => {
    if ($3.is0()) {
      if (e.allowInfinityPoint && !n2.is0($3.py)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: d3, y: m2 } = $3.toAffine();
    if (!n2.isValid(d3) || !n2.isValid(m2)) throw new Error("bad point: x or y not field elements");
    if (!g2(d3, m2)) throw new Error("bad point: equation left != right");
    if (!$3.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function V5($3, d3, m2, p2, b3) {
    return m2 = new _2(n2.mul(m2.px, $3), m2.py, m2.pz), d3 = le(p2, d3), m2 = le(b3, m2), d3.add(m2);
  }
  class _2 {
    constructor(d3, m2, p2) {
      this.px = x4("x", d3), this.py = x4("y", m2, true), this.pz = x4("z", p2), Object.freeze(this);
    }
    static fromAffine(d3) {
      const { x: m2, y: p2 } = d3 || {};
      if (!d3 || !n2.isValid(m2) || !n2.isValid(p2)) throw new Error("invalid affine point");
      if (d3 instanceof _2) throw new Error("projective point not allowed");
      return n2.is0(m2) && n2.is0(p2) ? _2.ZERO : new _2(m2, p2, n2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(d3) {
      return lc(_2, "pz", d3);
    }
    static fromBytes(d3) {
      return at(d3), _2.fromHex(d3);
    }
    static fromHex(d3) {
      const m2 = _2.fromAffine(u3(rt("pointHex", d3)));
      return m2.assertValidity(), m2;
    }
    static fromPrivateKey(d3) {
      const m2 = To(r2, e.allowedPrivateKeyLengths, e.wrapPrivateKey);
      return _2.BASE.multiply(m2(d3));
    }
    static msm(d3, m2) {
      return bc(_2, r2, d3, m2);
    }
    precompute(d3 = 8, m2 = true) {
      return j3.setWindowSize(this, d3), m2 || this.multiply(He), this;
    }
    _setWindowSize(d3) {
      this.precompute(d3);
    }
    assertValidity() {
      L2(this);
    }
    hasEvenY() {
      const { y: d3 } = this.toAffine();
      if (!n2.isOdd) throw new Error("Field doesn't support isOdd");
      return !n2.isOdd(d3);
    }
    equals(d3) {
      R4(d3);
      const { px: m2, py: p2, pz: b3 } = this, { px: v3, py: B3, pz: E4 } = d3, I3 = n2.eql(n2.mul(m2, E4), n2.mul(v3, b3)), S3 = n2.eql(n2.mul(p2, E4), n2.mul(B3, b3));
      return I3 && S3;
    }
    negate() {
      return new _2(this.px, n2.neg(this.py), this.pz);
    }
    double() {
      const { a: d3, b: m2 } = t, p2 = n2.mul(m2, He), { px: b3, py: v3, pz: B3 } = this;
      let E4 = n2.ZERO, I3 = n2.ZERO, S3 = n2.ZERO, O5 = n2.mul(b3, b3), A4 = n2.mul(v3, v3), T3 = n2.mul(B3, B3), U4 = n2.mul(b3, v3);
      return U4 = n2.add(U4, U4), S3 = n2.mul(b3, B3), S3 = n2.add(S3, S3), E4 = n2.mul(d3, S3), I3 = n2.mul(p2, T3), I3 = n2.add(E4, I3), E4 = n2.sub(A4, I3), I3 = n2.add(A4, I3), I3 = n2.mul(E4, I3), E4 = n2.mul(U4, E4), S3 = n2.mul(p2, S3), T3 = n2.mul(d3, T3), U4 = n2.sub(O5, T3), U4 = n2.mul(d3, U4), U4 = n2.add(U4, S3), S3 = n2.add(O5, O5), O5 = n2.add(S3, O5), O5 = n2.add(O5, T3), O5 = n2.mul(O5, U4), I3 = n2.add(I3, O5), T3 = n2.mul(v3, B3), T3 = n2.add(T3, T3), O5 = n2.mul(T3, U4), E4 = n2.sub(E4, O5), S3 = n2.mul(T3, A4), S3 = n2.add(S3, S3), S3 = n2.add(S3, S3), new _2(E4, I3, S3);
    }
    add(d3) {
      R4(d3);
      const { px: m2, py: p2, pz: b3 } = this, { px: v3, py: B3, pz: E4 } = d3;
      let I3 = n2.ZERO, S3 = n2.ZERO, O5 = n2.ZERO;
      const A4 = t.a, T3 = n2.mul(t.b, He);
      let U4 = n2.mul(m2, v3), C4 = n2.mul(p2, B3), H2 = n2.mul(b3, E4), q3 = n2.add(m2, p2), P4 = n2.add(v3, B3);
      q3 = n2.mul(q3, P4), P4 = n2.add(U4, C4), q3 = n2.sub(q3, P4), P4 = n2.add(m2, b3);
      let K5 = n2.add(v3, E4);
      return P4 = n2.mul(P4, K5), K5 = n2.add(U4, H2), P4 = n2.sub(P4, K5), K5 = n2.add(p2, b3), I3 = n2.add(B3, E4), K5 = n2.mul(K5, I3), I3 = n2.add(C4, H2), K5 = n2.sub(K5, I3), O5 = n2.mul(A4, P4), I3 = n2.mul(T3, H2), O5 = n2.add(I3, O5), I3 = n2.sub(C4, O5), O5 = n2.add(C4, O5), S3 = n2.mul(I3, O5), C4 = n2.add(U4, U4), C4 = n2.add(C4, U4), H2 = n2.mul(A4, H2), P4 = n2.mul(T3, P4), C4 = n2.add(C4, H2), H2 = n2.sub(U4, H2), H2 = n2.mul(A4, H2), P4 = n2.add(P4, H2), U4 = n2.mul(C4, P4), S3 = n2.add(S3, U4), U4 = n2.mul(K5, P4), I3 = n2.mul(q3, I3), I3 = n2.sub(I3, U4), U4 = n2.mul(q3, C4), O5 = n2.mul(K5, O5), O5 = n2.add(O5, U4), new _2(I3, S3, O5);
    }
    subtract(d3) {
      return this.add(d3.negate());
    }
    is0() {
      return this.equals(_2.ZERO);
    }
    multiply(d3) {
      const { endo: m2 } = e;
      if (!r2.isValidNot0(d3)) throw new Error("invalid scalar: out of range");
      let p2, b3;
      const v3 = (B3) => j3.wNAFCached(this, B3, _2.normalizeZ);
      if (m2) {
        const { k1neg: B3, k1: E4, k2neg: I3, k2: S3 } = m2.splitScalar(d3), { p: O5, f: A4 } = v3(E4), { p: T3, f: U4 } = v3(S3);
        b3 = A4.add(U4), p2 = V5(m2.beta, O5, T3, B3, I3);
      } else {
        const { p: B3, f: E4 } = v3(d3);
        p2 = B3, b3 = E4;
      }
      return _2.normalizeZ([p2, b3])[0];
    }
    multiplyUnsafe(d3) {
      const { endo: m2 } = e, p2 = this;
      if (!r2.isValid(d3)) throw new Error("invalid scalar: out of range");
      if (d3 === he || p2.is0()) return _2.ZERO;
      if (d3 === pe) return p2;
      if (j3.hasPrecomputes(this)) return this.multiply(d3);
      if (m2) {
        const { k1neg: b3, k1: v3, k2neg: B3, k2: E4 } = m2.splitScalar(d3), { p1: I3, p2: S3 } = gc(_2, p2, v3, E4);
        return V5(m2.beta, I3, S3, b3, B3);
      } else return j3.wNAFCachedUnsafe(p2, d3);
    }
    multiplyAndAddUnsafe(d3, m2, p2) {
      const b3 = this.multiplyUnsafe(m2).add(d3.multiplyUnsafe(p2));
      return b3.is0() ? void 0 : b3;
    }
    toAffine(d3) {
      return M5(this, d3);
    }
    isTorsionFree() {
      const { isTorsionFree: d3 } = e;
      return o2 === pe ? true : d3 ? d3(_2, this) : j3.wNAFCachedUnsafe(this, s).is0();
    }
    clearCofactor() {
      const { clearCofactor: d3 } = e;
      return o2 === pe ? this : d3 ? d3(_2, this) : this.multiplyUnsafe(o2);
    }
    toBytes(d3 = true) {
      return Re("isCompressed", d3), this.assertValidity(), c4(_2, this, d3);
    }
    toRawBytes(d3 = true) {
      return this.toBytes(d3);
    }
    toHex(d3 = true) {
      return ce(this.toBytes(d3));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  _2.BASE = new _2(t.Gx, t.Gy, n2.ONE), _2.ZERO = new _2(n2.ZERO, n2.ONE, n2.ZERO), _2.Fp = n2, _2.Fn = r2;
  const k4 = r2.BITS, j3 = pc(_2, e.endo ? Math.ceil(k4 / 2) : k4);
  return _2;
}
function Ro(t) {
  return Uint8Array.of(t ? 2 : 3);
}
function Tc(t, e, n2 = {}) {
  ke(e, { hash: "function" }, { hmac: "function", lowS: "boolean", randomBytes: "function", bits2int: "function", bits2int_modN: "function" });
  const r2 = e.randomBytes || Zt, o2 = e.hmac || ((p2, ...b3) => _e(e.hash, p2, Ht(...b3))), { Fp: s, Fn: i3 } = t, { ORDER: f7, BITS: a2 } = i3;
  function l4(p2) {
    const b3 = f7 >> pe;
    return p2 > b3;
  }
  function c4(p2) {
    return l4(p2) ? i3.neg(p2) : p2;
  }
  function u3(p2, b3) {
    if (!i3.isValidNot0(b3)) throw new Error(`invalid signature ${p2}: out of range 1..CURVE.n`);
  }
  class h4 {
    constructor(b3, v3, B3) {
      u3("r", b3), u3("s", v3), this.r = b3, this.s = v3, B3 != null && (this.recovery = B3), Object.freeze(this);
    }
    static fromCompact(b3) {
      const v3 = i3.BYTES, B3 = rt("compactSignature", b3, v3 * 2);
      return new h4(i3.fromBytes(B3.subarray(0, v3)), i3.fromBytes(B3.subarray(v3, v3 * 2)));
    }
    static fromDER(b3) {
      const { r: v3, s: B3 } = vt.toSig(rt("DER", b3));
      return new h4(v3, B3);
    }
    assertValidity() {
    }
    addRecoveryBit(b3) {
      return new h4(this.r, this.s, b3);
    }
    recoverPublicKey(b3) {
      const v3 = s.ORDER, { r: B3, s: E4, recovery: I3 } = this;
      if (I3 == null || ![0, 1, 2, 3].includes(I3)) throw new Error("recovery id invalid");
      if (f7 * Nc < v3 && I3 > 1) throw new Error("recovery id is ambiguous for h>1 curve");
      const O5 = I3 === 2 || I3 === 3 ? B3 + f7 : B3;
      if (!s.isValid(O5)) throw new Error("recovery id 2 or 3 invalid");
      const A4 = s.toBytes(O5), T3 = t.fromHex(Ht(Ro((I3 & 1) === 0), A4)), U4 = i3.inv(O5), C4 = L2(rt("msgHash", b3)), H2 = i3.create(-C4 * U4), q3 = i3.create(E4 * U4), P4 = t.BASE.multiplyUnsafe(H2).add(T3.multiplyUnsafe(q3));
      if (P4.is0()) throw new Error("point at infinify");
      return P4.assertValidity(), P4;
    }
    hasHighS() {
      return l4(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new h4(this.r, i3.neg(this.s), this.recovery) : this;
    }
    toBytes(b3) {
      if (b3 === "compact") return Ht(i3.toBytes(this.r), i3.toBytes(this.s));
      if (b3 === "der") return fn(vt.hexFromSig(this));
      throw new Error("invalid format");
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return ce(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return ce(this.toBytes("compact"));
    }
  }
  const g2 = To(i3, n2.allowedPrivateKeyLengths, n2.wrapPrivateKey), w = { isValidPrivateKey(p2) {
    try {
      return g2(p2), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: g2, randomPrivateKey: () => {
    const p2 = f7;
    return uc(r2(Eo(p2)), p2);
  }, precompute(p2 = 8, b3 = t.BASE) {
    return b3.precompute(p2, false);
  } };
  function y5(p2, b3 = true) {
    return t.fromPrivateKey(p2).toBytes(b3);
  }
  function x4(p2) {
    if (typeof p2 == "bigint") return false;
    if (p2 instanceof t) return true;
    const v3 = rt("key", p2).length, B3 = s.BYTES, E4 = B3 + 1, I3 = 2 * B3 + 1;
    if (!(n2.allowedPrivateKeyLengths || i3.BYTES === E4)) return v3 === E4 || v3 === I3;
  }
  function R4(p2, b3, v3 = true) {
    if (x4(p2) === true) throw new Error("first arg must be private key");
    if (x4(b3) === false) throw new Error("second arg must be public key");
    return t.fromHex(b3).multiply(g2(p2)).toBytes(v3);
  }
  const M5 = e.bits2int || function(p2) {
    if (p2.length > 8192) throw new Error("input is too large");
    const b3 = Ce(p2), v3 = p2.length * 8 - a2;
    return v3 > 0 ? b3 >> BigInt(v3) : b3;
  }, L2 = e.bits2int_modN || function(p2) {
    return i3.create(M5(p2));
  }, V5 = je(a2);
  function _2(p2) {
    return Nn("num < 2^" + a2, p2, he, V5), i3.toBytes(p2);
  }
  function k4(p2, b3, v3 = j3) {
    if (["recovered", "canonical"].some((q3) => q3 in v3)) throw new Error("sign() legacy options not supported");
    const { hash: B3 } = e;
    let { lowS: E4, prehash: I3, extraEntropy: S3 } = v3;
    E4 == null && (E4 = true), p2 = rt("msgHash", p2), _o(v3), I3 && (p2 = rt("prehashed msgHash", B3(p2)));
    const O5 = L2(p2), A4 = g2(b3), T3 = [_2(A4), _2(O5)];
    if (S3 != null && S3 !== false) {
      const q3 = S3 === true ? r2(s.BYTES) : S3;
      T3.push(rt("extraEntropy", q3));
    }
    const U4 = Ht(...T3), C4 = O5;
    function H2(q3) {
      const P4 = M5(q3);
      if (!i3.isValidNot0(P4)) return;
      const K5 = i3.inv(P4), et2 = t.BASE.multiply(P4).toAffine(), Z2 = i3.create(et2.x);
      if (Z2 === he) return;
      const z3 = i3.create(K5 * i3.create(C4 + Z2 * A4));
      if (z3 === he) return;
      let Ft2 = (et2.x === Z2 ? 0 : 2) | Number(et2.y & pe), yt3 = z3;
      return E4 && l4(z3) && (yt3 = c4(z3), Ft2 ^= 1), new h4(Z2, yt3, Ft2);
    }
    return { seed: U4, k2sig: H2 };
  }
  const j3 = { lowS: e.lowS, prehash: false }, $3 = { lowS: e.lowS, prehash: false };
  function d3(p2, b3, v3 = j3) {
    const { seed: B3, k2sig: E4 } = k4(p2, b3, v3);
    return ec(e.hash.outputLen, i3.BYTES, o2)(B3, E4);
  }
  t.BASE.precompute(8);
  function m2(p2, b3, v3, B3 = $3) {
    const E4 = p2;
    b3 = rt("msgHash", b3), v3 = rt("publicKey", v3), _o(B3);
    const { lowS: I3, prehash: S3, format: O5 } = B3;
    if ("strict" in B3) throw new Error("options.strict was renamed to lowS");
    if (O5 !== void 0 && !["compact", "der", "js"].includes(O5)) throw new Error('format must be "compact", "der" or "js"');
    const A4 = typeof E4 == "string" || nn(E4), T3 = !A4 && !O5 && typeof E4 == "object" && E4 !== null && typeof E4.r == "bigint" && typeof E4.s == "bigint";
    if (!A4 && !T3) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let U4, C4;
    try {
      if (T3) if (O5 === void 0 || O5 === "js") U4 = new h4(E4.r, E4.s);
      else throw new Error("invalid format");
      if (A4) {
        try {
          O5 !== "compact" && (U4 = h4.fromDER(E4));
        } catch (yt3) {
          if (!(yt3 instanceof vt.Err)) throw yt3;
        }
        !U4 && O5 !== "der" && (U4 = h4.fromCompact(E4));
      }
      C4 = t.fromHex(v3);
    } catch {
      return false;
    }
    if (!U4 || I3 && U4.hasHighS()) return false;
    S3 && (b3 = e.hash(b3));
    const { r: H2, s: q3 } = U4, P4 = L2(b3), K5 = i3.inv(q3), et2 = i3.create(P4 * K5), Z2 = i3.create(H2 * K5), z3 = t.BASE.multiplyUnsafe(et2).add(C4.multiplyUnsafe(Z2));
    return z3.is0() ? false : i3.create(z3.x) === H2;
  }
  return Object.freeze({ getPublicKey: y5, getSharedSecret: R4, sign: d3, verify: m2, utils: w, Point: t, Signature: h4 });
}
function Rc(t) {
  const e = { a: t.a, b: t.b, p: t.Fp.ORDER, n: t.n, h: t.h, Gx: t.Gx, Gy: t.Gy }, n2 = t.Fp, r2 = Yt(e.n, t.nBitLength), o2 = { Fp: n2, Fn: r2, allowedPrivateKeyLengths: t.allowedPrivateKeyLengths, allowInfinityPoint: t.allowInfinityPoint, endo: t.endo, wrapPrivateKey: t.wrapPrivateKey, isTorsionFree: t.isTorsionFree, clearCofactor: t.clearCofactor, fromBytes: t.fromBytes, toBytes: t.toBytes };
  return { CURVE: e, curveOpts: o2 };
}
function $c(t) {
  const { CURVE: e, curveOpts: n2 } = Rc(t), r2 = { hash: t.hash, hmac: t.hmac, randomBytes: t.randomBytes, lowS: t.lowS, bits2int: t.bits2int, bits2int_modN: t.bits2int_modN };
  return { CURVE: e, curveOpts: n2, ecdsaOpts: r2 };
}
function Cc(t, e) {
  return Object.assign({}, e, { ProjectivePoint: e.Point, CURVE: t });
}
function Lc(t) {
  const { CURVE: e, curveOpts: n2, ecdsaOpts: r2 } = $c(t), o2 = _c(e, n2), s = Tc(o2, r2, n2);
  return Cc(t, s);
}
function Rn(t, e) {
  const n2 = (r2) => Lc({ ...t, hash: r2 });
  return { ...n2(e), create: n2 };
}
var $o = { p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"), n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), h: BigInt(1), a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"), b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5") };
var Co = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"), n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"), h: BigInt(1), a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"), b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"), Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"), Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f") };
var Lo = { p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"), h: BigInt(1), a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"), b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"), Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"), Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650") };
var jc = Yt($o.p);
var kc = Yt(Co.p);
var Pc = Yt(Lo.p);
var Hc = Rn({ ...$o, Fp: jc, lowS: false }, Ae);
Rn({ ...Co, Fp: kc, lowS: false }, Yi), Rn({ ...Lo, Fp: Pc, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, Wi);
var Dc = Hc;
var $n = "base10";
var tt = "base16";
var Qt = "base64pad";
var De = "base64url";
var te = "utf8";
var Cn = 0;
var ee = 1;
var ge = 2;
var Mc = 0;
var jo = 1;
var be = 12;
var Ln = 32;
function Vc() {
  const t = Tn.utils.randomPrivateKey(), e = Tn.getPublicKey(t);
  return { privateKey: toString2(t, tt), publicKey: toString2(e, tt) };
}
function qc() {
  const t = Zt(Ln);
  return toString2(t, tt);
}
function Kc(t, e) {
  const n2 = Tn.getSharedSecret(fromString3(t, tt), fromString3(e, tt)), r2 = Jf(Te, n2, void 0, void 0, Ln);
  return toString2(r2, tt);
}
function Fc(t) {
  const e = Te(fromString3(t, tt));
  return toString2(e, tt);
}
function zc(t) {
  const e = Te(fromString3(t, te));
  return toString2(e, tt);
}
function jn(t) {
  return fromString3(`${t}`, $n);
}
function Vt(t) {
  return Number(toString2(t, $n));
}
function ko(t) {
  return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function Po2(t) {
  const e = t.replace(/-/g, "+").replace(/_/g, "/"), n2 = (4 - e.length % 4) % 4;
  return e + "=".repeat(n2);
}
function Gc(t) {
  const e = jn(typeof t.type < "u" ? t.type : Cn);
  if (Vt(e) === ee && typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n2 = typeof t.senderPublicKey < "u" ? fromString3(t.senderPublicKey, tt) : void 0, r2 = typeof t.iv < "u" ? fromString3(t.iv, tt) : Zt(be), o2 = fromString3(t.symKey, tt), s = co(o2, r2).encrypt(fromString3(t.message, te)), i3 = kn({ type: e, sealed: s, iv: r2, senderPublicKey: n2 });
  return t.encoding === De ? ko(i3) : i3;
}
function Zc(t) {
  const e = fromString3(t.symKey, tt), { sealed: n2, iv: r2 } = Me({ encoded: t.encoded, encoding: t.encoding }), o2 = co(e, r2).decrypt(n2);
  if (o2 === null) throw new Error("Failed to decrypt");
  return toString2(o2, te);
}
function Wc(t, e) {
  const n2 = jn(ge), r2 = Zt(be), o2 = fromString3(t, te), s = kn({ type: n2, sealed: o2, iv: r2 });
  return e === De ? ko(s) : s;
}
function Yc(t, e) {
  const { sealed: n2 } = Me({ encoded: t, encoding: e });
  return toString2(n2, te);
}
function kn(t) {
  if (Vt(t.type) === ge) return toString2(concat3([t.type, t.sealed]), Qt);
  if (Vt(t.type) === ee) {
    if (typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString2(concat3([t.type, t.senderPublicKey, t.iv, t.sealed]), Qt);
  }
  return toString2(concat3([t.type, t.iv, t.sealed]), Qt);
}
function Me(t) {
  const e = (t.encoding || Qt) === De ? Po2(t.encoded) : t.encoded, n2 = fromString3(e, Qt), r2 = n2.slice(Mc, jo), o2 = jo;
  if (Vt(r2) === ee) {
    const a2 = o2 + Ln, l4 = a2 + be, c4 = n2.slice(o2, a2), u3 = n2.slice(a2, l4), h4 = n2.slice(l4);
    return { type: r2, sealed: h4, iv: u3, senderPublicKey: c4 };
  }
  if (Vt(r2) === ge) {
    const a2 = n2.slice(o2), l4 = Zt(be);
    return { type: r2, sealed: a2, iv: l4 };
  }
  const s = o2 + be, i3 = n2.slice(o2, s), f7 = n2.slice(s);
  return { type: r2, sealed: f7, iv: i3 };
}
function Xc(t, e) {
  const n2 = Me({ encoded: t, encoding: e == null ? void 0 : e.encoding });
  return Ho({ type: Vt(n2.type), senderPublicKey: typeof n2.senderPublicKey < "u" ? toString2(n2.senderPublicKey, tt) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function Ho(t) {
  const e = (t == null ? void 0 : t.type) || Cn;
  if (e === ee) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: t == null ? void 0 : t.senderPublicKey, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey };
}
function Jc(t) {
  return t.type === ee && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
function Qc(t) {
  return t.type === ge;
}
function Do(t) {
  const e = Buffer.from(t.x, "base64"), n2 = Buffer.from(t.y, "base64");
  return concat3([new Uint8Array([4]), e, n2]);
}
function ta(t, e) {
  const [n2, r2, o2] = t.split("."), s = Buffer.from(Po2(o2), "base64");
  if (s.length !== 64) throw new Error("Invalid signature length");
  const i3 = s.slice(0, 32), f7 = s.slice(32, 64), a2 = `${n2}.${r2}`, l4 = Te(a2), c4 = Do(e);
  if (!Dc.verify(concat3([i3, f7]), l4, c4)) throw new Error("Invalid signature");
  return sn(t).payload;
}
var Mo = "irn";
function ea(t) {
  return (t == null ? void 0 : t.relay) || { protocol: Mo };
}
function na(t) {
  const e = C[t];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
function Vo(t, e = "-") {
  const n2 = {}, r2 = "relay" + e;
  return Object.keys(t).forEach((o2) => {
    if (o2.startsWith(r2)) {
      const s = o2.replace(r2, ""), i3 = t[o2];
      n2[s] = i3;
    }
  }), n2;
}
function ra(t) {
  if (!t.includes("wc:")) {
    const l4 = Qe2(t);
    l4 != null && l4.includes("wc:") && (t = l4);
  }
  t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
  const e = t.indexOf(":"), n2 = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, r2 = t.substring(0, e), o2 = t.substring(e + 1, n2).split("@"), s = typeof n2 < "u" ? t.substring(n2) : "", i3 = new URLSearchParams(s), f7 = {};
  i3.forEach((l4, c4) => {
    f7[c4] = l4;
  });
  const a2 = typeof f7.methods == "string" ? f7.methods.split(",") : void 0;
  return { protocol: r2, topic: qo(o2[0]), version: parseInt(o2[1], 10), symKey: f7.symKey, relay: Vo(f7), methods: a2, expiryTimestamp: f7.expiryTimestamp ? parseInt(f7.expiryTimestamp, 10) : void 0 };
}
function qo(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function Ko(t, e = "-") {
  const n2 = "relay", r2 = {};
  return Object.keys(t).forEach((o2) => {
    const s = o2, i3 = n2 + e + s;
    t[s] && (r2[i3] = t[s]);
  }), r2;
}
function oa(t) {
  const e = new URLSearchParams(), n2 = Ko(t.relay);
  Object.keys(n2).sort().forEach((o2) => {
    e.set(o2, n2[o2]);
  }), e.set("symKey", t.symKey), t.expiryTimestamp && e.set("expiryTimestamp", t.expiryTimestamp.toString()), t.methods && e.set("methods", t.methods.join(","));
  const r2 = e.toString();
  return `${t.protocol}:${t.topic}@${t.version}?${r2}`;
}
function sa(t, e, n2) {
  return `${t}?wc_ev=${n2}&topic=${e}`;
}
var ia = Object.defineProperty;
var fa = Object.defineProperties;
var ca = Object.getOwnPropertyDescriptors;
var Fo = Object.getOwnPropertySymbols;
var aa = Object.prototype.hasOwnProperty;
var ua = Object.prototype.propertyIsEnumerable;
var zo = (t, e, n2) => e in t ? ia(t, e, { enumerable: true, configurable: true, writable: true, value: n2 }) : t[e] = n2;
var la = (t, e) => {
  for (var n2 in e || (e = {})) aa.call(e, n2) && zo(t, n2, e[n2]);
  if (Fo) for (var n2 of Fo(e)) ua.call(e, n2) && zo(t, n2, e[n2]);
  return t;
};
var da = (t, e) => fa(t, ca(e));
function qt(t) {
  const e = [];
  return t.forEach((n2) => {
    const [r2, o2] = n2.split(":");
    e.push(`${r2}:${o2}`);
  }), e;
}
function Go(t) {
  const e = [];
  return Object.values(t).forEach((n2) => {
    e.push(...qt(n2.accounts));
  }), e;
}
function Zo(t, e) {
  const n2 = [];
  return Object.values(t).forEach((r2) => {
    qt(r2.accounts).includes(e) && n2.push(...r2.methods);
  }), n2;
}
function Wo(t, e) {
  const n2 = [];
  return Object.values(t).forEach((r2) => {
    qt(r2.accounts).includes(e) && n2.push(...r2.events);
  }), n2;
}
function Pn(t) {
  return t.includes(":");
}
function Yo(t) {
  return Pn(t) ? t.split(":")[0] : t;
}
function ye(t) {
  var e, n2, r2;
  const o2 = {};
  if (!Ve(t)) return o2;
  for (const [s, i3] of Object.entries(t)) {
    const f7 = Pn(s) ? [s] : i3.chains, a2 = i3.methods || [], l4 = i3.events || [], c4 = Yo(s);
    o2[c4] = da(la({}, o2[c4]), { chains: ct(f7, (e = o2[c4]) == null ? void 0 : e.chains), methods: ct(a2, (n2 = o2[c4]) == null ? void 0 : n2.methods), events: ct(l4, (r2 = o2[c4]) == null ? void 0 : r2.events) });
  }
  return o2;
}
function Xo(t) {
  const e = {};
  return t == null ? void 0 : t.forEach((n2) => {
    var r2;
    const [o2, s] = n2.split(":");
    e[o2] || (e[o2] = { accounts: [], chains: [], events: [], methods: [] }), e[o2].accounts.push(n2), (r2 = e[o2].chains) == null || r2.push(`${o2}:${s}`);
  }), e;
}
function ga(t, e) {
  e = e.map((r2) => r2.replace("did:pkh:", ""));
  const n2 = Xo(e);
  for (const [r2, o2] of Object.entries(n2)) o2.methods ? o2.methods = ct(o2.methods, t) : o2.methods = t, o2.events = ["chainChanged", "accountsChanged"];
  return n2;
}
function ba(t, e) {
  var n2, r2, o2, s, i3, f7;
  const a2 = ye(t), l4 = ye(e), c4 = {}, u3 = Object.keys(a2).concat(Object.keys(l4));
  for (const h4 of u3) c4[h4] = { chains: ct((n2 = a2[h4]) == null ? void 0 : n2.chains, (r2 = l4[h4]) == null ? void 0 : r2.chains), methods: ct((o2 = a2[h4]) == null ? void 0 : o2.methods, (s = l4[h4]) == null ? void 0 : s.methods), events: ct((i3 = a2[h4]) == null ? void 0 : i3.events, (f7 = l4[h4]) == null ? void 0 : f7.events) };
  return c4;
}
var Jo = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Qo2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function Et(t, e) {
  const { message: n2, code: r2 } = Qo2[t];
  return { message: e ? `${n2} ${e}` : n2, code: r2 };
}
function Kt(t, e) {
  const { message: n2, code: r2 } = Jo[t];
  return { message: e ? `${n2} ${e}` : n2, code: r2 };
}
function me(t, e) {
  return Array.isArray(t) ? typeof e < "u" && t.length ? t.every(e) : true : false;
}
function Ve(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function kt(t) {
  return typeof t > "u";
}
function it(t, e) {
  return e && kt(t) ? true : typeof t == "string" && !!t.trim().length;
}
function qe(t, e) {
  return e && kt(t) ? true : typeof t == "number" && !isNaN(t);
}
function ya(t, e) {
  const { requiredNamespaces: n2 } = e, r2 = Object.keys(t.namespaces), o2 = Object.keys(n2);
  let s = true;
  return It(o2, r2) ? (r2.forEach((i3) => {
    const { accounts: f7, methods: a2, events: l4 } = t.namespaces[i3], c4 = qt(f7), u3 = n2[i3];
    (!It(ve(i3, u3), c4) || !It(u3.methods, a2) || !It(u3.events, l4)) && (s = false);
  }), s) : false;
}
function we(t) {
  return it(t, false) && t.includes(":") ? t.split(":").length === 2 : false;
}
function ts(t) {
  if (it(t, false) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const n2 = e[0] + ":" + e[1];
      return !!e[2] && we(n2);
    }
  }
  return false;
}
function ma(t) {
  function e(n2) {
    try {
      return typeof new URL(n2) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (it(t, false)) {
      if (e(t)) return true;
      const n2 = Qe2(t);
      return e(n2);
    }
  } catch {
  }
  return false;
}
function wa(t) {
  var e;
  return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey;
}
function xa(t) {
  return t == null ? void 0 : t.topic;
}
function va(t, e) {
  let n2 = null;
  return it(t == null ? void 0 : t.publicKey, false) || (n2 = Et("MISSING_OR_INVALID", `${e} controller public key should be a string`)), n2;
}
function Hn(t) {
  let e = true;
  return me(t) ? t.length && (e = t.every((n2) => it(n2, false))) : e = false, e;
}
function es(t, e, n2) {
  let r2 = null;
  return me(e) && e.length ? e.forEach((o2) => {
    r2 || we(o2) || (r2 = Kt("UNSUPPORTED_CHAINS", `${n2}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : we(t) || (r2 = Kt("UNSUPPORTED_CHAINS", `${n2}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r2;
}
function ns(t, e, n2) {
  let r2 = null;
  return Object.entries(t).forEach(([o2, s]) => {
    if (r2) return;
    const i3 = es(o2, ve(o2, s), `${e} ${n2}`);
    i3 && (r2 = i3);
  }), r2;
}
function rs(t, e) {
  let n2 = null;
  return me(t) ? t.forEach((r2) => {
    n2 || ts(r2) || (n2 = Kt("UNSUPPORTED_ACCOUNTS", `${e}, account ${r2} should be a string and conform to "namespace:chainId:address" format`));
  }) : n2 = Kt("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n2;
}
function os(t, e) {
  let n2 = null;
  return Object.values(t).forEach((r2) => {
    if (n2) return;
    const o2 = rs(r2 == null ? void 0 : r2.accounts, `${e} namespace`);
    o2 && (n2 = o2);
  }), n2;
}
function ss(t, e) {
  let n2 = null;
  return Hn(t == null ? void 0 : t.methods) ? Hn(t == null ? void 0 : t.events) || (n2 = Kt("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : n2 = Kt("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), n2;
}
function Dn(t, e) {
  let n2 = null;
  return Object.values(t).forEach((r2) => {
    if (n2) return;
    const o2 = ss(r2, `${e}, namespace`);
    o2 && (n2 = o2);
  }), n2;
}
function Ea(t, e, n2) {
  let r2 = null;
  if (t && Ve(t)) {
    const o2 = Dn(t, e);
    o2 && (r2 = o2);
    const s = ns(t, e, n2);
    s && (r2 = s);
  } else r2 = Et("MISSING_OR_INVALID", `${e}, ${n2} should be an object with data`);
  return r2;
}
function is(t, e) {
  let n2 = null;
  if (t && Ve(t)) {
    const r2 = Dn(t, e);
    r2 && (n2 = r2);
    const o2 = os(t, e);
    o2 && (n2 = o2);
  } else n2 = Et("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return n2;
}
function fs(t) {
  return it(t.protocol, true);
}
function Ba(t, e) {
  let n2 = false;
  return e && !t ? n2 = true : t && me(t) && t.length && t.forEach((r2) => {
    n2 = fs(r2);
  }), n2;
}
function Ia(t) {
  return typeof t == "number";
}
function Aa(t) {
  return typeof t < "u" && typeof t !== null;
}
function Sa(t) {
  return !(!t || typeof t != "object" || !t.code || !qe(t.code, false) || !t.message || !it(t.message, false));
}
function Na(t) {
  return !(kt(t) || !it(t.method, false));
}
function Oa(t) {
  return !(kt(t) || kt(t.result) && kt(t.error) || !qe(t.id, false) || !it(t.jsonrpc, false));
}
function Ua(t) {
  return !(kt(t) || !it(t.name, false));
}
function _a(t, e) {
  return !(!we(e) || !Go(t).includes(e));
}
function Ta(t, e, n2) {
  return it(n2, false) ? Zo(t, e).includes(n2) : false;
}
function Ra(t, e, n2) {
  return it(n2, false) ? Wo(t, e).includes(n2) : false;
}
function cs(t, e, n2) {
  let r2 = null;
  const o2 = $a(t), s = Ca(e), i3 = Object.keys(o2), f7 = Object.keys(s), a2 = as(Object.keys(t)), l4 = as(Object.keys(e)), c4 = a2.filter((u3) => !l4.includes(u3));
  return c4.length && (r2 = Et("NON_CONFORMING_NAMESPACES", `${n2} namespaces keys don't satisfy requiredNamespaces.
      Required: ${c4.toString()}
      Received: ${Object.keys(e).toString()}`)), It(i3, f7) || (r2 = Et("NON_CONFORMING_NAMESPACES", `${n2} namespaces chains don't satisfy required namespaces.
      Required: ${i3.toString()}
      Approved: ${f7.toString()}`)), Object.keys(e).forEach((u3) => {
    if (!u3.includes(":") || r2) return;
    const h4 = qt(e[u3].accounts);
    h4.includes(u3) || (r2 = Et("NON_CONFORMING_NAMESPACES", `${n2} namespaces accounts don't satisfy namespace accounts for ${u3}
        Required: ${u3}
        Approved: ${h4.toString()}`));
  }), i3.forEach((u3) => {
    r2 || (It(o2[u3].methods, s[u3].methods) ? It(o2[u3].events, s[u3].events) || (r2 = Et("NON_CONFORMING_NAMESPACES", `${n2} namespaces events don't satisfy namespace events for ${u3}`)) : r2 = Et("NON_CONFORMING_NAMESPACES", `${n2} namespaces methods don't satisfy namespace methods for ${u3}`));
  }), r2;
}
function $a(t) {
  const e = {};
  return Object.keys(t).forEach((n2) => {
    var r2;
    n2.includes(":") ? e[n2] = t[n2] : (r2 = t[n2].chains) == null || r2.forEach((o2) => {
      e[o2] = { methods: t[n2].methods, events: t[n2].events };
    });
  }), e;
}
function as(t) {
  return [...new Set(t.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function Ca(t) {
  const e = {};
  return Object.keys(t).forEach((n2) => {
    if (n2.includes(":")) e[n2] = t[n2];
    else {
      const r2 = qt(t[n2].accounts);
      r2 == null ? void 0 : r2.forEach((o2) => {
        e[o2] = { accounts: t[n2].accounts.filter((s) => s.includes(`${o2}:`)), methods: t[n2].methods, events: t[n2].events };
      });
    }
  }), e;
}
function La(t, e) {
  return qe(t, false) && t <= e.max && t >= e.min;
}
function ja() {
  const t = Pt();
  return new Promise((e) => {
    switch (t) {
      case J2.browser:
        e(us());
        break;
      case J2.reactNative:
        e(ls());
        break;
      case J2.node:
        e(ds());
        break;
      default:
        e(true);
    }
  });
}
function us() {
  return zt() && (navigator == null ? void 0 : navigator.onLine);
}
async function ls() {
  if (Bt() && typeof global < "u" && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch());
    return t == null ? void 0 : t.isConnected;
  }
  return true;
}
function ds() {
  return true;
}
function ka(t) {
  switch (Pt()) {
    case J2.browser:
      hs(t);
      break;
    case J2.reactNative:
      ps(t);
      break;
    case J2.node:
      break;
  }
}
function hs(t) {
  !Bt() && zt() && (window.addEventListener("online", () => t(true)), window.addEventListener("offline", () => t(false)));
}
function ps(t) {
  Bt() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((e) => t(e == null ? void 0 : e.isConnected)));
}
function Pa() {
  var t;
  return zt() && (0, import_window_getters.getDocument)() ? ((t = (0, import_window_getters.getDocument)()) == null ? void 0 : t.visibilityState) === "visible" : true;
}
var Mn = {};
var Ha = class {
  static get(e) {
    return Mn[e];
  }
  static set(e, n2) {
    Mn[e] = n2;
  }
  static delete(e) {
    delete Mn[e];
  }
};
function gs(t) {
  const e = esm_default.decode(t);
  if (e.length < 33) throw new Error("Too short to contain a public key");
  return e.slice(1, 33);
}
function bs({ publicKey: t, signature: e, payload: n2 }) {
  var r2;
  const o2 = Vn(n2.method), s = 128 | parseInt(((r2 = n2.version) == null ? void 0 : r2.toString()) || "4"), i3 = Ma(n2.address), f7 = n2.era === "00" ? new Uint8Array([0]) : Vn(n2.era);
  if (f7.length !== 1 && f7.length !== 2) throw new Error("Invalid era length");
  const a2 = parseInt(n2.nonce, 16), l4 = new Uint8Array([a2 & 255, a2 >> 8 & 255]), c4 = BigInt(`0x${Da(n2.tip)}`), u3 = qa(c4), h4 = new Uint8Array([0, ...t, i3, ...e, ...f7, ...l4, ...u3, ...o2]), g2 = Va(h4.length + 1);
  return new Uint8Array([...g2, s, ...h4]);
}
function ys(t) {
  const e = Vn(t), n2 = (0, import_blakejs.blake2b)(e, void 0, 32);
  return "0x" + Buffer.from(n2).toString("hex");
}
function Vn(t) {
  return new Uint8Array(t.replace(/^0x/, "").match(/.{1,2}/g).map((e) => parseInt(e, 16)));
}
function Da(t) {
  return t.startsWith("0x") ? t.slice(2) : t;
}
function Ma(t) {
  const e = esm_default.decode(t)[0];
  return e === 42 ? 0 : e === 60 ? 2 : 1;
}
function Va(t) {
  if (t < 64) return new Uint8Array([t << 2]);
  if (t < 16384) {
    const e = t << 2 | 1;
    return new Uint8Array([e & 255, e >> 8 & 255]);
  } else if (t < 1 << 30) {
    const e = t << 2 | 2;
    return new Uint8Array([e & 255, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255]);
  } else throw new Error("Compact encoding > 2^30 not supported");
}
function qa(t) {
  if (t < BigInt(1) << BigInt(6)) return new Uint8Array([Number(t << BigInt(2))]);
  if (t < BigInt(1) << BigInt(14)) {
    const e = t << BigInt(2) | BigInt(1);
    return new Uint8Array([Number(e & BigInt(255)), Number(e >> BigInt(8) & BigInt(255))]);
  } else if (t < BigInt(1) << BigInt(30)) {
    const e = t << BigInt(2) | BigInt(2);
    return new Uint8Array([Number(e & BigInt(255)), Number(e >> BigInt(8) & BigInt(255)), Number(e >> BigInt(16) & BigInt(255)), Number(e >> BigInt(24) & BigInt(255))]);
  } else throw new Error("BigInt compact encoding not supported > 2^30");
}
function Ka(t) {
  const e = Uint8Array.from(Buffer.from(t.signature, "hex")), n2 = gs(t.transaction.address), r2 = bs({ publicKey: n2, signature: e, payload: t.transaction }), o2 = Buffer.from(r2).toString("hex");
  return ys(o2);
}

// node_modules/@reown/appkit/node_modules/@walletconnect/core/dist/index.es.js
var import_window_getters2 = __toESM(require_cjs2());
var Ue2 = "wc";
var Fe2 = 2;
var pe2 = "core";
var W2 = `${Ue2}@2:${pe2}:`;
var It2 = { name: pe2, logger: "error" };
var Tt2 = { database: ":memory:" };
var Ct2 = "crypto";
var Me2 = "client_ed25519_seed";
var Pt2 = import_time2.ONE_DAY;
var St2 = "keychain";
var Ot2 = "0.3";
var Rt2 = "messages";
var At2 = "0.3";
var xt2 = import_time2.SIX_HOURS;
var Nt2 = "publisher";
var $t2 = "irn";
var zt2 = "error";
var Ke2 = "wss://relay.walletconnect.org";
var Lt2 = "relayer";
var C2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var kt2 = "_subscription";
var M2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var jt2 = 0.1;
var Pe2 = "2.21.7";
var ee2 = { link_mode: "link_mode", relay: "relay" };
var ye2 = { inbound: "inbound", outbound: "outbound" };
var Ut2 = "0.3";
var Ft = "WALLETCONNECT_CLIENT_ID";
var Be2 = "WALLETCONNECT_LINK_MODE_APPS";
var U2 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var Mt2 = "subscription";
var Kt2 = "0.3";
var Qs = import_time2.FIVE_SECONDS * 1e3;
var Bt2 = "pairing";
var Vt2 = "0.3";
var oe = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var ae2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var V2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var qt2 = "history";
var Gt2 = "0.3";
var Wt2 = "expirer";
var q = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Ht2 = "0.3";
var Yt2 = "verify-api";
var ir2 = "https://verify.walletconnect.com";
var Jt2 = "https://verify.walletconnect.org";
var be2 = Jt2;
var Xt2 = `${be2}/v3`;
var Zt2 = [ir2, Jt2];
var Qt2 = "echo";
var ei2 = "https://echo.walletconnect.com";
var Y2 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var X2 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var rr2 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var nr = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var or2 = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var ar = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var ti = 0.1;
var ii2 = "event-client";
var si2 = 86400;
var ri2 = "https://pulse.walletconnect.org/batch";
function cr2(r2, e) {
  if (r2.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i3 = 0; i3 < t.length; i3++) t[i3] = 255;
  for (var s = 0; s < r2.length; s++) {
    var n2 = r2.charAt(s), o2 = n2.charCodeAt(0);
    if (t[o2] !== 255) throw new TypeError(n2 + " is ambiguous");
    t[o2] = s;
  }
  var a2 = r2.length, c4 = r2.charAt(0), h4 = Math.log(a2) / Math.log(256), l4 = Math.log(256) / Math.log(a2);
  function p2(u3) {
    if (u3 instanceof Uint8Array || (ArrayBuffer.isView(u3) ? u3 = new Uint8Array(u3.buffer, u3.byteOffset, u3.byteLength) : Array.isArray(u3) && (u3 = Uint8Array.from(u3))), !(u3 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u3.length === 0) return "";
    for (var m2 = 0, D4 = 0, _2 = 0, E4 = u3.length; _2 !== E4 && u3[_2] === 0; ) _2++, m2++;
    for (var L2 = (E4 - _2) * l4 + 1 >>> 0, I3 = new Uint8Array(L2); _2 !== E4; ) {
      for (var k4 = u3[_2], T3 = 0, S3 = L2 - 1; (k4 !== 0 || T3 < D4) && S3 !== -1; S3--, T3++) k4 += 256 * I3[S3] >>> 0, I3[S3] = k4 % a2 >>> 0, k4 = k4 / a2 >>> 0;
      if (k4 !== 0) throw new Error("Non-zero carry");
      D4 = T3, _2++;
    }
    for (var O5 = L2 - D4; O5 !== L2 && I3[O5] === 0; ) O5++;
    for (var te3 = c4.repeat(m2); O5 < L2; ++O5) te3 += r2.charAt(I3[O5]);
    return te3;
  }
  function y5(u3) {
    if (typeof u3 != "string") throw new TypeError("Expected String");
    if (u3.length === 0) return new Uint8Array();
    var m2 = 0;
    if (u3[m2] !== " ") {
      for (var D4 = 0, _2 = 0; u3[m2] === c4; ) D4++, m2++;
      for (var E4 = (u3.length - m2) * h4 + 1 >>> 0, L2 = new Uint8Array(E4); u3[m2]; ) {
        var I3 = t[u3.charCodeAt(m2)];
        if (I3 === 255) return;
        for (var k4 = 0, T3 = E4 - 1; (I3 !== 0 || k4 < _2) && T3 !== -1; T3--, k4++) I3 += a2 * L2[T3] >>> 0, L2[T3] = I3 % 256 >>> 0, I3 = I3 / 256 >>> 0;
        if (I3 !== 0) throw new Error("Non-zero carry");
        _2 = k4, m2++;
      }
      if (u3[m2] !== " ") {
        for (var S3 = E4 - _2; S3 !== E4 && L2[S3] === 0; ) S3++;
        for (var O5 = new Uint8Array(D4 + (E4 - S3)), te3 = D4; S3 !== E4; ) O5[te3++] = L2[S3++];
        return O5;
      }
    }
  }
  function w(u3) {
    var m2 = y5(u3);
    if (m2) return m2;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p2, decodeUnsafe: y5, decode: w };
}
var hr2 = cr2;
var lr = hr2;
var ni2 = (r2) => {
  if (r2 instanceof Uint8Array && r2.constructor.name === "Uint8Array") return r2;
  if (r2 instanceof ArrayBuffer) return new Uint8Array(r2);
  if (ArrayBuffer.isView(r2)) return new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ur = (r2) => new TextEncoder().encode(r2);
var dr2 = (r2) => new TextDecoder().decode(r2);
var gr2 = class {
  constructor(e, t, i3) {
    this.name = e, this.prefix = t, this.baseEncode = i3;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var pr2 = class {
  constructor(e, t, i3) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i3;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return oi2(this, e);
  }
};
var yr2 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return oi2(this, e);
  }
  decode(e) {
    const t = e[0], i3 = this.decoders[t];
    if (i3) return i3.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var oi2 = (r2, e) => new yr2({ ...r2.decoders || { [r2.prefix]: r2 }, ...e.decoders || { [e.prefix]: e } });
var br2 = class {
  constructor(e, t, i3, s) {
    this.name = e, this.prefix = t, this.baseEncode = i3, this.baseDecode = s, this.encoder = new gr2(e, t, i3), this.decoder = new pr2(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Se2 = ({ name: r2, prefix: e, encode: t, decode: i3 }) => new br2(r2, e, t, i3);
var me2 = ({ prefix: r2, name: e, alphabet: t }) => {
  const { encode: i3, decode: s } = lr(t, e);
  return Se2({ prefix: r2, name: e, encode: i3, decode: (n2) => ni2(s(n2)) });
};
var mr2 = (r2, e, t, i3) => {
  const s = {};
  for (let l4 = 0; l4 < e.length; ++l4) s[e[l4]] = l4;
  let n2 = r2.length;
  for (; r2[n2 - 1] === "="; ) --n2;
  const o2 = new Uint8Array(n2 * t / 8 | 0);
  let a2 = 0, c4 = 0, h4 = 0;
  for (let l4 = 0; l4 < n2; ++l4) {
    const p2 = s[r2[l4]];
    if (p2 === void 0) throw new SyntaxError(`Non-${i3} character`);
    c4 = c4 << t | p2, a2 += t, a2 >= 8 && (a2 -= 8, o2[h4++] = 255 & c4 >> a2);
  }
  if (a2 >= t || 255 & c4 << 8 - a2) throw new SyntaxError("Unexpected end of data");
  return o2;
};
var fr2 = (r2, e, t) => {
  const i3 = e[e.length - 1] === "=", s = (1 << t) - 1;
  let n2 = "", o2 = 0, a2 = 0;
  for (let c4 = 0; c4 < r2.length; ++c4) for (a2 = a2 << 8 | r2[c4], o2 += 8; o2 > t; ) o2 -= t, n2 += e[s & a2 >> o2];
  if (o2 && (n2 += e[s & a2 << t - o2]), i3) for (; n2.length * t & 7; ) n2 += "=";
  return n2;
};
var A2 = ({ name: r2, prefix: e, bitsPerChar: t, alphabet: i3 }) => Se2({ prefix: e, name: r2, encode(s) {
  return fr2(s, i3, t);
}, decode(s) {
  return mr2(s, i3, t, r2);
} });
var Dr2 = Se2({ prefix: "\0", name: "identity", encode: (r2) => dr2(r2), decode: (r2) => ur(r2) });
var vr2 = Object.freeze({ __proto__: null, identity: Dr2 });
var wr2 = A2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var _r2 = Object.freeze({ __proto__: null, base2: wr2 });
var Er2 = A2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Ir2 = Object.freeze({ __proto__: null, base8: Er2 });
var Tr2 = me2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Cr2 = Object.freeze({ __proto__: null, base10: Tr2 });
var Pr2 = A2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Sr2 = A2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Or2 = Object.freeze({ __proto__: null, base16: Pr2, base16upper: Sr2 });
var Rr2 = A2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Ar2 = A2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var xr2 = A2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Nr2 = A2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var $r2 = A2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var zr = A2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Lr2 = A2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var kr2 = A2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var jr2 = A2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Ur2 = Object.freeze({ __proto__: null, base32: Rr2, base32upper: Ar2, base32pad: xr2, base32padupper: Nr2, base32hex: $r2, base32hexupper: zr, base32hexpad: Lr2, base32hexpadupper: kr2, base32z: jr2 });
var Fr = me2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Mr2 = me2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Kr = Object.freeze({ __proto__: null, base36: Fr, base36upper: Mr2 });
var Br2 = me2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Vr2 = me2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var qr2 = Object.freeze({ __proto__: null, base58btc: Br2, base58flickr: Vr2 });
var Gr2 = A2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Wr2 = A2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Hr2 = A2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Yr = A2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Jr = Object.freeze({ __proto__: null, base64: Gr2, base64pad: Wr2, base64url: Hr2, base64urlpad: Yr });
var ai2 = Array.from("");
var Xr2 = ai2.reduce((r2, e, t) => (r2[t] = e, r2), []);
var Zr2 = ai2.reduce((r2, e, t) => (r2[e.codePointAt(0)] = t, r2), []);
function Qr2(r2) {
  return r2.reduce((e, t) => (e += Xr2[t], e), "");
}
function en2(r2) {
  const e = [];
  for (const t of r2) {
    const i3 = Zr2[t.codePointAt(0)];
    if (i3 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i3);
  }
  return new Uint8Array(e);
}
var tn2 = Se2({ prefix: "", name: "base256emoji", encode: Qr2, decode: en2 });
var sn3 = Object.freeze({ __proto__: null, base256emoji: tn2 });
var rn2 = hi2;
var ci2 = 128;
var nn2 = 127;
var on2 = ~nn2;
var an2 = Math.pow(2, 31);
function hi2(r2, e, t) {
  e = e || [], t = t || 0;
  for (var i3 = t; r2 >= an2; ) e[t++] = r2 & 255 | ci2, r2 /= 128;
  for (; r2 & on2; ) e[t++] = r2 & 255 | ci2, r2 >>>= 7;
  return e[t] = r2 | 0, hi2.bytes = t - i3 + 1, e;
}
var cn2 = Ve2;
var hn2 = 128;
var li2 = 127;
function Ve2(r2, i3) {
  var t = 0, i3 = i3 || 0, s = 0, n2 = i3, o2, a2 = r2.length;
  do {
    if (n2 >= a2) throw Ve2.bytes = 0, new RangeError("Could not decode varint");
    o2 = r2[n2++], t += s < 28 ? (o2 & li2) << s : (o2 & li2) * Math.pow(2, s), s += 7;
  } while (o2 >= hn2);
  return Ve2.bytes = n2 - i3, t;
}
var ln2 = Math.pow(2, 7);
var un2 = Math.pow(2, 14);
var dn2 = Math.pow(2, 21);
var gn2 = Math.pow(2, 28);
var pn2 = Math.pow(2, 35);
var yn2 = Math.pow(2, 42);
var bn2 = Math.pow(2, 49);
var mn2 = Math.pow(2, 56);
var fn2 = Math.pow(2, 63);
var Dn2 = function(r2) {
  return r2 < ln2 ? 1 : r2 < un2 ? 2 : r2 < dn2 ? 3 : r2 < gn2 ? 4 : r2 < pn2 ? 5 : r2 < yn2 ? 6 : r2 < bn2 ? 7 : r2 < mn2 ? 8 : r2 < fn2 ? 9 : 10;
};
var vn2 = { encode: rn2, decode: cn2, encodingLength: Dn2 };
var ui2 = vn2;
var di2 = (r2, e, t = 0) => (ui2.encode(r2, e, t), e);
var gi2 = (r2) => ui2.encodingLength(r2);
var qe2 = (r2, e) => {
  const t = e.byteLength, i3 = gi2(r2), s = i3 + gi2(t), n2 = new Uint8Array(s + t);
  return di2(r2, n2, 0), di2(t, n2, i3), n2.set(e, s), new wn2(r2, t, e, n2);
};
var wn2 = class {
  constructor(e, t, i3, s) {
    this.code = e, this.size = t, this.digest = i3, this.bytes = s;
  }
};
var pi2 = ({ name: r2, code: e, encode: t }) => new _n2(r2, e, t);
var _n2 = class {
  constructor(e, t, i3) {
    this.name = e, this.code = t, this.encode = i3;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? qe2(this.code, t) : t.then((i3) => qe2(this.code, i3));
    } else throw Error("Unknown type, must be binary type");
  }
};
var yi2 = (r2) => async (e) => new Uint8Array(await crypto.subtle.digest(r2, e));
var En2 = pi2({ name: "sha2-256", code: 18, encode: yi2("SHA-256") });
var In2 = pi2({ name: "sha2-512", code: 19, encode: yi2("SHA-512") });
var Tn2 = Object.freeze({ __proto__: null, sha256: En2, sha512: In2 });
var bi2 = 0;
var Cn2 = "identity";
var mi2 = ni2;
var Pn2 = (r2) => qe2(bi2, mi2(r2));
var Sn2 = { code: bi2, name: Cn2, encode: mi2, digest: Pn2 };
var On2 = Object.freeze({ __proto__: null, identity: Sn2 });
new TextEncoder(), new TextDecoder();
var fi2 = { ...vr2, ..._r2, ...Ir2, ...Cr2, ...Or2, ...Ur2, ...Kr, ...qr2, ...Jr, ...sn3 };
({ ...Tn2, ...On2 });
function Di2(r2) {
  return globalThis.Buffer != null ? new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength) : r2;
}
function Rn2(r2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Di2(globalThis.Buffer.allocUnsafe(r2)) : new Uint8Array(r2);
}
function vi2(r2, e, t, i3) {
  return { name: r2, prefix: e, encoder: { name: r2, prefix: e, encode: t }, decoder: { decode: i3 } };
}
var wi2 = vi2("utf8", "u", (r2) => "u" + new TextDecoder("utf8").decode(r2), (r2) => new TextEncoder().encode(r2.substring(1)));
var Ge = vi2("ascii", "a", (r2) => {
  let e = "a";
  for (let t = 0; t < r2.length; t++) e += String.fromCharCode(r2[t]);
  return e;
}, (r2) => {
  r2 = r2.substring(1);
  const e = Rn2(r2.length);
  for (let t = 0; t < r2.length; t++) e[t] = r2.charCodeAt(t);
  return e;
});
var An2 = { utf8: wi2, "utf-8": wi2, hex: fi2.base16, latin1: Ge, ascii: Ge, binary: Ge, ...fi2 };
function xn2(r2, e = "utf8") {
  const t = An2[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Di2(globalThis.Buffer.from(r2, "utf-8")) : t.decoder.decode(`${t.prefix}${r2}`);
}
var Nn2 = Object.defineProperty;
var $n2 = (r2, e, t) => e in r2 ? Nn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var J3 = (r2, e, t) => $n2(r2, typeof e != "symbol" ? e + "" : e, t);
var _i2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, J3(this, "keychain", /* @__PURE__ */ new Map()), J3(this, "name", St2), J3(this, "version", Ot2), J3(this, "initialized", false), J3(this, "storagePrefix", W2), J3(this, "init", async () => {
      if (!this.initialized) {
        const i3 = await this.getKeyChain();
        typeof i3 < "u" && (this.keychain = i3), this.initialized = true;
      }
    }), J3(this, "has", (i3) => (this.isInitialized(), this.keychain.has(i3))), J3(this, "set", async (i3, s) => {
      this.isInitialized(), this.keychain.set(i3, s), await this.persist();
    }), J3(this, "get", (i3) => {
      this.isInitialized();
      const s = this.keychain.get(i3);
      if (typeof s > "u") {
        const { message: n2 } = Et("NO_MATCHING_KEY", `${this.name}: ${i3}`);
        throw new Error(n2);
      }
      return s;
    }), J3(this, "del", async (i3) => {
      this.isInitialized(), this.keychain.delete(i3), await this.persist();
    }), this.core = e, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, Ys(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Xs(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var zn2 = Object.defineProperty;
var Ln2 = (r2, e, t) => e in r2 ? zn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var x2 = (r2, e, t) => Ln2(r2, typeof e != "symbol" ? e + "" : e, t);
var Ei2 = class {
  constructor(e, t, i3) {
    this.core = e, this.logger = t, x2(this, "name", Ct2), x2(this, "keychain"), x2(this, "randomSessionIdentifier", qc()), x2(this, "initialized", false), x2(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), x2(this, "hasKeys", (s) => (this.isInitialized(), this.keychain.has(s))), x2(this, "getClientId", async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), n2 = Po(s);
      return Qe(n2.publicKey);
    }), x2(this, "generateKeyPair", () => {
      this.isInitialized();
      const s = Vc();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }), x2(this, "signJWT", async (s) => {
      this.isInitialized();
      const n2 = await this.getClientSeed(), o2 = Po(n2), a2 = this.randomSessionIdentifier, c4 = Pt2;
      return await Qo(a2, s, c4, o2);
    }), x2(this, "generateSharedKey", (s, n2, o2) => {
      this.isInitialized();
      const a2 = this.getPrivateKey(s), c4 = Kc(a2, n2);
      return this.setSymKey(c4, o2);
    }), x2(this, "setSymKey", async (s, n2) => {
      this.isInitialized();
      const o2 = n2 || Fc(s);
      return await this.keychain.set(o2, s), o2;
    }), x2(this, "deleteKeyPair", async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }), x2(this, "deleteSymKey", async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }), x2(this, "encode", async (s, n2, o2) => {
      this.isInitialized();
      const a2 = Ho(o2), c4 = safeJsonStringify(n2);
      if (Qc(a2)) return Wc(c4, o2 == null ? void 0 : o2.encoding);
      if (Jc(a2)) {
        const y5 = a2.senderPublicKey, w = a2.receiverPublicKey;
        s = await this.generateSharedKey(y5, w);
      }
      const h4 = this.getSymKey(s), { type: l4, senderPublicKey: p2 } = a2;
      return Gc({ type: l4, symKey: h4, message: c4, senderPublicKey: p2, encoding: o2 == null ? void 0 : o2.encoding });
    }), x2(this, "decode", async (s, n2, o2) => {
      this.isInitialized();
      const a2 = Xc(n2, o2);
      if (Qc(a2)) {
        const c4 = Yc(n2, o2 == null ? void 0 : o2.encoding);
        return safeJsonParse(c4);
      }
      if (Jc(a2)) {
        const c4 = a2.receiverPublicKey, h4 = a2.senderPublicKey;
        s = await this.generateSharedKey(c4, h4);
      }
      try {
        const c4 = this.getSymKey(s), h4 = Zc({ symKey: c4, encoded: n2, encoding: o2 == null ? void 0 : o2.encoding });
        return safeJsonParse(h4);
      } catch (c4) {
        this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(c4);
      }
    }), x2(this, "getPayloadType", (s, n2 = Qt) => {
      const o2 = Me({ encoded: s, encoding: n2 });
      return Vt(o2.type);
    }), x2(this, "getPayloadSenderPublicKey", (s, n2 = Qt) => {
      const o2 = Me({ encoded: s, encoding: n2 });
      return o2.senderPublicKey ? toString2(o2.senderPublicKey, tt) : void 0;
    }), this.core = e, this.logger = E(t, this.name), this.keychain = i3 || new _i2(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(Me2);
    } catch {
      e = qc(), await this.keychain.set(Me2, e);
    }
    return xn2(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var kn2 = Object.defineProperty;
var jn2 = Object.defineProperties;
var Un2 = Object.getOwnPropertyDescriptors;
var Ii2 = Object.getOwnPropertySymbols;
var Fn2 = Object.prototype.hasOwnProperty;
var Mn2 = Object.prototype.propertyIsEnumerable;
var We = (r2, e, t) => e in r2 ? kn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Kn2 = (r2, e) => {
  for (var t in e || (e = {})) Fn2.call(e, t) && We(r2, t, e[t]);
  if (Ii2) for (var t of Ii2(e)) Mn2.call(e, t) && We(r2, t, e[t]);
  return r2;
};
var Bn2 = (r2, e) => jn2(r2, Un2(e));
var K3 = (r2, e, t) => We(r2, typeof e != "symbol" ? e + "" : e, t);
var Ti2 = class extends y3 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, K3(this, "messages", /* @__PURE__ */ new Map()), K3(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), K3(this, "name", Rt2), K3(this, "version", At2), K3(this, "initialized", false), K3(this, "storagePrefix", W2), K3(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i3 = await this.getRelayerMessages();
          typeof i3 < "u" && (this.messages = i3);
          const s = await this.getRelayerMessagesWithoutClientAck();
          typeof s < "u" && (this.messagesWithoutClientAck = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i3) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i3);
        } finally {
          this.initialized = true;
        }
      }
    }), K3(this, "set", async (i3, s, n2) => {
      this.isInitialized();
      const o2 = zc(s);
      let a2 = this.messages.get(i3);
      if (typeof a2 > "u" && (a2 = {}), typeof a2[o2] < "u") return o2;
      if (a2[o2] = s, this.messages.set(i3, a2), n2 === ye2.inbound) {
        const c4 = this.messagesWithoutClientAck.get(i3) || {};
        this.messagesWithoutClientAck.set(i3, Bn2(Kn2({}, c4), { [o2]: s }));
      }
      return await this.persist(), o2;
    }), K3(this, "get", (i3) => {
      this.isInitialized();
      let s = this.messages.get(i3);
      return typeof s > "u" && (s = {}), s;
    }), K3(this, "getWithoutAck", (i3) => {
      this.isInitialized();
      const s = {};
      for (const n2 of i3) {
        const o2 = this.messagesWithoutClientAck.get(n2) || {};
        s[n2] = Object.values(o2);
      }
      return s;
    }), K3(this, "has", (i3, s) => {
      this.isInitialized();
      const n2 = this.get(i3), o2 = zc(s);
      return typeof n2[o2] < "u";
    }), K3(this, "ack", async (i3, s) => {
      this.isInitialized();
      const n2 = this.messagesWithoutClientAck.get(i3);
      if (typeof n2 > "u") return;
      const o2 = zc(s);
      delete n2[o2], Object.keys(n2).length === 0 ? this.messagesWithoutClientAck.delete(i3) : this.messagesWithoutClientAck.set(i3, n2), await this.persist();
    }), K3(this, "del", async (i3) => {
      this.isInitialized(), this.messages.delete(i3), this.messagesWithoutClientAck.delete(i3), await this.persist();
    }), this.logger = E(e, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get storageKeyWithoutClientAck() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, Ys(e));
  }
  async setRelayerMessagesWithoutClientAck(e) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, Ys(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Xs(e) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e < "u" ? Xs(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Vn2 = Object.defineProperty;
var qn2 = Object.defineProperties;
var Gn = Object.getOwnPropertyDescriptors;
var Ci2 = Object.getOwnPropertySymbols;
var Wn = Object.prototype.hasOwnProperty;
var Hn2 = Object.prototype.propertyIsEnumerable;
var He2 = (r2, e, t) => e in r2 ? Vn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var ce2 = (r2, e) => {
  for (var t in e || (e = {})) Wn.call(e, t) && He2(r2, t, e[t]);
  if (Ci2) for (var t of Ci2(e)) Hn2.call(e, t) && He2(r2, t, e[t]);
  return r2;
};
var Pi2 = (r2, e) => qn2(r2, Gn(e));
var G2 = (r2, e, t) => He2(r2, typeof e != "symbol" ? e + "" : e, t);
var Yn = class extends m {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, G2(this, "events", new import_events3.EventEmitter()), G2(this, "name", Nt2), G2(this, "queue", /* @__PURE__ */ new Map()), G2(this, "publishTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE)), G2(this, "initialPublishTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), G2(this, "needsTransportRestart", false), G2(this, "publish", async (i3, s, n2) => {
      var o2, a2, c4, h4, l4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s, opts: n2 } });
      const p2 = (n2 == null ? void 0 : n2.ttl) || xt2, y5 = (n2 == null ? void 0 : n2.prompt) || false, w = (n2 == null ? void 0 : n2.tag) || 0, u3 = (n2 == null ? void 0 : n2.id) || getBigIntRpcId().toString(), m2 = na(ea().protocol), D4 = { id: u3, method: (n2 == null ? void 0 : n2.publishMethod) || m2.publish, params: ce2({ topic: i3, message: s, ttl: p2, prompt: y5, tag: w, attestation: n2 == null ? void 0 : n2.attestation }, (n2 == null ? void 0 : n2.tvf) && { tvf: n2.tvf }) }, _2 = `Failed to publish payload, please try again. id:${u3} tag:${w}`;
      try {
        kt((o2 = D4.params) == null ? void 0 : o2.prompt) && ((a2 = D4.params) == null || delete a2.prompt), kt((c4 = D4.params) == null ? void 0 : c4.tag) && ((h4 = D4.params) == null || delete h4.tag);
        const E4 = new Promise(async (L2) => {
          const I3 = ({ id: T3 }) => {
            var S3;
            ((S3 = D4.id) == null ? void 0 : S3.toString()) === T3.toString() && (this.removeRequestFromQueue(T3), this.relayer.events.removeListener(C2.publish, I3), L2());
          };
          this.relayer.events.on(C2.publish, I3);
          const k4 = ni(new Promise((T3, S3) => {
            this.rpcPublish(D4, n2).then(T3).catch((O5) => {
              this.logger.warn(O5, O5 == null ? void 0 : O5.message), S3(O5);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${u3} tag:${w}`);
          try {
            await k4, this.events.removeListener(C2.publish, I3);
          } catch (T3) {
            this.queue.set(u3, { request: D4, opts: n2, attempt: 1 }), this.logger.warn(T3, T3 == null ? void 0 : T3.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: u3, topic: i3, message: s, opts: n2 } }), await ni(E4, this.publishTimeout, _2);
      } catch (E4) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(E4), (l4 = n2 == null ? void 0 : n2.internal) != null && l4.throwOnFailedPublish) throw E4;
      } finally {
        this.queue.delete(u3);
      }
    }), G2(this, "publishCustom", async (i3) => {
      var s, n2, o2, a2, c4;
      this.logger.debug("Publishing custom payload"), this.logger.trace({ type: "method", method: "publishCustom", params: i3 });
      const { payload: h4, opts: l4 = {} } = i3, { attestation: p2, tvf: y5, publishMethod: w, prompt: u3, tag: m2, ttl: D4 = import_time2.FIVE_MINUTES } = l4, _2 = l4.id || getBigIntRpcId().toString(), E4 = na(ea().protocol), L2 = w || E4.publish, I3 = { id: _2, method: L2, params: ce2(Pi2(ce2({}, h4), { ttl: D4, prompt: u3, tag: m2, attestation: p2 }), y5) }, k4 = `Failed to publish custom payload, please try again. id:${_2} tag:${m2}`;
      try {
        kt((s = I3.params) == null ? void 0 : s.prompt) && ((n2 = I3.params) == null || delete n2.prompt), kt((o2 = I3.params) == null ? void 0 : o2.tag) && ((a2 = I3.params) == null || delete a2.tag);
        const T3 = new Promise(async (S3) => {
          const O5 = ({ id: Z2 }) => {
            var _e4;
            ((_e4 = I3.id) == null ? void 0 : _e4.toString()) === Z2.toString() && (this.removeRequestFromQueue(Z2), this.relayer.events.removeListener(C2.publish, O5), S3());
          };
          this.relayer.events.on(C2.publish, O5);
          const te3 = ni(new Promise((Z2, _e4) => {
            this.rpcPublish(I3, l4).then(Z2).catch((Ee2) => {
              this.logger.warn(Ee2, Ee2 == null ? void 0 : Ee2.message), _e4(Ee2);
            });
          }), this.initialPublishTimeout, `Failed initial custom payload publish, retrying.... method:${L2} id:${_2} tag:${m2}`);
          try {
            await te3, this.events.removeListener(C2.publish, O5);
          } catch (Z2) {
            this.queue.set(_2, { request: I3, opts: l4, attempt: 1 }), this.logger.warn(Z2, Z2 == null ? void 0 : Z2.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: _2, payload: h4, opts: l4 } }), await ni(T3, this.publishTimeout, k4);
      } catch (T3) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(T3), (c4 = l4 == null ? void 0 : l4.internal) != null && c4.throwOnFailedPublish) throw T3;
      } finally {
        this.queue.delete(_2);
      }
    }), G2(this, "on", (i3, s) => {
      this.events.on(i3, s);
    }), G2(this, "once", (i3, s) => {
      this.events.once(i3, s);
    }), G2(this, "off", (i3, s) => {
      this.events.off(i3, s);
    }), G2(this, "removeListener", (i3, s) => {
      this.events.removeListener(i3, s);
    }), this.relayer = e, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  async rpcPublish(e, t) {
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: e });
    const i3 = await this.relayer.request(e);
    return this.relayer.events.emit(C2.publish, ce2(ce2({}, e), t)), this.logger.debug("Successfully Published Payload"), i3;
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, t) => {
      var i3;
      const s = e.attempt + 1;
      this.queue.set(t, Pi2(ce2({}, e), { attempt: s })), this.logger.warn({}, `Publisher: queue->publishing: ${e.request.id}, tag: ${(i3 = e.request.params) == null ? void 0 : i3.tag}, attempt: ${s}`), await this.rpcPublish(e.request, e.opts), this.logger.warn({}, `Publisher: queue->published: ${e.request.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(C2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(C2.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var Jn2 = Object.defineProperty;
var Xn = (r2, e, t) => e in r2 ? Jn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var he2 = (r2, e, t) => Xn(r2, typeof e != "symbol" ? e + "" : e, t);
var Zn = class {
  constructor() {
    he2(this, "map", /* @__PURE__ */ new Map()), he2(this, "set", (e, t) => {
      const i3 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i3, t]);
    }), he2(this, "get", (e) => this.map.get(e) || []), he2(this, "exists", (e, t) => this.get(e).includes(t)), he2(this, "delete", (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const i3 = this.get(e);
      if (!this.exists(e, t)) return;
      const s = i3.filter((n2) => n2 !== t);
      if (!s.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s);
    }), he2(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var Qn2 = Object.defineProperty;
var eo2 = Object.defineProperties;
var to2 = Object.getOwnPropertyDescriptors;
var Si2 = Object.getOwnPropertySymbols;
var io2 = Object.prototype.hasOwnProperty;
var so2 = Object.prototype.propertyIsEnumerable;
var Ye2 = (r2, e, t) => e in r2 ? Qn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var fe2 = (r2, e) => {
  for (var t in e || (e = {})) io2.call(e, t) && Ye2(r2, t, e[t]);
  if (Si2) for (var t of Si2(e)) so2.call(e, t) && Ye2(r2, t, e[t]);
  return r2;
};
var Je = (r2, e) => eo2(r2, to2(e));
var f4 = (r2, e, t) => Ye2(r2, typeof e != "symbol" ? e + "" : e, t);
var Oi2 = class extends P {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, f4(this, "subscriptions", /* @__PURE__ */ new Map()), f4(this, "topicMap", new Zn()), f4(this, "events", new import_events3.EventEmitter()), f4(this, "name", Mt2), f4(this, "version", Kt2), f4(this, "pending", /* @__PURE__ */ new Map()), f4(this, "cached", []), f4(this, "initialized", false), f4(this, "storagePrefix", W2), f4(this, "subscribeTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE)), f4(this, "initialSubscribeTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), f4(this, "clientId"), f4(this, "batchSubscribeTopicsLimit", 500), f4(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), f4(this, "subscribe", async (i3, s) => {
      var n2;
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } });
      try {
        const o2 = ea(s), a2 = { topic: i3, relay: o2, transportType: s == null ? void 0 : s.transportType };
        (n2 = s == null ? void 0 : s.internal) != null && n2.skipSubscribe || this.pending.set(i3, a2);
        const c4 = await this.rpcSubscribe(i3, o2, s);
        return typeof c4 == "string" && (this.onSubscribe(c4, a2), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } })), c4;
      } catch (o2) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(o2), o2;
      }
    }), f4(this, "unsubscribe", async (i3, s) => {
      this.isInitialized(), typeof (s == null ? void 0 : s.id) < "u" ? await this.unsubscribeById(i3, s.id, s) : await this.unsubscribeByTopic(i3, s);
    }), f4(this, "isSubscribed", (i3) => new Promise((s) => {
      s(this.topicMap.topics.includes(i3));
    })), f4(this, "isKnownTopic", (i3) => new Promise((s) => {
      s(this.topicMap.topics.includes(i3) || this.pending.has(i3) || this.cached.some((n2) => n2.topic === i3));
    })), f4(this, "on", (i3, s) => {
      this.events.on(i3, s);
    }), f4(this, "once", (i3, s) => {
      this.events.once(i3, s);
    }), f4(this, "off", (i3, s) => {
      this.events.off(i3, s);
    }), f4(this, "removeListener", (i3, s) => {
      this.events.removeListener(i3, s);
    }), f4(this, "start", async () => {
      await this.onConnect();
    }), f4(this, "stop", async () => {
      await this.onDisconnect();
    }), f4(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), f4(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const i3 = [];
      this.pending.forEach((s) => {
        i3.push(s);
      }), await this.batchSubscribe(i3);
    }), f4(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(r.pulse, async () => {
        await this.checkPending();
      }), this.events.on(U2.created, async (i3) => {
        const s = U2.created;
        this.logger.info(`Emitting ${s}`), this.logger.debug({ type: "event", event: s, data: i3 }), await this.persist();
      }), this.events.on(U2.deleted, async (i3) => {
        const s = U2.deleted;
        this.logger.info(`Emitting ${s}`), this.logger.debug({ type: "event", event: s, data: i3 }), await this.persist();
      });
    }), this.relayer = e, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e, t) {
    let i3 = false;
    try {
      i3 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i3;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.values.length > 0 && (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i3 = this.topicMap.get(e);
    await Promise.all(i3.map(async (s) => await this.unsubscribeById(e, s, t)));
  }
  async unsubscribeById(e, t, i3) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    try {
      const s = ea(i3);
      await this.restartToComplete({ topic: e, id: t, relay: s }), await this.rpcUnsubscribe(e, t, s);
      const n2 = Kt("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, n2), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e, t, i3) {
    var s, n2;
    const o2 = await this.getSubscriptionId(e);
    if ((s = i3 == null ? void 0 : i3.internal) != null && s.skipSubscribe) return o2;
    (!i3 || (i3 == null ? void 0 : i3.transportType) === ee2.relay) && await this.restartToComplete({ topic: e, id: e, relay: t });
    const a2 = { method: na(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: a2 });
    const c4 = (n2 = i3 == null ? void 0 : i3.internal) == null ? void 0 : n2.throwOnFailedPublish;
    try {
      if ((i3 == null ? void 0 : i3.transportType) === ee2.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(a2).catch((p2) => this.logger.warn(p2));
      }, (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), o2;
      const h4 = new Promise(async (p2) => {
        const y5 = (w) => {
          w.topic === e && (this.events.removeListener(U2.created, y5), p2(w.id));
        };
        this.events.on(U2.created, y5);
        try {
          const w = await ni(new Promise((u3, m2) => {
            this.relayer.request(a2).catch((D4) => {
              this.logger.warn(D4, D4 == null ? void 0 : D4.message), m2(D4);
            }).then(u3);
          }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
          this.events.removeListener(U2.created, y5), p2(w);
        } catch {
        }
      }), l4 = await ni(h4, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!l4 && c4) throw new Error(`Subscribing to ${e} failed, please try again`);
      return l4 ? o2 : null;
    } catch (h4) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(C2.connection_stalled), c4) throw h4;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay, i3 = { method: na(t.protocol).batchSubscribe, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      await await ni(new Promise((s) => {
        this.relayer.request(i3).catch((n2) => this.logger.warn(n2)).then(s);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(C2.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay, i3 = { method: na(t.protocol).batchFetchMessages, params: { topics: e.map((n2) => n2.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    let s;
    try {
      s = await await ni(new Promise((n2, o2) => {
        this.relayer.request(i3).catch((a2) => {
          this.logger.warn(a2), o2(a2);
        }).then(n2);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(C2.connection_stalled);
    }
    return s;
  }
  rpcUnsubscribe(e, t, i3) {
    const s = { method: na(i3.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, Je(fe2({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, fe2({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i3) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i3), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, fe2({}, t)), this.topicMap.set(t.topic, e), this.events.emit(U2.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i3 } = Et("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i3 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i3.topic, e), this.events.emit(U2.deleted, Je(fe2({}, i3), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(U2.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let i3 = 0; i3 < t; i3++) {
        const s = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(s);
      }
    }
    this.events.emit(U2.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size && !e.every((t) => {
        var i3;
        return t.topic === ((i3 = this.subscriptions.get(t.id)) == null ? void 0 : i3.topic);
      })) {
        const { message: t } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async (t) => Je(fe2({}, t), { id: await this.getSubscriptionId(t.topic) })))));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (await pi((0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete(e) {
    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen());
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e) {
    return zc(e + await this.getClientId());
  }
};
var ro2 = Object.defineProperty;
var Ri2 = Object.getOwnPropertySymbols;
var no2 = Object.prototype.hasOwnProperty;
var oo2 = Object.prototype.propertyIsEnumerable;
var Xe2 = (r2, e, t) => e in r2 ? ro2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Ai2 = (r2, e) => {
  for (var t in e || (e = {})) no2.call(e, t) && Xe2(r2, t, e[t]);
  if (Ri2) for (var t of Ri2(e)) oo2.call(e, t) && Xe2(r2, t, e[t]);
  return r2;
};
var g = (r2, e, t) => Xe2(r2, typeof e != "symbol" ? e + "" : e, t);
var xi2 = class extends d {
  constructor(e) {
    super(e), g(this, "protocol", "wc"), g(this, "version", 2), g(this, "core"), g(this, "logger"), g(this, "events", new import_events3.EventEmitter()), g(this, "provider"), g(this, "messages"), g(this, "subscriber"), g(this, "publisher"), g(this, "name", Lt2), g(this, "transportExplicitlyClosed", false), g(this, "initialized", false), g(this, "connectionAttemptInProgress", false), g(this, "relayUrl"), g(this, "projectId"), g(this, "packageName"), g(this, "bundleId"), g(this, "hasExperiencedNetworkDisruption", false), g(this, "pingTimeout"), g(this, "heartBeatTimeout", (0, import_time2.toMiliseconds)(import_time2.THIRTY_SECONDS + import_time2.FIVE_SECONDS)), g(this, "reconnectTimeout"), g(this, "connectPromise"), g(this, "reconnectInProgress", false), g(this, "requestsInFlight", []), g(this, "connectTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), g(this, "request", async (t) => {
      var i3, s;
      this.logger.debug("Publishing Request Payload");
      const n2 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: n2, method: t.method, topic: (i3 = t.params) == null ? void 0 : i3.topic }, "relayer.request - publishing...");
        const o2 = `${n2}:${((s = t.params) == null ? void 0 : s.tag) || ""}`;
        this.requestsInFlight.push(o2);
        const a2 = await this.provider.request(t);
        return this.requestsInFlight = this.requestsInFlight.filter((c4) => c4 !== o2), a2;
      } catch (o2) {
        throw this.logger.debug(`Failed to Publish Request: ${n2}`), o2;
      }
    }), g(this, "resetPingTimeout", () => {
      Ye() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
        var t, i3, s, n2;
        try {
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (n2 = (s = (i3 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : i3.socket) == null ? void 0 : s.terminate) == null || n2.call(s);
        } catch (o2) {
          this.logger.warn(o2, o2 == null ? void 0 : o2.message);
        }
      }, this.heartBeatTimeout));
    }), g(this, "onPayloadHandler", (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }), g(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(C2.connect);
    }), g(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
    }), g(this, "onProviderErrorHandler", (t) => {
      this.logger.fatal(`Fatal socket error: ${t.message}`), this.events.emit(C2.error, t), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), g(this, "registerProviderListeners", () => {
      this.provider.on(M2.payload, this.onPayloadHandler), this.provider.on(M2.connect, this.onConnectHandler), this.provider.on(M2.disconnect, this.onDisconnectHandler), this.provider.on(M2.error, this.onProviderErrorHandler);
    }), this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E(e.logger, this.name) : (0, import_pino.default)(k({ level: e.logger || zt2 })), this.messages = new Ti2(this.logger, e.core), this.subscriber = new Oi2(this, this.logger), this.publisher = new Yn(this, this.logger), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || Ke2, Ms() ? this.packageName = qs() : Vs() && (this.bundleId = qs()), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.transportOpen().catch((e) => this.logger.warn(e, e == null ? void 0 : e.message));
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e, t, i3;
    return ((i3 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i3.readyState) === 1 || false;
  }
  get connecting() {
    var e, t, i3;
    return ((i3 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i3.readyState) === 0 || this.connectPromise !== void 0 || false;
  }
  async publish(e, t, i3) {
    this.isInitialized(), await this.publisher.publish(e, t, i3), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: ee2.relay }, ye2.outbound);
  }
  async publishCustom(e) {
    this.isInitialized(), await this.publisher.publishCustom(e);
  }
  async subscribe(e, t) {
    var i3, s, n2;
    this.isInitialized(), (!(t != null && t.transportType) || (t == null ? void 0 : t.transportType) === "relay") && await this.toEstablishConnection();
    const o2 = typeof ((i3 = t == null ? void 0 : t.internal) == null ? void 0 : i3.throwOnFailedPublish) > "u" ? true : (s = t == null ? void 0 : t.internal) == null ? void 0 : s.throwOnFailedPublish;
    let a2 = ((n2 = this.subscriber.topicMap.get(e)) == null ? void 0 : n2[0]) || "", c4;
    const h4 = (l4) => {
      l4.topic === e && (this.subscriber.off(U2.created, h4), c4());
    };
    return await Promise.all([new Promise((l4) => {
      c4 = l4, this.subscriber.on(U2.created, h4);
    }), new Promise(async (l4, p2) => {
      a2 = await this.subscriber.subscribe(e, Ai2({ internal: { throwOnFailedPublish: o2 } }, t)).catch((y5) => {
        o2 && p2(y5);
      }) || a2, l4();
    })]), a2;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await ni(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.info("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, i3) => {
      await this.connect(e).then(t).catch(i3).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await ja()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((i3, s) => i3.publishedAt - s.publishedAt);
    this.logger.debug(`Batch of ${t.length} message events sorted`);
    for (const i3 of t) try {
      await this.onMessageEvent(i3);
    } catch (s) {
      this.logger.warn(s, "Error while processing batch message event: " + (s == null ? void 0 : s.message));
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: i3 } = e;
    if (!t.sessionExists) {
      const s = ii(import_time2.FIVE_MINUTES), n2 = { topic: i3, expiry: s, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(i3, n2);
    }
    this.events.emit(C2.message, e), await this.recordMessageEvent(e, ye2.inbound);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t = 1;
    for (; t < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (i3, s) => {
          const n2 = () => {
            s(new Error("Connection interrupted while trying to connect"));
          };
          this.provider.once(M2.disconnect, n2), await ni(new Promise((o2, a2) => {
            this.provider.connect().then(o2).catch(a2);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o2) => {
            s(o2);
          }).finally(() => {
            this.provider.off(M2.disconnect, n2), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o2, a2) => {
            const c4 = () => {
              s(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(M2.disconnect, c4), await this.subscriber.start().then(o2).catch(a2).finally(() => {
              this.provider.off(M2.disconnect, c4);
            });
          }), this.hasExperiencedNetworkDisruption = false, i3();
        });
      } catch (i3) {
        await this.subscriber.stop();
        const s = i3;
        this.logger.warn({}, s.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
        break;
      }
      await new Promise((i3) => setTimeout(i3, (0, import_time2.toMiliseconds)(t * 1))), t++;
    }
  }
  startPingTimeout() {
    var e, t, i3, s, n2;
    if (Ye()) try {
      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((n2 = (s = (i3 = this.provider) == null ? void 0 : i3.connection) == null ? void 0 : s.socket) == null || n2.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o2) {
      this.logger.warn(o2, o2 == null ? void 0 : o2.message);
    }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o(new f(zs({ sdkVersion: Pe2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e, t) {
    const { topic: i3, message: s } = e;
    await this.messages.set(i3, s, t);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i3 } = e;
    if (!i3 || i3.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${i3}`), true;
    if (!await this.subscriber.isKnownTopic(t)) return this.logger.warn(`Ignoring message for unknown topic ${t}`), true;
    const s = this.messages.has(t, i3);
    return s && this.logger.warn(`Ignoring duplicate message: ${i3}`), s;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(kt2)) return;
      const t = e.params, { topic: i3, message: s, publishedAt: n2, attestation: o2 } = t.data, a2 = { topic: i3, message: s, publishedAt: n2, transportType: ee2.relay, attestation: o2 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Ai2({ type: "event", event: t.id }, a2)), this.events.emit(t.id, a2), await this.acknowledgePayload(e), await this.onMessageEvent(a2);
    } else isJsonRpcResponse(e) && this.events.emit(C2.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, ye2.inbound), this.events.emit(C2.message, e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(M2.payload, this.onPayloadHandler), this.provider.off(M2.connect, this.onConnectHandler), this.provider.off(M2.disconnect, this.onDisconnectHandler), this.provider.off(M2.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await ja();
    ka(async (t) => {
      e !== t && (e = t, t ? await this.transportOpen().catch((i3) => this.logger.error(i3, i3 == null ? void 0 : i3.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    }), this.core.heartbeat.on(r.pulse, async () => {
      if (!this.transportExplicitlyClosed && !this.connected && Pa()) try {
        await this.confirmOnlineStateOrThrow(), await this.transportOpen();
      } catch (t) {
        this.logger.warn(t, t == null ? void 0 : t.message);
      }
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout), this.events.emit(C2.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e, e == null ? void 0 : e.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
    }, (0, import_time2.toMiliseconds)(jt2)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectPromise) {
        await this.connectPromise;
        return;
      }
      await this.connect();
    }
  }
};
function ao2(r2, e) {
  return r2 === e || Number.isNaN(r2) && Number.isNaN(e);
}
function Ni2(r2) {
  return Object.getOwnPropertySymbols(r2).filter((e) => Object.prototype.propertyIsEnumerable.call(r2, e));
}
function $i2(r2) {
  return r2 == null ? r2 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r2);
}
var co2 = "[object RegExp]";
var ho2 = "[object String]";
var lo2 = "[object Number]";
var uo2 = "[object Boolean]";
var zi2 = "[object Arguments]";
var go2 = "[object Symbol]";
var po2 = "[object Date]";
var yo2 = "[object Map]";
var bo2 = "[object Set]";
var mo2 = "[object Array]";
var fo2 = "[object Function]";
var Do2 = "[object ArrayBuffer]";
var Ze2 = "[object Object]";
var vo2 = "[object Error]";
var wo2 = "[object DataView]";
var _o2 = "[object Uint8Array]";
var Eo2 = "[object Uint8ClampedArray]";
var Io2 = "[object Uint16Array]";
var To2 = "[object Uint32Array]";
var Co2 = "[object BigUint64Array]";
var Po3 = "[object Int8Array]";
var So2 = "[object Int16Array]";
var Oo2 = "[object Int32Array]";
var Ro2 = "[object BigInt64Array]";
var Ao2 = "[object Float32Array]";
var xo2 = "[object Float64Array]";
function No2() {
}
function Li2(r2) {
  if (!r2 || typeof r2 != "object") return false;
  const e = Object.getPrototypeOf(r2);
  return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(r2) === "[object Object]" : false;
}
function $o2(r2, e, t) {
  return De2(r2, e, void 0, void 0, void 0, void 0, t);
}
function De2(r2, e, t, i3, s, n2, o2) {
  const a2 = o2(r2, e, t, i3, s, n2);
  if (a2 !== void 0) return a2;
  if (typeof r2 == typeof e) switch (typeof r2) {
    case "bigint":
    case "string":
    case "boolean":
    case "symbol":
    case "undefined":
      return r2 === e;
    case "number":
      return r2 === e || Object.is(r2, e);
    case "function":
      return r2 === e;
    case "object":
      return ve2(r2, e, n2, o2);
  }
  return ve2(r2, e, n2, o2);
}
function ve2(r2, e, t, i3) {
  if (Object.is(r2, e)) return true;
  let s = $i2(r2), n2 = $i2(e);
  if (s === zi2 && (s = Ze2), n2 === zi2 && (n2 = Ze2), s !== n2) return false;
  switch (s) {
    case ho2:
      return r2.toString() === e.toString();
    case lo2: {
      const c4 = r2.valueOf(), h4 = e.valueOf();
      return ao2(c4, h4);
    }
    case uo2:
    case po2:
    case go2:
      return Object.is(r2.valueOf(), e.valueOf());
    case co2:
      return r2.source === e.source && r2.flags === e.flags;
    case fo2:
      return r2 === e;
  }
  t = t ?? /* @__PURE__ */ new Map();
  const o2 = t.get(r2), a2 = t.get(e);
  if (o2 != null && a2 != null) return o2 === e;
  t.set(r2, e), t.set(e, r2);
  try {
    switch (s) {
      case yo2: {
        if (r2.size !== e.size) return false;
        for (const [c4, h4] of r2.entries()) if (!e.has(c4) || !De2(h4, e.get(c4), c4, r2, e, t, i3)) return false;
        return true;
      }
      case bo2: {
        if (r2.size !== e.size) return false;
        const c4 = Array.from(r2.values()), h4 = Array.from(e.values());
        for (let l4 = 0; l4 < c4.length; l4++) {
          const p2 = c4[l4], y5 = h4.findIndex((w) => De2(p2, w, void 0, r2, e, t, i3));
          if (y5 === -1) return false;
          h4.splice(y5, 1);
        }
        return true;
      }
      case mo2:
      case _o2:
      case Eo2:
      case Io2:
      case To2:
      case Co2:
      case Po3:
      case So2:
      case Oo2:
      case Ro2:
      case Ao2:
      case xo2: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r2) !== Buffer.isBuffer(e) || r2.length !== e.length) return false;
        for (let c4 = 0; c4 < r2.length; c4++) if (!De2(r2[c4], e[c4], c4, r2, e, t, i3)) return false;
        return true;
      }
      case Do2:
        return r2.byteLength !== e.byteLength ? false : ve2(new Uint8Array(r2), new Uint8Array(e), t, i3);
      case wo2:
        return r2.byteLength !== e.byteLength || r2.byteOffset !== e.byteOffset ? false : ve2(new Uint8Array(r2), new Uint8Array(e), t, i3);
      case vo2:
        return r2.name === e.name && r2.message === e.message;
      case Ze2: {
        if (!(ve2(r2.constructor, e.constructor, t, i3) || Li2(r2) && Li2(e))) return false;
        const h4 = [...Object.keys(r2), ...Ni2(r2)], l4 = [...Object.keys(e), ...Ni2(e)];
        if (h4.length !== l4.length) return false;
        for (let p2 = 0; p2 < h4.length; p2++) {
          const y5 = h4[p2], w = r2[y5];
          if (!Object.hasOwn(e, y5)) return false;
          const u3 = e[y5];
          if (!De2(w, u3, y5, r2, e, t, i3)) return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t.delete(r2), t.delete(e);
  }
}
function zo2(r2, e) {
  return $o2(r2, e, No2);
}
var Lo2 = Object.defineProperty;
var ki2 = Object.getOwnPropertySymbols;
var ko2 = Object.prototype.hasOwnProperty;
var jo2 = Object.prototype.propertyIsEnumerable;
var Qe3 = (r2, e, t) => e in r2 ? Lo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var ji2 = (r2, e) => {
  for (var t in e || (e = {})) ko2.call(e, t) && Qe3(r2, t, e[t]);
  if (ki2) for (var t of ki2(e)) jo2.call(e, t) && Qe3(r2, t, e[t]);
  return r2;
};
var F2 = (r2, e, t) => Qe3(r2, typeof e != "symbol" ? e + "" : e, t);
var Ui2 = class extends f3 {
  constructor(e, t, i3, s = W2, n2 = void 0) {
    super(e, t, i3, s), this.core = e, this.logger = t, this.name = i3, F2(this, "map", /* @__PURE__ */ new Map()), F2(this, "version", Ut2), F2(this, "cached", []), F2(this, "initialized", false), F2(this, "getKey"), F2(this, "storagePrefix", W2), F2(this, "recentlyDeleted", []), F2(this, "recentlyDeletedLimit", 200), F2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o2) => {
        this.getKey && o2 !== null && !kt(o2) ? this.map.set(this.getKey(o2), o2) : wa(o2) ? this.map.set(o2.id, o2) : xa(o2) && this.map.set(o2.topic, o2);
      }), this.cached = [], this.initialized = true);
    }), F2(this, "set", async (o2, a2) => {
      this.isInitialized(), this.map.has(o2) ? await this.update(o2, a2) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o2, value: a2 }), this.map.set(o2, a2), await this.persist());
    }), F2(this, "get", (o2) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o2 }), this.getData(o2))), F2(this, "getAll", (o2) => (this.isInitialized(), o2 ? this.values.filter((a2) => Object.keys(o2).every((c4) => zo2(a2[c4], o2[c4]))) : this.values)), F2(this, "update", async (o2, a2) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o2, update: a2 });
      const c4 = ji2(ji2({}, this.getData(o2)), a2);
      this.map.set(o2, c4), await this.persist();
    }), F2(this, "delete", async (o2, a2) => {
      this.isInitialized(), this.map.has(o2) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o2, reason: a2 }), this.map.delete(o2), this.addToRecentlyDeleted(o2), await this.persist());
    }), this.logger = E(t, this.name), this.storagePrefix = s, this.getKey = n2;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: s } = Et("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(s), new Error(s);
      }
      const { message: i3 } = Et("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Uo2 = Object.defineProperty;
var Fo2 = (r2, e, t) => e in r2 ? Uo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var d2 = (r2, e, t) => Fo2(r2, typeof e != "symbol" ? e + "" : e, t);
var Fi2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, d2(this, "name", Bt2), d2(this, "version", Vt2), d2(this, "events", new import_events3.default()), d2(this, "pairings"), d2(this, "initialized", false), d2(this, "storagePrefix", W2), d2(this, "ignoredPayloadTypes", [ee]), d2(this, "registeredMethods", []), d2(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), d2(this, "register", ({ methods: i3 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i3])];
    }), d2(this, "create", async (i3) => {
      this.isInitialized();
      const s = qc(), n2 = await this.core.crypto.setSymKey(s), o2 = ii(import_time2.FIVE_MINUTES), a2 = { protocol: $t2 }, c4 = { topic: n2, expiry: o2, relay: a2, active: false, methods: i3 == null ? void 0 : i3.methods }, h4 = oa({ protocol: this.core.protocol, version: this.core.version, topic: n2, symKey: s, relay: a2, expiryTimestamp: o2, methods: i3 == null ? void 0 : i3.methods });
      return this.events.emit(ae2.create, c4), this.core.expirer.set(n2, o2), await this.pairings.set(n2, c4), await this.core.relayer.subscribe(n2, { transportType: i3 == null ? void 0 : i3.transportType, internal: i3 == null ? void 0 : i3.internal }), { topic: n2, uri: h4 };
    }), d2(this, "pair", async (i3) => {
      this.isInitialized();
      const s = this.core.eventClient.createEvent({ properties: { topic: i3 == null ? void 0 : i3.uri, trace: [Y2.pairing_started] } });
      this.isValidPair(i3, s);
      const { topic: n2, symKey: o2, relay: a2, expiryTimestamp: c4, methods: h4 } = ra(i3.uri);
      s.props.properties.topic = n2, s.addTrace(Y2.pairing_uri_validation_success), s.addTrace(Y2.pairing_uri_not_expired);
      let l4;
      if (this.pairings.keys.includes(n2)) {
        if (l4 = this.pairings.get(n2), s.addTrace(Y2.existing_pairing), l4.active) throw s.setError(X2.active_pairing_already_exists), new Error(`Pairing already exists: ${n2}. Please try again with a new connection URI.`);
        s.addTrace(Y2.pairing_not_expired);
      }
      const p2 = c4 || ii(import_time2.FIVE_MINUTES), y5 = { topic: n2, relay: a2, expiry: p2, active: false, methods: h4 };
      this.core.expirer.set(n2, p2), await this.pairings.set(n2, y5), s.addTrace(Y2.store_new_pairing), i3.activatePairing && await this.activate({ topic: n2 }), this.events.emit(ae2.create, y5), s.addTrace(Y2.emit_inactive_pairing), this.core.crypto.keychain.has(n2) || await this.core.crypto.setSymKey(o2, n2), s.addTrace(Y2.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        s.setError(X2.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(n2, { relay: a2 });
      } catch (w) {
        throw s.setError(X2.subscribe_pairing_topic_failure), w;
      }
      return s.addTrace(Y2.subscribe_pairing_topic_success), y5;
    }), d2(this, "activate", async ({ topic: i3 }) => {
      this.isInitialized();
      const s = ii(import_time2.FIVE_MINUTES);
      this.core.expirer.set(i3, s), await this.pairings.update(i3, { active: true, expiry: s });
    }), d2(this, "ping", async (i3) => {
      this.isInitialized(), await this.isValidPing(i3), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: s } = i3;
      if (this.pairings.keys.includes(s)) {
        const n2 = await this.sendRequest(s, "wc_pairingPing", {}), { done: o2, resolve: a2, reject: c4 } = ei();
        this.events.once(ci("pairing_ping", n2), ({ error: h4 }) => {
          h4 ? c4(h4) : a2();
        }), await o2();
      }
    }), d2(this, "updateExpiry", async ({ topic: i3, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { expiry: s });
    }), d2(this, "updateMetadata", async ({ topic: i3, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { peerMetadata: s });
    }), d2(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), d2(this, "disconnect", async (i3) => {
      this.isInitialized(), await this.isValidDisconnect(i3);
      const { topic: s } = i3;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", Kt("USER_DISCONNECTED")), await this.deletePairing(s));
    }), d2(this, "formatUriFromPairing", (i3) => {
      this.isInitialized();
      const { topic: s, relay: n2, expiry: o2, methods: a2 } = i3, c4 = this.core.crypto.keychain.get(s);
      return oa({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: c4, relay: n2, expiryTimestamp: o2, methods: a2 });
    }), d2(this, "sendRequest", async (i3, s, n2) => {
      const o2 = formatJsonRpcRequest(s, n2), a2 = await this.core.crypto.encode(i3, o2), c4 = oe[s].req;
      return this.core.history.set(i3, o2), this.core.relayer.publish(i3, a2, c4), o2.id;
    }), d2(this, "sendResult", async (i3, s, n2) => {
      const o2 = formatJsonRpcResult(i3, n2), a2 = await this.core.crypto.encode(s, o2), c4 = (await this.core.history.get(s, i3)).request.method, h4 = oe[c4].res;
      await this.core.relayer.publish(s, a2, h4), await this.core.history.resolve(o2);
    }), d2(this, "sendError", async (i3, s, n2) => {
      const o2 = formatJsonRpcError(i3, n2), a2 = await this.core.crypto.encode(s, o2), c4 = (await this.core.history.get(s, i3)).request.method, h4 = oe[c4] ? oe[c4].res : oe.unregistered_method.res;
      await this.core.relayer.publish(s, a2, h4), await this.core.history.resolve(o2);
    }), d2(this, "deletePairing", async (i3, s) => {
      await this.core.relayer.unsubscribe(i3), await Promise.all([this.pairings.delete(i3, Kt("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i3), s ? Promise.resolve() : this.core.expirer.del(i3)]);
    }), d2(this, "cleanup", async () => {
      const i3 = this.pairings.getAll().filter((s) => fi(s.expiry));
      await Promise.all(i3.map((s) => this.deletePairing(s.topic)));
    }), d2(this, "onRelayEventRequest", async (i3) => {
      const { topic: s, payload: n2 } = i3;
      switch (n2.method) {
        case "wc_pairingPing":
          return await this.onPairingPingRequest(s, n2);
        case "wc_pairingDelete":
          return await this.onPairingDeleteRequest(s, n2);
        default:
          return await this.onUnknownRpcMethodRequest(s, n2);
      }
    }), d2(this, "onRelayEventResponse", async (i3) => {
      const { topic: s, payload: n2 } = i3, o2 = (await this.core.history.get(s, n2.id)).request.method;
      switch (o2) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s, n2);
        default:
          return this.onUnknownRpcMethodResponse(o2);
      }
    }), d2(this, "onPairingPingRequest", async (i3, s) => {
      const { id: n2 } = s;
      try {
        this.isValidPing({ topic: i3 }), await this.sendResult(n2, i3, true), this.events.emit(ae2.ping, { id: n2, topic: i3 });
      } catch (o2) {
        await this.sendError(n2, i3, o2), this.logger.error(o2);
      }
    }), d2(this, "onPairingPingResponse", (i3, s) => {
      const { id: n2 } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(ci("pairing_ping", n2), {}) : isJsonRpcError(s) && this.events.emit(ci("pairing_ping", n2), { error: s.error });
      }, 500);
    }), d2(this, "onPairingDeleteRequest", async (i3, s) => {
      const { id: n2 } = s;
      try {
        this.isValidDisconnect({ topic: i3 }), await this.deletePairing(i3), this.events.emit(ae2.delete, { id: n2, topic: i3 });
      } catch (o2) {
        await this.sendError(n2, i3, o2), this.logger.error(o2);
      }
    }), d2(this, "onUnknownRpcMethodRequest", async (i3, s) => {
      const { id: n2, method: o2 } = s;
      try {
        if (this.registeredMethods.includes(o2)) return;
        const a2 = Kt("WC_METHOD_UNSUPPORTED", o2);
        await this.sendError(n2, i3, a2), this.logger.error(a2);
      } catch (a2) {
        await this.sendError(n2, i3, a2), this.logger.error(a2);
      }
    }), d2(this, "onUnknownRpcMethodResponse", (i3) => {
      this.registeredMethods.includes(i3) || this.logger.error(Kt("WC_METHOD_UNSUPPORTED", i3));
    }), d2(this, "isValidPair", (i3, s) => {
      var n2;
      if (!Aa(i3)) {
        const { message: a2 } = Et("MISSING_OR_INVALID", `pair() params: ${i3}`);
        throw s.setError(X2.malformed_pairing_uri), new Error(a2);
      }
      if (!ma(i3.uri)) {
        const { message: a2 } = Et("MISSING_OR_INVALID", `pair() uri: ${i3.uri}`);
        throw s.setError(X2.malformed_pairing_uri), new Error(a2);
      }
      const o2 = ra(i3 == null ? void 0 : i3.uri);
      if (!((n2 = o2 == null ? void 0 : o2.relay) != null && n2.protocol)) {
        const { message: a2 } = Et("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw s.setError(X2.malformed_pairing_uri), new Error(a2);
      }
      if (!(o2 != null && o2.symKey)) {
        const { message: a2 } = Et("MISSING_OR_INVALID", "pair() uri#symKey");
        throw s.setError(X2.malformed_pairing_uri), new Error(a2);
      }
      if (o2 != null && o2.expiryTimestamp && (0, import_time2.toMiliseconds)(o2 == null ? void 0 : o2.expiryTimestamp) < Date.now()) {
        s.setError(X2.pairing_expired);
        const { message: a2 } = Et("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a2);
      }
    }), d2(this, "isValidPing", async (i3) => {
      if (!Aa(i3)) {
        const { message: n2 } = Et("MISSING_OR_INVALID", `ping() params: ${i3}`);
        throw new Error(n2);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }), d2(this, "isValidDisconnect", async (i3) => {
      if (!Aa(i3)) {
        const { message: n2 } = Et("MISSING_OR_INVALID", `disconnect() params: ${i3}`);
        throw new Error(n2);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }), d2(this, "isValidPairingTopic", async (i3) => {
      if (!it(i3, false)) {
        const { message: s } = Et("MISSING_OR_INVALID", `pairing topic should be a string: ${i3}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(i3)) {
        const { message: s } = Et("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i3}`);
        throw new Error(s);
      }
      if (fi(this.pairings.get(i3).expiry)) {
        await this.deletePairing(i3);
        const { message: s } = Et("EXPIRED", `pairing topic: ${i3}`);
        throw new Error(s);
      }
    }), this.core = e, this.logger = E(t, this.name), this.pairings = new Ui2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(C2.message, async (e) => {
      const { topic: t, message: i3, transportType: s } = e;
      if (this.pairings.keys.includes(t) && s !== ee2.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i3))) try {
        const n2 = await this.core.crypto.decode(t, i3);
        isJsonRpcRequest(n2) ? (this.core.history.set(t, n2), await this.onRelayEventRequest({ topic: t, payload: n2 })) : isJsonRpcResponse(n2) && (await this.core.history.resolve(n2), await this.onRelayEventResponse({ topic: t, payload: n2 }), this.core.history.delete(t, n2.id)), await this.core.relayer.messages.ack(t, i3);
      } catch (n2) {
        this.logger.error(n2);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(q.expired, async (e) => {
      const { topic: t } = si(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(ae2.expire, { topic: t }));
    });
  }
};
var Mo2 = Object.defineProperty;
var Ko2 = (r2, e, t) => e in r2 ? Mo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var N3 = (r2, e, t) => Ko2(r2, typeof e != "symbol" ? e + "" : e, t);
var Mi2 = class extends I {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, N3(this, "records", /* @__PURE__ */ new Map()), N3(this, "events", new import_events3.EventEmitter()), N3(this, "name", qt2), N3(this, "version", Gt2), N3(this, "cached", []), N3(this, "initialized", false), N3(this, "storagePrefix", W2), N3(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.records.set(i3.id, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), N3(this, "set", (i3, s, n2) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i3, request: s, chainId: n2 }), this.records.has(s.id)) return;
      const o2 = { id: s.id, topic: i3, request: { method: s.method, params: s.params || null }, chainId: n2, expiry: ii(import_time2.THIRTY_DAYS) };
      this.records.set(o2.id, o2), this.persist(), this.events.emit(V2.created, o2);
    }), N3(this, "resolve", async (i3) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i3 }), !this.records.has(i3.id)) return;
      const s = await this.getRecord(i3.id);
      typeof s.response > "u" && (s.response = isJsonRpcError(i3) ? { error: i3.error } : { result: i3.result }, this.records.set(s.id, s), this.persist(), this.events.emit(V2.updated, s));
    }), N3(this, "get", async (i3, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i3, id: s }), await this.getRecord(s))), N3(this, "delete", (i3, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((n2) => {
        if (n2.topic === i3) {
          if (typeof s < "u" && n2.id !== s) return;
          this.records.delete(n2.id), this.events.emit(V2.deleted, n2);
        }
      }), this.persist();
    }), N3(this, "exists", async (i3, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i3 : false)), N3(this, "on", (i3, s) => {
      this.events.on(i3, s);
    }), N3(this, "once", (i3, s) => {
      this.events.once(i3, s);
    }), N3(this, "off", (i3, s) => {
      this.events.off(i3, s);
    }), N3(this, "removeListener", (i3, s) => {
      this.events.removeListener(i3, s);
    }), this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const i3 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i3);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i3 } = Et("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(V2.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(V2.created, (e) => {
      const t = V2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(V2.updated, (e) => {
      const t = V2.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(V2.deleted, (e) => {
      const t = V2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(r.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        (0, import_time2.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(V2.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Bo2 = Object.defineProperty;
var Vo2 = (r2, e, t) => e in r2 ? Bo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var z2 = (r2, e, t) => Vo2(r2, typeof e != "symbol" ? e + "" : e, t);
var Ki2 = class extends S {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, z2(this, "expirations", /* @__PURE__ */ new Map()), z2(this, "events", new import_events3.EventEmitter()), z2(this, "name", Wt2), z2(this, "version", Ht2), z2(this, "cached", []), z2(this, "initialized", false), z2(this, "storagePrefix", W2), z2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.expirations.set(i3.target, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), z2(this, "has", (i3) => {
      try {
        const s = this.formatTarget(i3);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return false;
      }
    }), z2(this, "set", (i3, s) => {
      this.isInitialized();
      const n2 = this.formatTarget(i3), o2 = { target: n2, expiry: s };
      this.expirations.set(n2, o2), this.checkExpiry(n2, o2), this.events.emit(q.created, { target: n2, expiration: o2 });
    }), z2(this, "get", (i3) => {
      this.isInitialized();
      const s = this.formatTarget(i3);
      return this.getExpiration(s);
    }), z2(this, "del", (i3) => {
      if (this.isInitialized(), this.has(i3)) {
        const s = this.formatTarget(i3), n2 = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(q.deleted, { target: s, expiration: n2 });
      }
    }), z2(this, "on", (i3, s) => {
      this.events.on(i3, s);
    }), z2(this, "once", (i3, s) => {
      this.events.once(i3, s);
    }), z2(this, "off", (i3, s) => {
      this.events.off(i3, s);
    }), z2(this, "removeListener", (i3, s) => {
      this.events.removeListener(i3, s);
    }), this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return ri(e);
    if (typeof e == "number") return oi(e);
    const { message: t } = Et("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(q.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i3 } = Et("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(i3), new Error(i3);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i3 } = t;
    (0, import_time2.toMiliseconds)(i3) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(q.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(q.created, (e) => {
      const t = q.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(q.expired, (e) => {
      const t = q.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(q.deleted, (e) => {
      const t = q.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var qo2 = Object.defineProperty;
var Go2 = (r2, e, t) => e in r2 ? qo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var P2 = (r2, e, t) => Go2(r2, typeof e != "symbol" ? e + "" : e, t);
var Bi2 = class extends M {
  constructor(e, t, i3) {
    super(e, t, i3), this.core = e, this.logger = t, this.store = i3, P2(this, "name", Yt2), P2(this, "abortController"), P2(this, "isDevEnv"), P2(this, "verifyUrlV3", Xt2), P2(this, "storagePrefix", W2), P2(this, "version", Fe2), P2(this, "publicKey"), P2(this, "fetchPromise"), P2(this, "init", async () => {
      var s;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time2.toMiliseconds)((s = this.publicKey) == null ? void 0 : s.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), P2(this, "register", async (s) => {
      if (!zt() || this.isDevEnv) return;
      const n2 = window.location.origin, { id: o2, decryptedId: a2 } = s, c4 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n2}&id=${o2}&decryptedId=${a2}`;
      try {
        const h4 = (0, import_window_getters2.getDocument)(), l4 = this.startAbortTimer(import_time2.ONE_SECOND * 5), p2 = await new Promise((y5, w) => {
          const u3 = () => {
            window.removeEventListener("message", D4), h4.body.removeChild(m2), w("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", u3);
          const m2 = h4.createElement("iframe");
          m2.src = c4, m2.style.display = "none", m2.addEventListener("error", u3, { signal: this.abortController.signal });
          const D4 = (_2) => {
            if (_2.data && typeof _2.data == "string") try {
              const E4 = JSON.parse(_2.data);
              if (E4.type === "verify_attestation") {
                if (sn(E4.attestation).payload.id !== o2) return;
                clearInterval(l4), h4.body.removeChild(m2), this.abortController.signal.removeEventListener("abort", u3), window.removeEventListener("message", D4), y5(E4.attestation === null ? "" : E4.attestation);
              }
            } catch (E4) {
              this.logger.warn(E4);
            }
          };
          h4.body.appendChild(m2), window.addEventListener("message", D4, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", p2), p2;
      } catch (h4) {
        this.logger.warn(h4);
      }
      return "";
    }), P2(this, "resolve", async (s) => {
      if (this.isDevEnv) return "";
      const { attestationId: n2, hash: o2, encryptedId: a2 } = s;
      if (n2 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (n2) {
        if (sn(n2).payload.id !== a2) return;
        const h4 = await this.isValidJwtAttestation(n2);
        if (h4) {
          if (!h4.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h4;
        }
      }
      if (!o2) return;
      const c4 = this.getVerifyUrl(s == null ? void 0 : s.verifyUrl);
      return this.fetchAttestation(o2, c4);
    }), P2(this, "fetchAttestation", async (s, n2) => {
      this.logger.debug(`resolving attestation: ${s} from url: ${n2}`);
      const o2 = this.startAbortTimer(import_time2.ONE_SECOND * 5), a2 = await fetch(`${n2}/attestation/${s}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o2), a2.status === 200 ? await a2.json() : void 0;
    }), P2(this, "getVerifyUrl", (s) => {
      let n2 = s || be2;
      return Zt2.includes(n2) || (this.logger.info(`verify url: ${n2}, not included in trusted list, assigning default: ${be2}`), n2 = be2), n2;
    }), P2(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const s = this.startAbortTimer(import_time2.FIVE_SECONDS), n2 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(s), await n2.json();
      } catch (s) {
        this.logger.warn(s);
      }
    }), P2(this, "persistPublicKey", async (s) => {
      this.logger.debug("persisting public key to local storage", s), await this.store.setItem(this.storeKey, s), this.publicKey = s;
    }), P2(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), P2(this, "isValidJwtAttestation", async (s) => {
      const n2 = await this.getPublicKey();
      try {
        if (n2) return this.validateAttestation(s, n2);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
      const o2 = await this.fetchAndPersistPublicKey();
      try {
        if (o2) return this.validateAttestation(s, o2);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
    }), P2(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), P2(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (n2) => {
        const o2 = await this.fetchPublicKey();
        o2 && (await this.persistPublicKey(o2), n2(o2));
      });
      const s = await this.fetchPromise;
      return this.fetchPromise = void 0, s;
    }), P2(this, "validateAttestation", (s, n2) => {
      const o2 = ta(s, n2.publicKey), a2 = { hasExpired: (0, import_time2.toMiliseconds)(o2.exp) < Date.now(), payload: o2 };
      if (a2.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a2.payload.origin, isScam: a2.payload.isScam, isVerified: a2.payload.isVerified };
    }), this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = hi(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e));
  }
};
var Wo2 = Object.defineProperty;
var Ho2 = (r2, e, t) => e in r2 ? Wo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Vi2 = (r2, e, t) => Ho2(r2, typeof e != "symbol" ? e + "" : e, t);
var qi2 = class extends O2 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, Vi2(this, "context", Qt2), Vi2(this, "registerDeviceToken", async (i3) => {
      const { clientId: s, token: n2, notificationType: o2, enableEncrypted: a2 = false } = i3, c4 = `${ei2}/${this.projectId}/clients`;
      await fetch(c4, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s, type: o2, token: n2, always_raw: a2 }) });
    }), this.logger = E(t, this.context);
  }
};
var Yo2 = Object.defineProperty;
var Gi2 = Object.getOwnPropertySymbols;
var Jo2 = Object.prototype.hasOwnProperty;
var Xo2 = Object.prototype.propertyIsEnumerable;
var et = (r2, e, t) => e in r2 ? Yo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var we2 = (r2, e) => {
  for (var t in e || (e = {})) Jo2.call(e, t) && et(r2, t, e[t]);
  if (Gi2) for (var t of Gi2(e)) Xo2.call(e, t) && et(r2, t, e[t]);
  return r2;
};
var R2 = (r2, e, t) => et(r2, typeof e != "symbol" ? e + "" : e, t);
var Wi2 = class extends R {
  constructor(e, t, i3 = true) {
    super(e, t, i3), this.core = e, this.logger = t, R2(this, "context", ii2), R2(this, "storagePrefix", W2), R2(this, "storageVersion", ti), R2(this, "events", /* @__PURE__ */ new Map()), R2(this, "shouldPersist", false), R2(this, "init", async () => {
      if (!hi()) try {
        const s = { eventId: di(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: cr(this.core.relayer.protocol, this.core.relayer.version, Pe2) } } };
        await this.sendEvent([s]);
      } catch (s) {
        this.logger.warn(s);
      }
    }), R2(this, "createEvent", (s) => {
      const { event: n2 = "ERROR", type: o2 = "", properties: { topic: a2, trace: c4 } } = s, h4 = di(), l4 = this.core.projectId || "", p2 = Date.now(), y5 = we2({ eventId: h4, timestamp: p2, props: { event: n2, type: o2, properties: { topic: a2, trace: c4 } }, bundleId: l4, domain: this.getAppDomain() }, this.setMethods(h4));
      return this.telemetryEnabled && (this.events.set(h4, y5), this.shouldPersist = true), y5;
    }), R2(this, "getEvent", (s) => {
      const { eventId: n2, topic: o2 } = s;
      if (n2) return this.events.get(n2);
      const a2 = Array.from(this.events.values()).find((c4) => c4.props.properties.topic === o2);
      if (a2) return we2(we2({}, a2), this.setMethods(a2.eventId));
    }), R2(this, "deleteEvent", (s) => {
      const { eventId: n2 } = s;
      this.events.delete(n2), this.shouldPersist = true;
    }), R2(this, "setEventListeners", () => {
      this.core.heartbeat.on(r.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((s) => {
          (0, import_time2.fromMiliseconds)(Date.now()) - (0, import_time2.fromMiliseconds)(s.timestamp) > si2 && (this.events.delete(s.eventId), this.shouldPersist = true);
        });
      });
    }), R2(this, "setMethods", (s) => ({ addTrace: (n2) => this.addTrace(s, n2), setError: (n2) => this.setError(s, n2) })), R2(this, "addTrace", (s, n2) => {
      const o2 = this.events.get(s);
      o2 && (o2.props.properties.trace.push(n2), this.events.set(s, o2), this.shouldPersist = true);
    }), R2(this, "setError", (s, n2) => {
      const o2 = this.events.get(s);
      o2 && (o2.props.type = n2, o2.timestamp = Date.now(), this.events.set(s, o2), this.shouldPersist = true);
    }), R2(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), R2(this, "restore", async () => {
      try {
        const s = await this.core.storage.getItem(this.storageKey) || [];
        if (!s.length) return;
        s.forEach((n2) => {
          this.events.set(n2.eventId, we2(we2({}, n2), this.setMethods(n2.eventId)));
        });
      } catch (s) {
        this.logger.warn(s);
      }
    }), R2(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const s = [];
      for (const [n2, o2] of this.events) o2.props.type && s.push(o2);
      if (s.length !== 0) try {
        if ((await this.sendEvent(s)).ok) for (const n2 of s) this.events.delete(n2.eventId), this.shouldPersist = true;
      } catch (n2) {
        this.logger.warn(n2);
      }
    }), R2(this, "sendEvent", async (s) => {
      const n2 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${ri2}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${Pe2}${n2}`, { method: "POST", body: JSON.stringify(s) });
    }), R2(this, "getAppDomain", () => sr().url), this.logger = E(t, this.context), this.telemetryEnabled = i3, i3 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Zo2 = Object.defineProperty;
var Hi2 = Object.getOwnPropertySymbols;
var Qo3 = Object.prototype.hasOwnProperty;
var ea2 = Object.prototype.propertyIsEnumerable;
var tt2 = (r2, e, t) => e in r2 ? Zo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Yi2 = (r2, e) => {
  for (var t in e || (e = {})) Qo3.call(e, t) && tt2(r2, t, e[t]);
  if (Hi2) for (var t of Hi2(e)) ea2.call(e, t) && tt2(r2, t, e[t]);
  return r2;
};
var v2 = (r2, e, t) => tt2(r2, typeof e != "symbol" ? e + "" : e, t);
var Oe2 = class _Oe extends h2 {
  constructor(e) {
    var t;
    super(e), v2(this, "protocol", Ue2), v2(this, "version", Fe2), v2(this, "name", pe2), v2(this, "relayUrl"), v2(this, "projectId"), v2(this, "customStoragePrefix"), v2(this, "events", new import_events3.EventEmitter()), v2(this, "logger"), v2(this, "heartbeat"), v2(this, "relayer"), v2(this, "crypto"), v2(this, "storage"), v2(this, "history"), v2(this, "expirer"), v2(this, "pairing"), v2(this, "verify"), v2(this, "echoClient"), v2(this, "linkModeSupportedApps"), v2(this, "eventClient"), v2(this, "initialized", false), v2(this, "logChunkController"), v2(this, "on", (a2, c4) => this.events.on(a2, c4)), v2(this, "once", (a2, c4) => this.events.once(a2, c4)), v2(this, "off", (a2, c4) => this.events.off(a2, c4)), v2(this, "removeListener", (a2, c4) => this.events.removeListener(a2, c4)), v2(this, "dispatchEnvelope", ({ topic: a2, message: c4, sessionExists: h4 }) => {
      if (!a2 || !c4) return;
      const l4 = { topic: a2, message: c4, publishedAt: Date.now(), transportType: ee2.link_mode };
      this.relayer.onLinkMessageEvent(l4, { sessionExists: h4 });
    });
    const i3 = this.getGlobalCore(e == null ? void 0 : e.customStoragePrefix);
    if (i3) try {
      return this.customStoragePrefix = i3.customStoragePrefix, this.logger = i3.logger, this.heartbeat = i3.heartbeat, this.crypto = i3.crypto, this.history = i3.history, this.expirer = i3.expirer, this.storage = i3.storage, this.relayer = i3.relayer, this.pairing = i3.pairing, this.verify = i3.verify, this.echoClient = i3.echoClient, this.linkModeSupportedApps = i3.linkModeSupportedApps, this.eventClient = i3.eventClient, this.initialized = i3.initialized, this.logChunkController = i3.logChunkController, i3;
    } catch (a2) {
      console.warn("Failed to copy global core", a2);
    }
    this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || Ke2, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s = k({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : It2.logger, name: pe2 }), { logger: n2, chunkLoggerController: o2 } = A({ opts: s, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = o2, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var a2, c4;
      (a2 = this.logChunkController) != null && a2.downloadLogsBlobInBrowser && ((c4 = this.logChunkController) == null || c4.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(n2, this.name), this.heartbeat = new i(), this.crypto = new Ei2(this, this.logger, e == null ? void 0 : e.keychain), this.history = new Mi2(this, this.logger), this.expirer = new Ki2(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(Yi2(Yi2({}, Tt2), e == null ? void 0 : e.storageOptions)), this.relayer = new xi2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Fi2(this, this.logger), this.verify = new Bi2(this, this.logger, this.storage), this.echoClient = new qi2(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Wi2(this, this.logger, e == null ? void 0 : e.telemetryEnabled), this.setGlobalCore(this);
  }
  static async init(e) {
    const t = new _Oe(e);
    await t.initialize();
    const i3 = await t.crypto.getClientId();
    return await t.storage.setItem(Ft, i3), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(Be2, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Be2) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
  getGlobalCore(e = "") {
    try {
      if (this.isGlobalCoreDisabled()) return;
      const t = `_walletConnectCore_${e}`, i3 = `${t}_count`;
      return globalThis[i3] = (globalThis[i3] || 0) + 1, globalThis[i3] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[i3]} times.`), globalThis[t];
    } catch (t) {
      console.warn("Failed to get global WalletConnect core", t);
      return;
    }
  }
  setGlobalCore(e) {
    var t;
    try {
      if (this.isGlobalCoreDisabled()) return;
      const i3 = `_walletConnectCore_${((t = e.opts) == null ? void 0 : t.customStoragePrefix) || ""}`;
      globalThis[i3] = e;
    } catch (i3) {
      console.warn("Failed to set global WalletConnect core", i3);
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < "u" && process.env.DISABLE_GLOBAL_CORE === "true";
    } catch {
      return true;
    }
  }
};
var ta2 = Oe2;

// node_modules/@reown/appkit/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events4 = __toESM(require_events());
var import_time3 = __toESM(require_cjs());
var Ce2 = "wc";
var ke2 = 2;
var De3 = "client";
var we3 = `${Ce2}@${ke2}:${De3}:`;
var me3 = { name: De3, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var Le2 = "WALLETCONNECT_DEEPLINK_CHOICE";
var dt2 = "proposal";
var Me3 = "Proposal expired";
var ut2 = "session";
var B = import_time3.SEVEN_DAYS;
var gt2 = "engine";
var P3 = { wc_sessionPropose: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time3.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time3.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var _e2 = { min: import_time3.FIVE_MINUTES, max: import_time3.SEVEN_DAYS };
var M3 = { idle: "IDLE", active: "ACTIVE" };
var yt = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" }, sui_signAndExecuteTransaction: { key: "digest" }, sui_signTransaction: { key: "" }, hedera_signAndExecuteTransaction: { key: "transactionId" }, hedera_executeTransaction: { key: "transactionId" }, near_signTransaction: { key: "" }, near_signTransactions: { key: "" }, tron_signTransaction: { key: "txID" }, xrpl_signTransaction: { key: "" }, xrpl_signTransactionFor: { key: "" }, algo_signTxn: { key: "" }, sendTransfer: { key: "txid" }, stacks_stxTransfer: { key: "txId" }, polkadot_signTransaction: { key: "" }, cosmos_signDirect: { key: "" } };
var wt2 = "request";
var mt2 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var _t2 = "wc";
var ft = "auth";
var Et2 = "authKeys";
var St3 = "pairingTopics";
var Rt3 = "requests";
var le3 = `${_t2}@${1.5}:${ft}:`;
var pe3 = `${le3}:PUB_KEY`;
var Os = Object.defineProperty;
var bs2 = Object.defineProperties;
var As = Object.getOwnPropertyDescriptors;
var vt2 = Object.getOwnPropertySymbols;
var xs2 = Object.prototype.hasOwnProperty;
var Vs2 = Object.prototype.propertyIsEnumerable;
var $e2 = (E4, o2, t) => o2 in E4 ? Os(E4, o2, { enumerable: true, configurable: true, writable: true, value: t }) : E4[o2] = t;
var R3 = (E4, o2) => {
  for (var t in o2 || (o2 = {})) xs2.call(o2, t) && $e2(E4, t, o2[t]);
  if (vt2) for (var t of vt2(o2)) Vs2.call(o2, t) && $e2(E4, t, o2[t]);
  return E4;
};
var O3 = (E4, o2) => bs2(E4, As(o2));
var c3 = (E4, o2, t) => $e2(E4, typeof o2 != "symbol" ? o2 + "" : o2, t);
var Cs2 = class extends V {
  constructor(o2) {
    super(o2), c3(this, "name", gt2), c3(this, "events", new import_events4.default()), c3(this, "initialized", false), c3(this, "requestQueue", { state: M3.idle, queue: [] }), c3(this, "sessionRequestQueue", { state: M3.idle, queue: [] }), c3(this, "emittedSessionRequests", new gi({ limit: 500 })), c3(this, "requestQueueDelay", import_time3.ONE_SECOND), c3(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c3(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c3(this, "recentlyDeletedLimit", 200), c3(this, "relayMessageCache", []), c3(this, "pendingSessions", /* @__PURE__ */ new Map()), c3(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(P3) }), this.initialized = true, setTimeout(async () => {
        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay)));
    }), c3(this, "connect", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const e = O3(R3({}, t), { requiredNamespaces: t.requiredNamespaces || {}, optionalNamespaces: t.optionalNamespaces || {} });
      await this.isValidConnect(e), e.optionalNamespaces = ba(e.requiredNamespaces, e.optionalNamespaces), e.requiredNamespaces = {};
      const { pairingTopic: s, requiredNamespaces: i3, optionalNamespaces: r2, sessionProperties: n2, scopedProperties: a2, relays: l4 } = e;
      let p2 = s, h4, u3 = false;
      try {
        if (p2) {
          const T3 = this.client.core.pairing.pairings.get(p2);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), u3 = T3.active;
        }
      } catch (T3) {
        throw this.client.logger.error(`connect() -> pairing.get(${p2}) failed`), T3;
      }
      if (!p2 || !u3) {
        const { topic: T3, uri: $3 } = await this.client.core.pairing.create({ internal: { skipSubscribe: true } });
        p2 = T3, h4 = $3;
      }
      if (!p2) {
        const { message: T3 } = Et("NO_MATCHING_KEY", `connect() pairing topic: ${p2}`);
        throw new Error(T3);
      }
      const d3 = await this.client.core.crypto.generateKeyPair(), y5 = P3.wc_sessionPropose.req.ttl || import_time3.FIVE_MINUTES, w = ii(y5), m2 = O3(R3(R3({ requiredNamespaces: i3, optionalNamespaces: r2, relays: l4 ?? [{ protocol: $t2 }], proposer: { publicKey: d3, metadata: this.client.metadata }, expiryTimestamp: w, pairingTopic: p2 }, n2 && { sessionProperties: n2 }), a2 && { scopedProperties: a2 }), { id: payloadId() }), S3 = ci("session_connect", m2.id), { reject: _2, resolve: b3, done: C4 } = ei(y5, Me3), I3 = ({ id: T3 }) => {
        T3 === m2.id && (this.client.events.off("proposal_expire", I3), this.pendingSessions.delete(m2.id), this.events.emit(S3, { error: { message: Me3, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", I3), this.events.once(S3, ({ error: T3, session: $3 }) => {
        this.client.events.off("proposal_expire", I3), T3 ? _2(T3) : $3 && b3($3);
      }), await this.sendProposeSession({ proposal: m2, publishOpts: { internal: { throwOnFailedPublish: true }, tvf: { correlationId: m2.id } } }), await this.setProposal(m2.id, m2), { uri: h4, approval: C4 };
    }), c3(this, "pair", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(t);
      } catch (e) {
        throw this.client.logger.error("pair() failed"), e;
      }
    }), c3(this, "approve", async (t) => {
      var e, s, i3;
      const r2 = this.client.core.eventClient.createEvent({ properties: { topic: (e = t == null ? void 0 : t.id) == null ? void 0 : e.toString(), trace: [rr2.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (N5) {
        throw r2.setError(nr.no_internet_connection), N5;
      }
      try {
        await this.isValidProposalId(t == null ? void 0 : t.id);
      } catch (N5) {
        throw this.client.logger.error(`approve() -> proposal.get(${t == null ? void 0 : t.id}) failed`), r2.setError(nr.proposal_not_found), N5;
      }
      try {
        await this.isValidApprove(t);
      } catch (N5) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r2.setError(nr.session_approve_namespace_validation_failure), N5;
      }
      const { id: n2, relayProtocol: a2, namespaces: l4, sessionProperties: p2, scopedProperties: h4, sessionConfig: u3 } = t, d3 = this.client.proposal.get(n2);
      this.client.core.eventClient.deleteEvent({ eventId: r2.eventId });
      const { pairingTopic: y5, proposer: w, requiredNamespaces: m2, optionalNamespaces: S3 } = d3;
      let _2 = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({ topic: y5 });
      _2 || (_2 = (i3 = this.client.core.eventClient) == null ? void 0 : i3.createEvent({ type: rr2.session_approve_started, properties: { topic: y5, trace: [rr2.session_approve_started, rr2.session_namespaces_validation_success] } }));
      const b3 = await this.client.core.crypto.generateKeyPair(), C4 = w.publicKey, I3 = await this.client.core.crypto.generateSharedKey(b3, C4), T3 = R3(R3(R3({ relay: { protocol: a2 ?? "irn" }, namespaces: l4, controller: { publicKey: b3, metadata: this.client.metadata }, expiry: ii(B) }, p2 && { sessionProperties: p2 }), h4 && { scopedProperties: h4 }), u3 && { sessionConfig: u3 }), $3 = ee2.relay;
      _2.addTrace(rr2.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(I3, { transportType: $3, internal: { skipSubscribe: true } });
      } catch (N5) {
        throw _2.setError(nr.subscribe_session_topic_failure), N5;
      }
      _2.addTrace(rr2.subscribe_session_topic_success);
      const Ee2 = O3(R3({}, T3), { topic: I3, requiredNamespaces: m2, optionalNamespaces: S3, pairingTopic: y5, acknowledged: false, self: T3.controller, peer: { publicKey: w.publicKey, metadata: w.metadata }, controller: b3, transportType: ee2.relay });
      await this.client.session.set(I3, Ee2), _2.addTrace(rr2.store_session);
      try {
        await this.sendApproveSession({ sessionTopic: I3, proposal: d3, pairingProposalResponse: { relay: { protocol: a2 ?? "irn" }, responderPublicKey: b3 }, sessionSettleRequest: T3, publishOpts: { internal: { throwOnFailedPublish: true }, tvf: { correlationId: n2 } } }), _2.addTrace(rr2.session_approve_publish_success);
      } catch (N5) {
        throw this.client.logger.error(N5), this.client.session.delete(I3, Kt("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(I3), N5;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: _2.eventId }), await this.client.core.pairing.updateMetadata({ topic: y5, metadata: w.metadata }), await this.deleteProposal(n2), await this.client.core.pairing.activate({ topic: y5 }), await this.setExpiry(I3, ii(B)), { topic: I3, acknowledged: () => Promise.resolve(this.client.session.get(I3)) };
    }), c3(this, "reject", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(t);
      } catch (r2) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r2;
      }
      const { id: e, reason: s } = t;
      let i3;
      try {
        i3 = this.client.proposal.get(e).pairingTopic;
      } catch (r2) {
        throw this.client.logger.error(`reject() -> proposal.get(${e}) failed`), r2;
      }
      i3 && await this.sendError({ id: e, topic: i3, error: s, rpcOpts: P3.wc_sessionPropose.reject }), await this.deleteProposal(e);
    }), c3(this, "update", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(t);
      } catch (h4) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), h4;
      }
      const { topic: e, namespaces: s } = t, { done: i3, resolve: r2, reject: n2 } = ei(), a2 = payloadId(), l4 = getBigIntRpcId().toString(), p2 = this.client.session.get(e).namespaces;
      return this.events.once(ci("session_update", a2), ({ error: h4 }) => {
        h4 ? n2(h4) : r2();
      }), await this.client.session.update(e, { namespaces: s }), await this.sendRequest({ topic: e, method: "wc_sessionUpdate", params: { namespaces: s }, throwOnFailedPublish: true, clientRpcId: a2, relayRpcId: l4 }).catch((h4) => {
        this.client.logger.error(h4), this.client.session.update(e, { namespaces: p2 }), n2(h4);
      }), { acknowledged: i3 };
    }), c3(this, "extend", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(t);
      } catch (a2) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a2;
      }
      const { topic: e } = t, s = payloadId(), { done: i3, resolve: r2, reject: n2 } = ei();
      return this.events.once(ci("session_extend", s), ({ error: a2 }) => {
        a2 ? n2(a2) : r2();
      }), await this.setExpiry(e, ii(B)), this.sendRequest({ topic: e, method: "wc_sessionExtend", params: {}, clientRpcId: s, throwOnFailedPublish: true }).catch((a2) => {
        n2(a2);
      }), { acknowledged: i3 };
    }), c3(this, "request", async (t) => {
      this.isInitialized();
      try {
        await this.isValidRequest(t);
      } catch (m2) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), m2;
      }
      const { chainId: e, request: s, topic: i3, expiry: r2 = P3.wc_sessionRequest.req.ttl } = t, n2 = this.client.session.get(i3);
      (n2 == null ? void 0 : n2.transportType) === ee2.relay && await this.confirmOnlineStateOrThrow();
      const a2 = payloadId(), l4 = getBigIntRpcId().toString(), { done: p2, resolve: h4, reject: u3 } = ei(r2, "Request expired. Please try again.");
      this.events.once(ci("session_request", a2), ({ error: m2, result: S3 }) => {
        m2 ? u3(m2) : h4(S3);
      });
      const d3 = "wc_sessionRequest", y5 = this.getAppLinkIfEnabled(n2.peer.metadata, n2.transportType);
      if (y5) return await this.sendRequest({ clientRpcId: a2, relayRpcId: l4, topic: i3, method: d3, params: { request: O3(R3({}, s), { expiryTimestamp: ii(r2) }), chainId: e }, expiry: r2, throwOnFailedPublish: true, appLink: y5 }).catch((m2) => u3(m2)), this.client.events.emit("session_request_sent", { topic: i3, request: s, chainId: e, id: a2 }), await p2();
      const w = { request: O3(R3({}, s), { expiryTimestamp: ii(r2) }), chainId: e };
      return await Promise.all([new Promise(async (m2) => {
        await this.sendRequest({ clientRpcId: a2, relayRpcId: l4, topic: i3, method: d3, params: w, expiry: r2, throwOnFailedPublish: true, tvf: this.getTVFParams(a2, w) }).catch((S3) => u3(S3)), this.client.events.emit("session_request_sent", { topic: i3, request: s, chainId: e, id: a2 }), m2();
      }), new Promise(async (m2) => {
        var S3;
        if (!((S3 = n2.sessionConfig) != null && S3.disableDeepLink)) {
          const _2 = await ui(this.client.core.storage, Le2);
          await ai({ id: a2, topic: i3, wcDeepLink: _2 });
        }
        m2();
      }), p2()]).then((m2) => m2[2]);
    }), c3(this, "respond", async (t) => {
      this.isInitialized(), await this.isValidRespond(t);
      const { topic: e, response: s } = t, { id: i3 } = s, r2 = this.client.session.get(e);
      r2.transportType === ee2.relay && await this.confirmOnlineStateOrThrow();
      const n2 = this.getAppLinkIfEnabled(r2.peer.metadata, r2.transportType);
      isJsonRpcResult(s) ? await this.sendResult({ id: i3, topic: e, result: s.result, throwOnFailedPublish: true, appLink: n2 }) : isJsonRpcError(s) && await this.sendError({ id: i3, topic: e, error: s.error, appLink: n2 }), this.cleanupAfterResponse(t);
    }), c3(this, "ping", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(t);
      } catch (s) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s;
      }
      const { topic: e } = t;
      if (this.client.session.keys.includes(e)) {
        const s = payloadId(), i3 = getBigIntRpcId().toString(), { done: r2, resolve: n2, reject: a2 } = ei();
        this.events.once(ci("session_ping", s), ({ error: l4 }) => {
          l4 ? a2(l4) : n2();
        }), await Promise.all([this.sendRequest({ topic: e, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s, relayRpcId: i3 }), r2()]);
      } else this.client.core.pairing.pairings.keys.includes(e) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: e }));
    }), c3(this, "emit", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(t);
      const { topic: e, event: s, chainId: i3 } = t, r2 = getBigIntRpcId().toString(), n2 = payloadId();
      await this.sendRequest({ topic: e, method: "wc_sessionEvent", params: { event: s, chainId: i3 }, throwOnFailedPublish: true, relayRpcId: r2, clientRpcId: n2 });
    }), c3(this, "disconnect", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(t);
      const { topic: e } = t;
      if (this.client.session.keys.includes(e)) await this.sendRequest({ topic: e, method: "wc_sessionDelete", params: Kt("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: e, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(e)) await this.client.core.pairing.disconnect({ topic: e });
      else {
        const { message: s } = Et("MISMATCHED_TOPIC", `Session or pairing topic not found: ${e}`);
        throw new Error(s);
      }
    }), c3(this, "find", (t) => (this.isInitialized(), this.client.session.getAll().filter((e) => ya(e, t)))), c3(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c3(this, "authenticate", async (t, e) => {
      var s;
      this.isInitialized(), this.isValidAuthenticate(t);
      const i3 = e && this.client.core.linkModeSupportedApps.includes(e) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode), r2 = i3 ? ee2.link_mode : ee2.relay;
      r2 === ee2.relay && await this.confirmOnlineStateOrThrow();
      const { chains: n2, statement: a2 = "", uri: l4, domain: p2, nonce: h4, type: u3, exp: d3, nbf: y5, methods: w = [], expiry: m2 } = t, S3 = [...t.resources || []], { topic: _2, uri: b3 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r2 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: _2, uri: b3 } });
      const C4 = await this.client.core.crypto.generateKeyPair(), I3 = Fc(C4);
      if (await Promise.all([this.client.auth.authKeys.set(pe3, { responseTopic: I3, publicKey: C4 }), this.client.auth.pairingTopics.set(I3, { topic: I3, pairingTopic: _2 })]), await this.client.core.relayer.subscribe(I3, { transportType: r2 }), this.client.logger.info(`sending request to new pairing topic: ${_2}`), w.length > 0) {
        const { namespace: A4 } = Fe(n2[0]);
        let k4 = Ef(A4, "request", w);
        Oe(S3) && (k4 = Bf(k4, S3.pop())), S3.push(k4);
      }
      const T3 = m2 && m2 > P3.wc_sessionAuthenticate.req.ttl ? m2 : P3.wc_sessionAuthenticate.req.ttl, $3 = { authPayload: { type: u3 ?? "caip122", chains: n2, statement: a2, aud: l4, domain: p2, version: "1", nonce: h4, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: d3, nbf: y5, resources: S3 }, requester: { publicKey: C4, metadata: this.client.metadata }, expiryTimestamp: ii(T3) }, Ee2 = { eip155: { chains: n2, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...w])], events: ["chainChanged", "accountsChanged"] } }, N5 = { requiredNamespaces: {}, optionalNamespaces: Ee2, relays: [{ protocol: "irn" }], pairingTopic: _2, proposer: { publicKey: C4, metadata: this.client.metadata }, expiryTimestamp: ii(P3.wc_sessionPropose.req.ttl), id: payloadId() }, { done: Tt4, resolve: Ue4, reject: Se4 } = ei(T3, "Request expired"), se3 = payloadId(), he4 = ci("session_connect", N5.id), Re4 = ci("session_request", se3), de3 = async ({ error: A4, session: k4 }) => {
        this.events.off(Re4, ve4), A4 ? Se4(A4) : k4 && Ue4({ session: k4 });
      }, ve4 = async (A4) => {
        var k4, Ge3, je3;
        if (await this.deletePendingAuthRequest(se3, { message: "fulfilled", code: 0 }), A4.error) {
          const re3 = Kt("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return A4.error.code === re3.code ? void 0 : (this.events.off(he4, de3), Se4(A4.error.message));
        }
        await this.deleteProposal(N5.id), this.events.off(he4, de3);
        const { cacaos: Fe4, responder: H2 } = A4.result, Te3 = [], Qe5 = [];
        for (const re3 of Fe4) {
          await yf({ cacao: re3, projectId: this.client.core.projectId }) || (this.client.logger.error(re3, "Signature verification failed"), Se4(Kt("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: qe4 } = re3, Pe4 = Oe(qe4.resources), He4 = [Vr(qe4.iss)], qt3 = dn(qe4.iss);
          if (Pe4) {
            const Ne3 = If(Pe4), Pt4 = Af(Pe4);
            Te3.push(...Ne3), He4.push(...Pt4);
          }
          for (const Ne3 of He4) Qe5.push(`${Ne3}:${qt3}`);
        }
        const ie4 = await this.client.core.crypto.generateSharedKey(C4, H2.publicKey);
        let ue3;
        Te3.length > 0 && (ue3 = { topic: ie4, acknowledged: true, self: { publicKey: C4, metadata: this.client.metadata }, peer: H2, controller: H2.publicKey, expiry: ii(B), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: _2, namespaces: ga([...new Set(Te3)], [...new Set(Qe5)]), transportType: r2 }, await this.client.core.relayer.subscribe(ie4, { transportType: r2 }), await this.client.session.set(ie4, ue3), _2 && await this.client.core.pairing.updateMetadata({ topic: _2, metadata: H2.metadata }), ue3 = this.client.session.get(ie4)), (k4 = this.client.metadata.redirect) != null && k4.linkMode && (Ge3 = H2.metadata.redirect) != null && Ge3.linkMode && (je3 = H2.metadata.redirect) != null && je3.universal && e && (this.client.core.addLinkModeSupportedApp(H2.metadata.redirect.universal), this.client.session.update(ie4, { transportType: ee2.link_mode })), Ue4({ auths: Fe4, session: ue3 });
      };
      this.events.once(he4, de3), this.events.once(Re4, ve4);
      let Ie3;
      try {
        if (i3) {
          const A4 = formatJsonRpcRequest("wc_sessionAuthenticate", $3, se3);
          this.client.core.history.set(_2, A4);
          const k4 = await this.client.core.crypto.encode("", A4, { type: ge, encoding: De });
          Ie3 = sa(e, _2, k4);
        } else await Promise.all([this.sendRequest({ topic: _2, method: "wc_sessionAuthenticate", params: $3, expiry: t.expiry, throwOnFailedPublish: true, clientRpcId: se3 }), this.sendRequest({ topic: _2, method: "wc_sessionPropose", params: N5, expiry: P3.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: N5.id })]);
      } catch (A4) {
        throw this.events.off(he4, de3), this.events.off(Re4, ve4), A4;
      }
      return await this.setProposal(N5.id, N5), await this.setAuthRequest(se3, { request: O3(R3({}, $3), { verifyContext: {} }), pairingTopic: _2, transportType: r2 }), { uri: Ie3 ?? b3, response: Tt4 };
    }), c3(this, "approveSessionAuthenticate", async (t) => {
      const { id: e, auths: s } = t, i3 = this.client.core.eventClient.createEvent({ properties: { topic: e.toString(), trace: [or2.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (m2) {
        throw i3.setError(ar.no_internet_connection), m2;
      }
      const r2 = this.getPendingAuthRequest(e);
      if (!r2) throw i3.setError(ar.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${e}`);
      const n2 = r2.transportType || ee2.relay;
      n2 === ee2.relay && await this.confirmOnlineStateOrThrow();
      const a2 = r2.requester.publicKey, l4 = await this.client.core.crypto.generateKeyPair(), p2 = Fc(a2), h4 = { type: ee, receiverPublicKey: a2, senderPublicKey: l4 }, u3 = [], d3 = [];
      for (const m2 of s) {
        if (!await yf({ cacao: m2, projectId: this.client.core.projectId })) {
          i3.setError(ar.invalid_cacao);
          const I3 = Kt("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: e, topic: p2, error: I3, encodeOpts: h4 }), new Error(I3.message);
        }
        i3.addTrace(or2.cacaos_verified);
        const { p: S3 } = m2, _2 = Oe(S3.resources), b3 = [Vr(S3.iss)], C4 = dn(S3.iss);
        if (_2) {
          const I3 = If(_2), T3 = Af(_2);
          u3.push(...I3), b3.push(...T3);
        }
        for (const I3 of b3) d3.push(`${I3}:${C4}`);
      }
      const y5 = await this.client.core.crypto.generateSharedKey(l4, a2);
      i3.addTrace(or2.create_authenticated_session_topic);
      let w;
      if ((u3 == null ? void 0 : u3.length) > 0) {
        w = { topic: y5, acknowledged: true, self: { publicKey: l4, metadata: this.client.metadata }, peer: { publicKey: a2, metadata: r2.requester.metadata }, controller: a2, expiry: ii(B), authentication: s, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r2.pairingTopic, namespaces: ga([...new Set(u3)], [...new Set(d3)]), transportType: n2 }, i3.addTrace(or2.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(y5, { transportType: n2 });
        } catch (m2) {
          throw i3.setError(ar.subscribe_authenticated_session_topic_failure), m2;
        }
        i3.addTrace(or2.subscribe_authenticated_session_topic_success), await this.client.session.set(y5, w), i3.addTrace(or2.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r2.pairingTopic, metadata: r2.requester.metadata });
      }
      i3.addTrace(or2.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: p2, id: e, result: { cacaos: s, responder: { publicKey: l4, metadata: this.client.metadata } }, encodeOpts: h4, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r2.requester.metadata, n2) });
      } catch (m2) {
        throw i3.setError(ar.authenticated_session_approve_publish_failure), m2;
      }
      return await this.client.auth.requests.delete(e, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r2.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i3.eventId }), { session: w };
    }), c3(this, "rejectSessionAuthenticate", async (t) => {
      this.isInitialized();
      const { id: e, reason: s } = t, i3 = this.getPendingAuthRequest(e);
      if (!i3) throw new Error(`Could not find pending auth request with id ${e}`);
      i3.transportType === ee2.relay && await this.confirmOnlineStateOrThrow();
      const r2 = i3.requester.publicKey, n2 = await this.client.core.crypto.generateKeyPair(), a2 = Fc(r2), l4 = { type: ee, receiverPublicKey: r2, senderPublicKey: n2 };
      await this.sendError({ id: e, topic: a2, error: s, encodeOpts: l4, rpcOpts: P3.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i3.requester.metadata, i3.transportType) }), await this.client.auth.requests.delete(e, { message: "rejected", code: 0 }), await this.deleteProposal(e);
    }), c3(this, "formatAuthMessage", (t) => {
      this.isInitialized();
      const { request: e, iss: s } = t;
      return qr(e, s);
    }), c3(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const t = this.relayMessageCache.shift();
          t && await this.onRelayMessage(t);
        } catch (t) {
          this.client.logger.error(t);
        }
      }, 50);
    }), c3(this, "cleanupDuplicatePairings", async (t) => {
      if (t.pairingTopic) try {
        const e = this.client.core.pairing.pairings.get(t.pairingTopic), s = this.client.core.pairing.pairings.getAll().filter((i3) => {
          var r2, n2;
          return ((r2 = i3.peerMetadata) == null ? void 0 : r2.url) && ((n2 = i3.peerMetadata) == null ? void 0 : n2.url) === t.peer.metadata.url && i3.topic && i3.topic !== e.topic;
        });
        if (s.length === 0) return;
        this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (e) {
        this.client.logger.error(e);
      }
    }), c3(this, "deleteSession", async (t) => {
      var e;
      const { topic: s, expirerHasDeleted: i3 = false, emitEvent: r2 = true, id: n2 = 0 } = t, { self: a2 } = this.client.session.get(s);
      await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, Kt("USER_DISCONNECTED")), this.addToRecentlyDeleted(s, "session"), this.client.core.crypto.keychain.has(a2.publicKey) && await this.client.core.crypto.deleteKeyPair(a2.publicKey), this.client.core.crypto.keychain.has(s) && await this.client.core.crypto.deleteSymKey(s), i3 || this.client.core.expirer.del(s), this.client.core.storage.removeItem(Le2).catch((l4) => this.client.logger.warn(l4)), this.getPendingSessionRequests().forEach((l4) => {
        l4.topic === s && this.deletePendingSessionRequest(l4.id, Kt("USER_DISCONNECTED"));
      }), s === ((e = this.sessionRequestQueue.queue[0]) == null ? void 0 : e.topic) && (this.sessionRequestQueue.state = M3.idle), r2 && this.client.events.emit("session_delete", { id: n2, topic: s });
    }), c3(this, "deleteProposal", async (t, e) => {
      if (e) try {
        const s = this.client.proposal.get(t), i3 = this.client.core.eventClient.getEvent({ topic: s.pairingTopic });
        i3 == null ? void 0 : i3.setError(nr.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(t, Kt("USER_DISCONNECTED")), e ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "proposal");
    }), c3(this, "deletePendingSessionRequest", async (t, e, s = false) => {
      await Promise.all([this.client.pendingRequest.delete(t, e), s ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i3) => i3.id !== t), s && (this.sessionRequestQueue.state = M3.idle, this.client.events.emit("session_request_expire", { id: t }));
    }), c3(this, "deletePendingAuthRequest", async (t, e, s = false) => {
      await Promise.all([this.client.auth.requests.delete(t, e), s ? Promise.resolve() : this.client.core.expirer.del(t)]);
    }), c3(this, "setExpiry", async (t, e) => {
      this.client.session.keys.includes(t) && (this.client.core.expirer.set(t, e), await this.client.session.update(t, { expiry: e }));
    }), c3(this, "setProposal", async (t, e) => {
      this.client.core.expirer.set(t, ii(P3.wc_sessionPropose.req.ttl)), await this.client.proposal.set(t, e);
    }), c3(this, "setAuthRequest", async (t, e) => {
      const { request: s, pairingTopic: i3, transportType: r2 = ee2.relay } = e;
      this.client.core.expirer.set(t, s.expiryTimestamp), await this.client.auth.requests.set(t, { authPayload: s.authPayload, requester: s.requester, expiryTimestamp: s.expiryTimestamp, id: t, pairingTopic: i3, verifyContext: s.verifyContext, transportType: r2 });
    }), c3(this, "setPendingSessionRequest", async (t) => {
      const { id: e, topic: s, params: i3, verifyContext: r2 } = t, n2 = i3.request.expiryTimestamp || ii(P3.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(e, n2), await this.client.pendingRequest.set(e, { id: e, topic: s, params: i3, verifyContext: r2 });
    }), c3(this, "sendRequest", async (t) => {
      const { topic: e, method: s, params: i3, expiry: r2, relayRpcId: n2, clientRpcId: a2, throwOnFailedPublish: l4, appLink: p2, tvf: h4, publishOpts: u3 = {} } = t, d3 = formatJsonRpcRequest(s, i3, a2);
      let y5;
      const w = !!p2;
      try {
        const _2 = w ? De : Qt;
        y5 = await this.client.core.crypto.encode(e, d3, { encoding: _2 });
      } catch (_2) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e} failed`), _2;
      }
      let m2;
      if (mt2.includes(s)) {
        const _2 = zc(JSON.stringify(d3)), b3 = zc(y5);
        m2 = await this.client.core.verify.register({ id: b3, decryptedId: _2 });
      }
      const S3 = R3(R3({}, P3[s].req), u3);
      if (S3.attestation = m2, r2 && (S3.ttl = r2), n2 && (S3.id = n2), this.client.core.history.set(e, d3), w) {
        const _2 = sa(p2, e, y5);
        await global.Linking.openURL(_2, this.client.name);
      } else S3.tvf = O3(R3({}, h4), { correlationId: d3.id }), l4 ? (S3.internal = O3(R3({}, S3.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(e, y5, S3)) : this.client.core.relayer.publish(e, y5, S3).catch((_2) => this.client.logger.error(_2));
      return d3.id;
    }), c3(this, "sendProposeSession", async (t) => {
      const { proposal: e, publishOpts: s } = t, i3 = formatJsonRpcRequest("wc_sessionPropose", e, e.id);
      this.client.core.history.set(e.pairingTopic, i3);
      const r2 = await this.client.core.crypto.encode(e.pairingTopic, i3, { encoding: Qt }), n2 = zc(JSON.stringify(i3)), a2 = zc(r2), l4 = await this.client.core.verify.register({ id: a2, decryptedId: n2 });
      await this.client.core.relayer.publishCustom({ payload: { pairingTopic: e.pairingTopic, sessionProposal: r2 }, opts: O3(R3({}, s), { publishMethod: "wc_proposeSession", attestation: l4 }) });
    }), c3(this, "sendApproveSession", async (t) => {
      const { sessionTopic: e, pairingProposalResponse: s, proposal: i3, sessionSettleRequest: r2, publishOpts: n2 } = t, a2 = formatJsonRpcResult(i3.id, s), l4 = await this.client.core.crypto.encode(i3.pairingTopic, a2, { encoding: Qt }), p2 = formatJsonRpcRequest("wc_sessionSettle", r2, n2 == null ? void 0 : n2.id), h4 = await this.client.core.crypto.encode(e, p2, { encoding: Qt });
      this.client.core.history.set(e, p2), await this.client.core.relayer.publishCustom({ payload: { sessionTopic: e, pairingTopic: i3.pairingTopic, sessionProposalResponse: l4, sessionSettlementRequest: h4 }, opts: O3(R3({}, n2), { publishMethod: "wc_approveSession" }) });
    }), c3(this, "sendResult", async (t) => {
      const { id: e, topic: s, result: i3, throwOnFailedPublish: r2, encodeOpts: n2, appLink: a2 } = t, l4 = formatJsonRpcResult(e, i3);
      let p2;
      const h4 = a2 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const y5 = h4 ? De : Qt;
        p2 = await this.client.core.crypto.encode(s, l4, O3(R3({}, n2 || {}), { encoding: y5 }));
      } catch (y5) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), y5;
      }
      let u3, d3;
      try {
        u3 = await this.client.core.history.get(s, e);
        const y5 = u3.request;
        try {
          d3 = this.getTVFParams(e, y5.params, i3);
        } catch (w) {
          this.client.logger.warn(`sendResult() -> getTVFParams() failed: ${w == null ? void 0 : w.message}`);
        }
      } catch (y5) {
        throw this.client.logger.error(`sendResult() -> history.get(${s}, ${e}) failed`), y5;
      }
      if (h4) {
        const y5 = sa(a2, s, p2);
        await global.Linking.openURL(y5, this.client.name);
      } else {
        const y5 = u3.request.method, w = P3[y5].res;
        w.tvf = O3(R3({}, d3), { correlationId: e }), r2 ? (w.internal = O3(R3({}, w.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s, p2, w)) : this.client.core.relayer.publish(s, p2, w).catch((m2) => this.client.logger.error(m2));
      }
      await this.client.core.history.resolve(l4);
    }), c3(this, "sendError", async (t) => {
      const { id: e, topic: s, error: i3, encodeOpts: r2, rpcOpts: n2, appLink: a2 } = t, l4 = formatJsonRpcError(e, i3);
      let p2;
      const h4 = a2 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const d3 = h4 ? De : Qt;
        p2 = await this.client.core.crypto.encode(s, l4, O3(R3({}, r2 || {}), { encoding: d3 }));
      } catch (d3) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), d3;
      }
      let u3;
      try {
        u3 = await this.client.core.history.get(s, e);
      } catch (d3) {
        throw this.client.logger.error(`sendError() -> history.get(${s}, ${e}) failed`), d3;
      }
      if (h4) {
        const d3 = sa(a2, s, p2);
        await global.Linking.openURL(d3, this.client.name);
      } else {
        const d3 = u3.request.method, y5 = n2 || P3[d3].res;
        this.client.core.relayer.publish(s, p2, y5);
      }
      await this.client.core.history.resolve(l4);
    }), c3(this, "cleanup", async () => {
      const t = [], e = [];
      this.client.session.getAll().forEach((s) => {
        let i3 = false;
        fi(s.expiry) && (i3 = true), this.client.core.crypto.keychain.has(s.topic) || (i3 = true), i3 && t.push(s.topic);
      }), this.client.proposal.getAll().forEach((s) => {
        fi(s.expiryTimestamp) && e.push(s.id);
      }), await Promise.all([...t.map((s) => this.deleteSession({ topic: s })), ...e.map((s) => this.deleteProposal(s))]);
    }), c3(this, "onProviderMessageEvent", async (t) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(t) : await this.onRelayMessage(t);
    }), c3(this, "onRelayEventRequest", async (t) => {
      this.requestQueue.queue.push(t), await this.processRequestsQueue();
    }), c3(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === M3.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = M3.active;
        const t = this.requestQueue.queue.shift();
        if (t) try {
          await this.processRequest(t);
        } catch (e) {
          this.client.logger.warn(e);
        }
      }
      this.requestQueue.state = M3.idle;
    }), c3(this, "processRequest", async (t) => {
      const { topic: e, payload: s, attestation: i3, transportType: r2, encryptedId: n2 } = t, a2 = s.method;
      if (!this.shouldIgnorePairingRequest({ topic: e, requestMethod: a2 })) switch (a2) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: e, payload: s, attestation: i3, encryptedId: n2 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(e, s);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(e, s);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(e, s);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(e, s);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(e, s);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: e, payload: s, attestation: i3, encryptedId: n2, transportType: r2 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(e, s);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: e, payload: s, attestation: i3, encryptedId: n2, transportType: r2 });
        default:
          return this.client.logger.info(`Unsupported request method ${a2}`);
      }
    }), c3(this, "onRelayEventResponse", async (t) => {
      const { topic: e, payload: s, transportType: i3 } = t, r2 = (await this.client.core.history.get(e, s.id)).request.method;
      switch (r2) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(e, s, i3);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(e, s);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(e, s);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(e, s);
        case "wc_sessionPing":
          return this.onSessionPingResponse(e, s);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(e, s);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(e, s);
        default:
          return this.client.logger.info(`Unsupported response method ${r2}`);
      }
    }), c3(this, "onRelayEventUnknownPayload", (t) => {
      const { topic: e } = t, { message: s } = Et("MISSING_OR_INVALID", `Decoded payload on topic ${e} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s);
    }), c3(this, "shouldIgnorePairingRequest", (t) => {
      const { topic: e, requestMethod: s } = t, i3 = this.expectedPairingMethodMap.get(e);
      return !i3 || i3.includes(s) ? false : !!(i3.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), c3(this, "onSessionProposeRequest", async (t) => {
      const { topic: e, payload: s, attestation: i3, encryptedId: r2 } = t, { params: n2, id: a2 } = s;
      try {
        const l4 = this.client.core.eventClient.getEvent({ topic: e });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l4 == null ? void 0 : l4.setError(X2.proposal_listener_not_found)), this.isValidConnect(R3({}, s.params));
        const p2 = n2.expiryTimestamp || ii(P3.wc_sessionPropose.req.ttl), h4 = R3({ id: a2, pairingTopic: e, expiryTimestamp: p2, attestation: i3, encryptedId: r2 }, n2);
        await this.setProposal(a2, h4);
        const u3 = await this.getVerifyContext({ attestationId: i3, hash: zc(JSON.stringify(s)), encryptedId: r2, metadata: h4.proposer.metadata });
        l4 == null ? void 0 : l4.addTrace(Y2.emit_session_proposal), this.client.events.emit("session_proposal", { id: a2, params: h4, verifyContext: u3 });
      } catch (l4) {
        await this.sendError({ id: a2, topic: e, error: l4, rpcOpts: P3.wc_sessionPropose.autoReject }), this.client.logger.error(l4);
      }
    }), c3(this, "onSessionProposeResponse", async (t, e, s) => {
      const { id: i3 } = e;
      if (isJsonRpcResult(e)) {
        const { result: r2 } = e;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r2 });
        const n2 = this.client.proposal.get(i3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n2 });
        const a2 = n2.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a2 });
        const l4 = r2.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l4 });
        const p2 = await this.client.core.crypto.generateSharedKey(a2, l4);
        this.pendingSessions.set(i3, { sessionTopic: p2, pairingTopic: t, proposalId: i3, publicKey: a2 });
        const h4 = await this.client.core.relayer.subscribe(p2, { transportType: s });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h4 }), await this.client.core.pairing.activate({ topic: t });
      } else if (isJsonRpcError(e)) {
        await this.deleteProposal(i3);
        const r2 = ci("session_connect", i3);
        if (this.events.listenerCount(r2) === 0) throw new Error(`emitting ${r2} without any listeners, 954`);
        this.events.emit(r2, { error: e.error });
      }
    }), c3(this, "onSessionSettleRequest", async (t, e) => {
      const { id: s, params: i3 } = e;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: r2, controller: n2, expiry: a2, namespaces: l4, sessionProperties: p2, scopedProperties: h4, sessionConfig: u3 } = e.params, d3 = [...this.pendingSessions.values()].find((m2) => m2.sessionTopic === t);
        if (!d3) return this.client.logger.error(`Pending session not found for topic ${t}`);
        const y5 = this.client.proposal.get(d3.proposalId), w = O3(R3(R3(R3({ topic: t, relay: r2, expiry: a2, namespaces: l4, acknowledged: true, pairingTopic: d3.pairingTopic, requiredNamespaces: y5.requiredNamespaces, optionalNamespaces: y5.optionalNamespaces, controller: n2.publicKey, self: { publicKey: d3.publicKey, metadata: this.client.metadata }, peer: { publicKey: n2.publicKey, metadata: n2.metadata } }, p2 && { sessionProperties: p2 }), h4 && { scopedProperties: h4 }), u3 && { sessionConfig: u3 }), { transportType: ee2.relay });
        await this.client.session.set(w.topic, w), await this.setExpiry(w.topic, w.expiry), await this.client.core.pairing.updateMetadata({ topic: d3.pairingTopic, metadata: w.peer.metadata }), this.client.events.emit("session_connect", { session: w }), this.events.emit(ci("session_connect", d3.proposalId), { session: w }), this.pendingSessions.delete(d3.proposalId), this.deleteProposal(d3.proposalId, false), this.cleanupDuplicatePairings(w), await this.sendResult({ id: e.id, topic: t, result: true });
      } catch (r2) {
        await this.sendError({ id: s, topic: t, error: r2 }), this.client.logger.error(r2);
      }
    }), c3(this, "onSessionSettleResponse", async (t, e) => {
      const { id: s } = e;
      isJsonRpcResult(e) ? (await this.client.session.update(t, { acknowledged: true }), this.events.emit(ci("session_approve", s), {})) : isJsonRpcError(e) && (await this.client.session.delete(t, Kt("USER_DISCONNECTED")), this.events.emit(ci("session_approve", s), { error: e.error }));
    }), c3(this, "onSessionUpdateRequest", async (t, e) => {
      const { params: s, id: i3 } = e;
      try {
        const r2 = `${t}_session_update`, n2 = Ha.get(r2);
        if (n2 && this.isRequestOutOfSync(n2, i3)) {
          this.client.logger.warn(`Discarding out of sync request - ${i3}`), this.sendError({ id: i3, topic: t, error: Kt("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(R3({ topic: t }, s));
        try {
          Ha.set(r2, i3), await this.client.session.update(t, { namespaces: s.namespaces }), await this.sendResult({ id: i3, topic: t, result: true });
        } catch (a2) {
          throw Ha.delete(r2), a2;
        }
        this.client.events.emit("session_update", { id: i3, topic: t, params: s });
      } catch (r2) {
        await this.sendError({ id: i3, topic: t, error: r2 }), this.client.logger.error(r2);
      }
    }), c3(this, "isRequestOutOfSync", (t, e) => e.toString().slice(0, -3) < t.toString().slice(0, -3)), c3(this, "onSessionUpdateResponse", (t, e) => {
      const { id: s } = e, i3 = ci("session_update", s);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(e) ? this.events.emit(ci("session_update", s), {}) : isJsonRpcError(e) && this.events.emit(ci("session_update", s), { error: e.error });
    }), c3(this, "onSessionExtendRequest", async (t, e) => {
      const { id: s } = e;
      try {
        this.isValidExtend({ topic: t }), await this.setExpiry(t, ii(B)), await this.sendResult({ id: s, topic: t, result: true }), this.client.events.emit("session_extend", { id: s, topic: t });
      } catch (i3) {
        await this.sendError({ id: s, topic: t, error: i3 }), this.client.logger.error(i3);
      }
    }), c3(this, "onSessionExtendResponse", (t, e) => {
      const { id: s } = e, i3 = ci("session_extend", s);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(e) ? this.events.emit(ci("session_extend", s), {}) : isJsonRpcError(e) && this.events.emit(ci("session_extend", s), { error: e.error });
    }), c3(this, "onSessionPingRequest", async (t, e) => {
      const { id: s } = e;
      try {
        this.isValidPing({ topic: t }), await this.sendResult({ id: s, topic: t, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s, topic: t });
      } catch (i3) {
        await this.sendError({ id: s, topic: t, error: i3 }), this.client.logger.error(i3);
      }
    }), c3(this, "onSessionPingResponse", (t, e) => {
      const { id: s } = e, i3 = ci("session_ping", s);
      setTimeout(() => {
        if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners 2176`);
        isJsonRpcResult(e) ? this.events.emit(ci("session_ping", s), {}) : isJsonRpcError(e) && this.events.emit(ci("session_ping", s), { error: e.error });
      }, 500);
    }), c3(this, "onSessionDeleteRequest", async (t, e) => {
      const { id: s } = e;
      try {
        this.isValidDisconnect({ topic: t, reason: e.params }), await Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(C2.publish, async () => {
            i3(await this.deleteSession({ topic: t, id: s }));
          });
        }), this.sendResult({ id: s, topic: t, result: true }), this.cleanupPendingSentRequestsForTopic({ topic: t, error: Kt("USER_DISCONNECTED") })]).catch((i3) => this.client.logger.error(i3));
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }), c3(this, "onSessionRequest", async (t) => {
      var e, s, i3;
      const { topic: r2, payload: n2, attestation: a2, encryptedId: l4, transportType: p2 } = t, { id: h4, params: u3 } = n2;
      try {
        await this.isValidRequest(R3({ topic: r2 }, u3));
        const d3 = this.client.session.get(r2), y5 = await this.getVerifyContext({ attestationId: a2, hash: zc(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", u3, h4))), encryptedId: l4, metadata: d3.peer.metadata, transportType: p2 }), w = { id: h4, topic: r2, params: u3, verifyContext: y5 };
        await this.setPendingSessionRequest(w), p2 === ee2.link_mode && (e = d3.peer.metadata.redirect) != null && e.universal && this.client.core.addLinkModeSupportedApp((s = d3.peer.metadata.redirect) == null ? void 0 : s.universal), (i3 = this.client.signConfig) != null && i3.disableRequestQueue ? this.emitSessionRequest(w) : (this.addSessionRequestToSessionRequestQueue(w), this.processSessionRequestQueue());
      } catch (d3) {
        await this.sendError({ id: h4, topic: r2, error: d3 }), this.client.logger.error(d3);
      }
    }), c3(this, "onSessionRequestResponse", (t, e) => {
      const { id: s } = e, i3 = ci("session_request", s);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(e) ? this.events.emit(ci("session_request", s), { result: e.result }) : isJsonRpcError(e) && this.events.emit(ci("session_request", s), { error: e.error });
    }), c3(this, "onSessionEventRequest", async (t, e) => {
      const { id: s, params: i3 } = e;
      try {
        const r2 = `${t}_session_event_${i3.event.name}`, n2 = Ha.get(r2);
        if (n2 && this.isRequestOutOfSync(n2, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`);
          return;
        }
        this.isValidEmit(R3({ topic: t }, i3)), this.client.events.emit("session_event", { id: s, topic: t, params: i3 }), Ha.set(r2, s);
      } catch (r2) {
        await this.sendError({ id: s, topic: t, error: r2 }), this.client.logger.error(r2);
      }
    }), c3(this, "onSessionAuthenticateResponse", (t, e) => {
      const { id: s } = e;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: t, payload: e }), isJsonRpcResult(e) ? this.events.emit(ci("session_request", s), { result: e.result }) : isJsonRpcError(e) && this.events.emit(ci("session_request", s), { error: e.error });
    }), c3(this, "onSessionAuthenticateRequest", async (t) => {
      var e;
      const { topic: s, payload: i3, attestation: r2, encryptedId: n2, transportType: a2 } = t;
      try {
        const { requester: l4, authPayload: p2, expiryTimestamp: h4 } = i3.params, u3 = await this.getVerifyContext({ attestationId: r2, hash: zc(JSON.stringify(i3)), encryptedId: n2, metadata: l4.metadata, transportType: a2 }), d3 = { requester: l4, pairingTopic: s, id: i3.id, authPayload: p2, verifyContext: u3, expiryTimestamp: h4 };
        await this.setAuthRequest(i3.id, { request: d3, pairingTopic: s, transportType: a2 }), a2 === ee2.link_mode && (e = l4.metadata.redirect) != null && e.universal && this.client.core.addLinkModeSupportedApp(l4.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s, params: i3.params, id: i3.id, verifyContext: u3 });
      } catch (l4) {
        this.client.logger.error(l4);
        const p2 = i3.params.requester.publicKey, h4 = await this.client.core.crypto.generateKeyPair(), u3 = this.getAppLinkIfEnabled(i3.params.requester.metadata, a2), d3 = { type: ee, receiverPublicKey: p2, senderPublicKey: h4 };
        await this.sendError({ id: i3.id, topic: s, error: l4, encodeOpts: d3, rpcOpts: P3.wc_sessionAuthenticate.autoReject, appLink: u3 });
      }
    }), c3(this, "addSessionRequestToSessionRequestQueue", (t) => {
      this.sessionRequestQueue.queue.push(t);
    }), c3(this, "cleanupAfterResponse", (t) => {
      this.deletePendingSessionRequest(t.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = M3.idle, this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay));
    }), c3(this, "cleanupPendingSentRequestsForTopic", ({ topic: t, error: e }) => {
      const s = this.client.core.history.pending;
      s.length > 0 && s.filter((i3) => i3.topic === t && i3.request.method === "wc_sessionRequest").forEach((i3) => {
        const r2 = i3.request.id, n2 = ci("session_request", r2);
        if (this.events.listenerCount(n2) === 0) throw new Error(`emitting ${n2} without any listeners`);
        this.events.emit(ci("session_request", i3.request.id), { error: e });
      });
    }), c3(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === M3.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const t = this.sessionRequestQueue.queue[0];
      if (!t) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.emitSessionRequest(t);
      } catch (e) {
        this.client.logger.error(e);
      }
    }), c3(this, "emitSessionRequest", (t) => {
      if (this.emittedSessionRequests.has(t.id)) {
        this.client.logger.warn({ id: t.id }, `Skipping emitting \`session_request\` event for duplicate request. id: ${t.id}`);
        return;
      }
      this.sessionRequestQueue.state = M3.active, this.emittedSessionRequests.add(t.id), this.client.events.emit("session_request", t);
    }), c3(this, "onPairingCreated", (t) => {
      if (t.methods && this.expectedPairingMethodMap.set(t.topic, t.methods), t.active) return;
      const e = this.client.proposal.getAll().find((s) => s.pairingTopic === t.topic);
      e && this.onSessionProposeRequest({ topic: t.topic, payload: formatJsonRpcRequest("wc_sessionPropose", O3(R3({}, e), { requiredNamespaces: e.requiredNamespaces, optionalNamespaces: e.optionalNamespaces, relays: e.relays, proposer: e.proposer, sessionProperties: e.sessionProperties, scopedProperties: e.scopedProperties }), e.id), attestation: e.attestation, encryptedId: e.encryptedId });
    }), c3(this, "isValidConnect", async (t) => {
      if (!Aa(t)) {
        const { message: l4 } = Et("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t)}`);
        throw new Error(l4);
      }
      const { pairingTopic: e, requiredNamespaces: s, optionalNamespaces: i3, sessionProperties: r2, scopedProperties: n2, relays: a2 } = t;
      if (kt(e) || await this.isValidPairingTopic(e), !Ba(a2, true)) {
        const { message: l4 } = Et("MISSING_OR_INVALID", `connect() relays: ${a2}`);
        throw new Error(l4);
      }
      if (!kt(s) && Ve(s) !== 0) {
        const l4 = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
        ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(l4) : this.client.logger.warn(l4), this.validateNamespaces(s, "requiredNamespaces");
      }
      if (!kt(i3) && Ve(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), kt(r2) || this.validateSessionProps(r2, "sessionProperties"), !kt(n2)) {
        this.validateSessionProps(n2, "scopedProperties");
        const l4 = Object.keys(s || {}).concat(Object.keys(i3 || {}));
        if (!Object.keys(n2).every((p2) => l4.includes(p2.split(":")[0]))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(n2)}, required/optional namespaces: ${JSON.stringify(l4)}`);
      }
    }), c3(this, "validateNamespaces", (t, e) => {
      const s = Ea(t, "connect()", e);
      if (s) throw new Error(s.message);
    }), c3(this, "isValidApprove", async (t) => {
      if (!Aa(t)) throw new Error(Et("MISSING_OR_INVALID", `approve() params: ${t}`).message);
      const { id: e, namespaces: s, relayProtocol: i3, sessionProperties: r2, scopedProperties: n2 } = t;
      this.checkRecentlyDeleted(e), await this.isValidProposalId(e);
      const a2 = this.client.proposal.get(e), l4 = is(s, "approve()");
      if (l4) throw new Error(l4.message);
      const p2 = cs(a2.requiredNamespaces, s, "approve()");
      if (p2) throw new Error(p2.message);
      if (!it(i3, true)) {
        const { message: h4 } = Et("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(h4);
      }
      if (kt(r2) || this.validateSessionProps(r2, "sessionProperties"), !kt(n2)) {
        this.validateSessionProps(n2, "scopedProperties");
        const h4 = new Set(Object.keys(s));
        if (!Object.keys(n2).every((u3) => h4.has(u3.split(":")[0]))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(n2)}, approved namespaces: ${Array.from(h4).join(", ")}`);
      }
    }), c3(this, "isValidReject", async (t) => {
      if (!Aa(t)) {
        const { message: i3 } = Et("MISSING_OR_INVALID", `reject() params: ${t}`);
        throw new Error(i3);
      }
      const { id: e, reason: s } = t;
      if (this.checkRecentlyDeleted(e), await this.isValidProposalId(e), !Sa(s)) {
        const { message: i3 } = Et("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s)}`);
        throw new Error(i3);
      }
    }), c3(this, "isValidSessionSettleRequest", (t) => {
      if (!Aa(t)) {
        const { message: l4 } = Et("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t}`);
        throw new Error(l4);
      }
      const { relay: e, controller: s, namespaces: i3, expiry: r2 } = t;
      if (!fs(e)) {
        const { message: l4 } = Et("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l4);
      }
      const n2 = va(s, "onSessionSettleRequest()");
      if (n2) throw new Error(n2.message);
      const a2 = is(i3, "onSessionSettleRequest()");
      if (a2) throw new Error(a2.message);
      if (fi(r2)) {
        const { message: l4 } = Et("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l4);
      }
    }), c3(this, "isValidUpdate", async (t) => {
      if (!Aa(t)) {
        const { message: a2 } = Et("MISSING_OR_INVALID", `update() params: ${t}`);
        throw new Error(a2);
      }
      const { topic: e, namespaces: s } = t;
      this.checkRecentlyDeleted(e), await this.isValidSessionTopic(e);
      const i3 = this.client.session.get(e), r2 = is(s, "update()");
      if (r2) throw new Error(r2.message);
      const n2 = cs(i3.requiredNamespaces, s, "update()");
      if (n2) throw new Error(n2.message);
    }), c3(this, "isValidExtend", async (t) => {
      if (!Aa(t)) {
        const { message: s } = Et("MISSING_OR_INVALID", `extend() params: ${t}`);
        throw new Error(s);
      }
      const { topic: e } = t;
      this.checkRecentlyDeleted(e), await this.isValidSessionTopic(e);
    }), c3(this, "isValidRequest", async (t) => {
      if (!Aa(t)) {
        const { message: a2 } = Et("MISSING_OR_INVALID", `request() params: ${t}`);
        throw new Error(a2);
      }
      const { topic: e, request: s, chainId: i3, expiry: r2 } = t;
      this.checkRecentlyDeleted(e), await this.isValidSessionTopic(e);
      const { namespaces: n2 } = this.client.session.get(e);
      if (!_a(n2, i3)) {
        const { message: a2 } = Et("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a2);
      }
      if (!Na(s)) {
        const { message: a2 } = Et("MISSING_OR_INVALID", `request() ${JSON.stringify(s)}`);
        throw new Error(a2);
      }
      if (!Ta(n2, i3, s.method)) {
        const { message: a2 } = Et("MISSING_OR_INVALID", `request() method: ${s.method}`);
        throw new Error(a2);
      }
      if (r2 && !La(r2, _e2)) {
        const { message: a2 } = Et("MISSING_OR_INVALID", `request() expiry: ${r2}. Expiry must be a number (in seconds) between ${_e2.min} and ${_e2.max}`);
        throw new Error(a2);
      }
    }), c3(this, "isValidRespond", async (t) => {
      var e;
      if (!Aa(t)) {
        const { message: r2 } = Et("MISSING_OR_INVALID", `respond() params: ${t}`);
        throw new Error(r2);
      }
      const { topic: s, response: i3 } = t;
      try {
        await this.isValidSessionTopic(s);
      } catch (r2) {
        throw (e = t == null ? void 0 : t.response) != null && e.id && this.cleanupAfterResponse(t), r2;
      }
      if (!Oa(i3)) {
        const { message: r2 } = Et("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i3)}`);
        throw new Error(r2);
      }
    }), c3(this, "isValidPing", async (t) => {
      if (!Aa(t)) {
        const { message: s } = Et("MISSING_OR_INVALID", `ping() params: ${t}`);
        throw new Error(s);
      }
      const { topic: e } = t;
      await this.isValidSessionOrPairingTopic(e);
    }), c3(this, "isValidEmit", async (t) => {
      if (!Aa(t)) {
        const { message: n2 } = Et("MISSING_OR_INVALID", `emit() params: ${t}`);
        throw new Error(n2);
      }
      const { topic: e, event: s, chainId: i3 } = t;
      await this.isValidSessionTopic(e);
      const { namespaces: r2 } = this.client.session.get(e);
      if (!_a(r2, i3)) {
        const { message: n2 } = Et("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(n2);
      }
      if (!Ua(s)) {
        const { message: n2 } = Et("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(n2);
      }
      if (!Ra(r2, i3, s.name)) {
        const { message: n2 } = Et("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(n2);
      }
    }), c3(this, "isValidDisconnect", async (t) => {
      if (!Aa(t)) {
        const { message: s } = Et("MISSING_OR_INVALID", `disconnect() params: ${t}`);
        throw new Error(s);
      }
      const { topic: e } = t;
      await this.isValidSessionOrPairingTopic(e);
    }), c3(this, "isValidAuthenticate", (t) => {
      const { chains: e, uri: s, domain: i3, nonce: r2 } = t;
      if (!Array.isArray(e) || e.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!it(s, false)) throw new Error("uri is required parameter");
      if (!it(i3, false)) throw new Error("domain is required parameter");
      if (!it(r2, false)) throw new Error("nonce is required parameter");
      if ([...new Set(e.map((a2) => Fe(a2).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: n2 } = Fe(e[0]);
      if (n2 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), c3(this, "getVerifyContext", async (t) => {
      const { attestationId: e, hash: s, encryptedId: i3, metadata: r2, transportType: n2 } = t, a2 = { verified: { verifyUrl: r2.verifyUrl || be2, validation: "UNKNOWN", origin: r2.url || "" } };
      try {
        if (n2 === ee2.link_mode) {
          const p2 = this.getAppLinkIfEnabled(r2, n2);
          return a2.verified.validation = p2 && new URL(p2).origin === new URL(r2.url).origin ? "VALID" : "INVALID", a2;
        }
        const l4 = await this.client.core.verify.resolve({ attestationId: e, hash: s, encryptedId: i3, verifyUrl: r2.verifyUrl });
        l4 && (a2.verified.origin = l4.origin, a2.verified.isScam = l4.isScam, a2.verified.validation = l4.origin === new URL(r2.url).origin ? "VALID" : "INVALID");
      } catch (l4) {
        this.client.logger.warn(l4);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a2)}`), a2;
    }), c3(this, "validateSessionProps", (t, e) => {
      Object.values(t).forEach((s, i3) => {
        if (s == null) {
          const { message: r2 } = Et("MISSING_OR_INVALID", `${e} must contain an existing value for each key. Received: ${s} for key ${Object.keys(t)[i3]}`);
          throw new Error(r2);
        }
      });
    }), c3(this, "getPendingAuthRequest", (t) => {
      const e = this.client.auth.requests.get(t);
      return typeof e == "object" ? e : void 0;
    }), c3(this, "addToRecentlyDeleted", (t, e) => {
      if (this.recentlyDeletedMap.set(t, e), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s = 0;
        const i3 = this.recentlyDeletedLimit / 2;
        for (const r2 of this.recentlyDeletedMap.keys()) {
          if (s++ >= i3) break;
          this.recentlyDeletedMap.delete(r2);
        }
      }
    }), c3(this, "checkRecentlyDeleted", (t) => {
      const e = this.recentlyDeletedMap.get(t);
      if (e) {
        const { message: s } = Et("MISSING_OR_INVALID", `Record was recently deleted - ${e}: ${t}`);
        throw new Error(s);
      }
    }), c3(this, "isLinkModeEnabled", (t, e) => {
      var s, i3, r2, n2, a2, l4, p2, h4, u3;
      return !t || e !== ee2.link_mode ? false : ((i3 = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i3.linkMode) === true && ((n2 = (r2 = this.client.metadata) == null ? void 0 : r2.redirect) == null ? void 0 : n2.universal) !== void 0 && ((l4 = (a2 = this.client.metadata) == null ? void 0 : a2.redirect) == null ? void 0 : l4.universal) !== "" && ((p2 = t == null ? void 0 : t.redirect) == null ? void 0 : p2.universal) !== void 0 && ((h4 = t == null ? void 0 : t.redirect) == null ? void 0 : h4.universal) !== "" && ((u3 = t == null ? void 0 : t.redirect) == null ? void 0 : u3.linkMode) === true && this.client.core.linkModeSupportedApps.includes(t.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }), c3(this, "getAppLinkIfEnabled", (t, e) => {
      var s;
      return this.isLinkModeEnabled(t, e) ? (s = t == null ? void 0 : t.redirect) == null ? void 0 : s.universal : void 0;
    }), c3(this, "handleLinkModeMessage", ({ url: t }) => {
      if (!t || !t.includes("wc_ev") || !t.includes("topic")) return;
      const e = li(t, "topic") || "", s = decodeURIComponent(li(t, "wc_ev") || ""), i3 = this.client.session.keys.includes(e);
      i3 && this.client.session.update(e, { transportType: ee2.link_mode }), this.client.core.dispatchEnvelope({ topic: e, message: s, sessionExists: i3 });
    }), c3(this, "registerLinkModeListeners", async () => {
      var t;
      if (hi() || Bt() && (t = this.client.metadata.redirect) != null && t.linkMode) {
        const e = global == null ? void 0 : global.Linking;
        if (typeof e < "u") {
          e.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s = await e.getInitialURL();
          s && setTimeout(() => {
            this.handleLinkModeMessage({ url: s });
          }, 50);
        }
      }
    }), c3(this, "getTVFParams", (t, e, s) => {
      var i3, r2, n2;
      if (!((i3 = e.request) != null && i3.method)) return {};
      const a2 = { correlationId: t, rpcMethods: [e.request.method], chainId: e.chainId };
      try {
        const l4 = this.extractTxHashesFromResult(e.request, s);
        a2.txHashes = l4, a2.contractAddresses = this.isValidContractData(e.request.params) ? [(n2 = (r2 = e.request.params) == null ? void 0 : r2[0]) == null ? void 0 : n2.to] : [];
      } catch (l4) {
        this.client.logger.warn("Error getting TVF params", l4);
      }
      return a2;
    }), c3(this, "isValidContractData", (t) => {
      var e;
      if (!t) return false;
      try {
        const s = (t == null ? void 0 : t.data) || ((e = t == null ? void 0 : t[0]) == null ? void 0 : e.data);
        if (!s.startsWith("0x")) return false;
        const i3 = s.slice(2);
        return /^[0-9a-fA-F]*$/.test(i3) ? i3.length % 2 === 0 : false;
      } catch {
      }
      return false;
    }), c3(this, "extractTxHashesFromResult", (t, e) => {
      var s;
      try {
        if (!e) return [];
        const i3 = t.method, r2 = yt[i3];
        if (i3 === "sui_signTransaction") return [ff(e.transactionBytes)];
        if (i3 === "near_signTransaction") return [cf(e)];
        if (i3 === "near_signTransactions") return e.map((a2) => cf(a2));
        if (i3 === "xrpl_signTransactionFor" || i3 === "xrpl_signTransaction") return [(s = e.tx_json) == null ? void 0 : s.hash];
        if (i3 === "polkadot_signTransaction") return [Ka({ transaction: t.params.transactionPayload, signature: e.signature })];
        if (i3 === "algo_signTxn") return me(e) ? e.map((a2) => af(a2)) : [af(e)];
        if (i3 === "cosmos_signDirect") return [uf(e)];
        if (typeof e == "string") return [e];
        const n2 = e[r2.key];
        if (me(n2)) return i3 === "solana_signAllTransactions" ? n2.map((a2) => sf(a2)) : n2;
        if (typeof n2 == "string") return [n2];
      } catch (i3) {
        this.client.logger.warn("Error extracting tx hashes from result", i3);
      }
      return [];
    });
  }
  async processPendingMessageEvents() {
    try {
      const o2 = this.client.session.keys, t = this.client.core.relayer.messages.getWithoutAck(o2);
      for (const [e, s] of Object.entries(t)) for (const i3 of s) try {
        await this.onProviderMessageEvent({ topic: e, message: i3, publishedAt: Date.now() });
      } catch {
        this.client.logger.warn(`Error processing pending message event for topic: ${e}, message: ${i3}`);
      }
    } catch (o2) {
      this.client.logger.warn("processPendingMessageEvents failed", o2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: o2 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(o2);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(C2.message, (o2) => {
      this.onProviderMessageEvent(o2);
    });
  }
  async onRelayMessage(o2) {
    const { topic: t, message: e, attestation: s, transportType: i3 } = o2, { publicKey: r2 } = this.client.auth.authKeys.keys.includes(pe3) ? this.client.auth.authKeys.get(pe3) : { responseTopic: void 0, publicKey: void 0 };
    try {
      const n2 = await this.client.core.crypto.decode(t, e, { receiverPublicKey: r2, encoding: i3 === ee2.link_mode ? De : Qt });
      isJsonRpcRequest(n2) ? (this.client.core.history.set(t, n2), await this.onRelayEventRequest({ topic: t, payload: n2, attestation: s, transportType: i3, encryptedId: zc(e) })) : isJsonRpcResponse(n2) ? (await this.client.core.history.resolve(n2), await this.onRelayEventResponse({ topic: t, payload: n2, transportType: i3 }), this.client.core.history.delete(t, n2.id)) : await this.onRelayEventUnknownPayload({ topic: t, payload: n2, transportType: i3 }), await this.client.core.relayer.messages.ack(t, e);
    } catch (n2) {
      this.client.logger.error(n2);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(q.expired, async (o2) => {
      const { topic: t, id: e } = si(o2.target);
      if (e && this.client.pendingRequest.keys.includes(e)) return await this.deletePendingSessionRequest(e, Et("EXPIRED"), true);
      if (e && this.client.auth.requests.keys.includes(e)) return await this.deletePendingAuthRequest(e, Et("EXPIRED"), true);
      t ? this.client.session.keys.includes(t) && (await this.deleteSession({ topic: t, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: t })) : e && (await this.deleteProposal(e, true), this.client.events.emit("proposal_expire", { id: e }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(ae2.create, (o2) => this.onPairingCreated(o2)), this.client.core.pairing.events.on(ae2.delete, (o2) => {
      this.addToRecentlyDeleted(o2.topic, "pairing");
    });
  }
  isValidPairingTopic(o2) {
    if (!it(o2, false)) {
      const { message: t } = Et("MISSING_OR_INVALID", `pairing topic should be a string: ${o2}`);
      throw new Error(t);
    }
    if (!this.client.core.pairing.pairings.keys.includes(o2)) {
      const { message: t } = Et("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o2}`);
      throw new Error(t);
    }
    if (fi(this.client.core.pairing.pairings.get(o2).expiry)) {
      const { message: t } = Et("EXPIRED", `pairing topic: ${o2}`);
      throw new Error(t);
    }
  }
  async isValidSessionTopic(o2) {
    if (!it(o2, false)) {
      const { message: t } = Et("MISSING_OR_INVALID", `session topic should be a string: ${o2}`);
      throw new Error(t);
    }
    if (this.checkRecentlyDeleted(o2), !this.client.session.keys.includes(o2)) {
      const { message: t } = Et("NO_MATCHING_KEY", `session topic doesn't exist: ${o2}`);
      throw new Error(t);
    }
    if (fi(this.client.session.get(o2).expiry)) {
      await this.deleteSession({ topic: o2 });
      const { message: t } = Et("EXPIRED", `session topic: ${o2}`);
      throw new Error(t);
    }
    if (!this.client.core.crypto.keychain.has(o2)) {
      const { message: t } = Et("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o2}`);
      throw await this.deleteSession({ topic: o2 }), new Error(t);
    }
  }
  async isValidSessionOrPairingTopic(o2) {
    if (this.checkRecentlyDeleted(o2), this.client.session.keys.includes(o2)) await this.isValidSessionTopic(o2);
    else if (this.client.core.pairing.pairings.keys.includes(o2)) this.isValidPairingTopic(o2);
    else if (it(o2, false)) {
      const { message: t } = Et("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o2}`);
      throw new Error(t);
    } else {
      const { message: t } = Et("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o2}`);
      throw new Error(t);
    }
  }
  async isValidProposalId(o2) {
    if (!Ia(o2)) {
      const { message: t } = Et("MISSING_OR_INVALID", `proposal id should be a number: ${o2}`);
      throw new Error(t);
    }
    if (!this.client.proposal.keys.includes(o2)) {
      const { message: t } = Et("NO_MATCHING_KEY", `proposal id doesn't exist: ${o2}`);
      throw new Error(t);
    }
    if (fi(this.client.proposal.get(o2).expiryTimestamp)) {
      await this.deleteProposal(o2);
      const { message: t } = Et("EXPIRED", `proposal id: ${o2}`);
      throw new Error(t);
    }
  }
};
var ks2 = class extends Ui2 {
  constructor(o2, t) {
    super(o2, t, dt2, we3), this.core = o2, this.logger = t;
  }
};
var It3 = class extends Ui2 {
  constructor(o2, t) {
    super(o2, t, ut2, we3), this.core = o2, this.logger = t;
  }
};
var Ds = class extends Ui2 {
  constructor(o2, t) {
    super(o2, t, wt2, we3, (e) => e.id), this.core = o2, this.logger = t;
  }
};
var Ls2 = class extends Ui2 {
  constructor(o2, t) {
    super(o2, t, Et2, le3, () => pe3), this.core = o2, this.logger = t;
  }
};
var Ms2 = class extends Ui2 {
  constructor(o2, t) {
    super(o2, t, St3, le3), this.core = o2, this.logger = t;
  }
};
var $s2 = class extends Ui2 {
  constructor(o2, t) {
    super(o2, t, Rt3, le3, (e) => e.id), this.core = o2, this.logger = t;
  }
};
var Ks2 = Object.defineProperty;
var Us = (E4, o2, t) => o2 in E4 ? Ks2(E4, o2, { enumerable: true, configurable: true, writable: true, value: t }) : E4[o2] = t;
var Ke3 = (E4, o2, t) => Us(E4, typeof o2 != "symbol" ? o2 + "" : o2, t);
var Gs = class {
  constructor(o2, t) {
    this.core = o2, this.logger = t, Ke3(this, "authKeys"), Ke3(this, "pairingTopics"), Ke3(this, "requests"), this.authKeys = new Ls2(this.core, this.logger), this.pairingTopics = new Ms2(this.core, this.logger), this.requests = new $s2(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var js2 = Object.defineProperty;
var Fs = (E4, o2, t) => o2 in E4 ? js2(E4, o2, { enumerable: true, configurable: true, writable: true, value: t }) : E4[o2] = t;
var f5 = (E4, o2, t) => Fs(E4, typeof o2 != "symbol" ? o2 + "" : o2, t);
var fe3 = class _fe extends J {
  constructor(o2) {
    super(o2), f5(this, "protocol", Ce2), f5(this, "version", ke2), f5(this, "name", me3.name), f5(this, "metadata"), f5(this, "core"), f5(this, "logger"), f5(this, "events", new import_events4.EventEmitter()), f5(this, "engine"), f5(this, "session"), f5(this, "proposal"), f5(this, "pendingRequest"), f5(this, "auth"), f5(this, "signConfig"), f5(this, "on", (e, s) => this.events.on(e, s)), f5(this, "once", (e, s) => this.events.once(e, s)), f5(this, "off", (e, s) => this.events.off(e, s)), f5(this, "removeListener", (e, s) => this.events.removeListener(e, s)), f5(this, "removeAllListeners", (e) => this.events.removeAllListeners(e)), f5(this, "connect", async (e) => {
      try {
        return await this.engine.connect(e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), f5(this, "pair", async (e) => {
      try {
        return await this.engine.pair(e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), f5(this, "approve", async (e) => {
      try {
        return await this.engine.approve(e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), f5(this, "reject", async (e) => {
      try {
        return await this.engine.reject(e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), f5(this, "update", async (e) => {
      try {
        return await this.engine.update(e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), f5(this, "extend", async (e) => {
      try {
        return await this.engine.extend(e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), f5(this, "request", async (e) => {
      try {
        return await this.engine.request(e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), f5(this, "respond", async (e) => {
      try {
        return await this.engine.respond(e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), f5(this, "ping", async (e) => {
      try {
        return await this.engine.ping(e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), f5(this, "emit", async (e) => {
      try {
        return await this.engine.emit(e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), f5(this, "disconnect", async (e) => {
      try {
        return await this.engine.disconnect(e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), f5(this, "find", (e) => {
      try {
        return this.engine.find(e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), f5(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }), f5(this, "authenticate", async (e, s) => {
      try {
        return await this.engine.authenticate(e, s);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }), f5(this, "formatAuthMessage", (e) => {
      try {
        return this.engine.formatAuthMessage(e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), f5(this, "approveSessionAuthenticate", async (e) => {
      try {
        return await this.engine.approveSessionAuthenticate(e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), f5(this, "rejectSessionAuthenticate", async (e) => {
      try {
        return await this.engine.rejectSessionAuthenticate(e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), this.name = (o2 == null ? void 0 : o2.name) || me3.name, this.metadata = Ks(o2 == null ? void 0 : o2.metadata), this.signConfig = o2 == null ? void 0 : o2.signConfig;
    const t = typeof (o2 == null ? void 0 : o2.logger) < "u" && typeof (o2 == null ? void 0 : o2.logger) != "string" ? o2.logger : (0, import_pino.default)(k({ level: (o2 == null ? void 0 : o2.logger) || me3.logger }));
    this.core = (o2 == null ? void 0 : o2.core) || new ta2(o2), this.logger = E(t, this.name), this.session = new It3(this.core, this.logger), this.proposal = new ks2(this.core, this.logger), this.pendingRequest = new Ds(this.core, this.logger), this.engine = new Cs2(this), this.auth = new Gs(this.core, this.logger);
  }
  static async init(o2) {
    const t = new _fe(o2);
    return await t.initialize(), t;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success");
    } catch (o2) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o2.message), o2;
    }
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events5 = __toESM(require_events());
var it2 = "error";
var Lt3 = "wss://relay.walletconnect.org";
var Mt3 = "wc";
var Bt3 = "universal_provider";
var F3 = `${Mt3}@2:${Bt3}:`;
var rt3 = "https://rpc.walletconnect.org/v1/";
var nt2 = "generic";
var Gt3 = `${rt3}bundler`;
var l3 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
function W3(s) {
  return s == null || typeof s != "object" && typeof s != "function";
}
function at2(s) {
  return Object.getOwnPropertySymbols(s).filter((t) => Object.prototype.propertyIsEnumerable.call(s, t));
}
function ct3(s) {
  return s == null ? s === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(s);
}
var Jt3 = "[object RegExp]";
var ot2 = "[object String]";
var ht2 = "[object Number]";
var pt3 = "[object Boolean]";
var dt3 = "[object Arguments]";
var zt3 = "[object Symbol]";
var kt3 = "[object Date]";
var Wt3 = "[object Map]";
var Kt3 = "[object Set]";
var Vt3 = "[object Array]";
var Xt3 = "[object ArrayBuffer]";
var Yt3 = "[object Object]";
var Qt3 = "[object DataView]";
var Zt3 = "[object Uint8Array]";
var Tt3 = "[object Uint8ClampedArray]";
var te2 = "[object Uint16Array]";
var ee3 = "[object Uint32Array]";
var se2 = "[object Int8Array]";
var ie3 = "[object Int16Array]";
var re2 = "[object Int32Array]";
var ne2 = "[object Float32Array]";
var ae3 = "[object Float64Array]";
function K4(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function ce3(s, t) {
  return I2(s, void 0, s, /* @__PURE__ */ new Map(), t);
}
function I2(s, t, e, i3 = /* @__PURE__ */ new Map(), n2 = void 0) {
  const a2 = n2 == null ? void 0 : n2(s, t, e, i3);
  if (a2 != null) return a2;
  if (W3(s)) return s;
  if (i3.has(s)) return i3.get(s);
  if (Array.isArray(s)) {
    const r2 = new Array(s.length);
    i3.set(s, r2);
    for (let c4 = 0; c4 < s.length; c4++) r2[c4] = I2(s[c4], c4, e, i3, n2);
    return Object.hasOwn(s, "index") && (r2.index = s.index), Object.hasOwn(s, "input") && (r2.input = s.input), r2;
  }
  if (s instanceof Date) return new Date(s.getTime());
  if (s instanceof RegExp) {
    const r2 = new RegExp(s.source, s.flags);
    return r2.lastIndex = s.lastIndex, r2;
  }
  if (s instanceof Map) {
    const r2 = /* @__PURE__ */ new Map();
    i3.set(s, r2);
    for (const [c4, o2] of s) r2.set(c4, I2(o2, c4, e, i3, n2));
    return r2;
  }
  if (s instanceof Set) {
    const r2 = /* @__PURE__ */ new Set();
    i3.set(s, r2);
    for (const c4 of s) r2.add(I2(c4, void 0, e, i3, n2));
    return r2;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(s)) return s.subarray();
  if (K4(s)) {
    const r2 = new (Object.getPrototypeOf(s)).constructor(s.length);
    i3.set(s, r2);
    for (let c4 = 0; c4 < s.length; c4++) r2[c4] = I2(s[c4], c4, e, i3, n2);
    return r2;
  }
  if (s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
  if (s instanceof DataView) {
    const r2 = new DataView(s.buffer.slice(0), s.byteOffset, s.byteLength);
    return i3.set(s, r2), y4(r2, s, e, i3, n2), r2;
  }
  if (typeof File < "u" && s instanceof File) {
    const r2 = new File([s], s.name, { type: s.type });
    return i3.set(s, r2), y4(r2, s, e, i3, n2), r2;
  }
  if (s instanceof Blob) {
    const r2 = new Blob([s], { type: s.type });
    return i3.set(s, r2), y4(r2, s, e, i3, n2), r2;
  }
  if (s instanceof Error) {
    const r2 = new s.constructor();
    return i3.set(s, r2), r2.message = s.message, r2.name = s.name, r2.stack = s.stack, r2.cause = s.cause, y4(r2, s, e, i3, n2), r2;
  }
  if (typeof s == "object" && oe2(s)) {
    const r2 = Object.create(Object.getPrototypeOf(s));
    return i3.set(s, r2), y4(r2, s, e, i3, n2), r2;
  }
  return s;
}
function y4(s, t, e = s, i3, n2) {
  const a2 = [...Object.keys(t), ...at2(t)];
  for (let r2 = 0; r2 < a2.length; r2++) {
    const c4 = a2[r2], o2 = Object.getOwnPropertyDescriptor(s, c4);
    (o2 == null || o2.writable) && (s[c4] = I2(t[c4], c4, e, i3, n2));
  }
}
function oe2(s) {
  switch (ct3(s)) {
    case dt3:
    case Vt3:
    case Xt3:
    case Qt3:
    case pt3:
    case kt3:
    case ne2:
    case ae3:
    case se2:
    case ie3:
    case re2:
    case Wt3:
    case ht2:
    case Yt3:
    case Jt3:
    case Kt3:
    case ot2:
    case zt3:
    case Zt3:
    case Tt3:
    case te2:
    case ee3:
      return true;
    default:
      return false;
  }
}
function he3(s, t) {
  return ce3(s, (e, i3, n2, a2) => {
    const r2 = t == null ? void 0 : t(e, i3, n2, a2);
    if (r2 != null) return r2;
    if (typeof s == "object") switch (Object.prototype.toString.call(s)) {
      case ht2:
      case ot2:
      case pt3: {
        const c4 = new s.constructor(s == null ? void 0 : s.valueOf());
        return y4(c4, s), c4;
      }
      case dt3: {
        const c4 = {};
        return y4(c4, s), c4.length = s.length, c4[Symbol.iterator] = s[Symbol.iterator], c4;
      }
      default:
        return;
    }
  });
}
function ut3(s) {
  return he3(s);
}
function lt3(s) {
  return s !== null && typeof s == "object" && ct3(s) === "[object Arguments]";
}
function ft2(s) {
  return typeof s == "object" && s !== null;
}
function pe4() {
}
function de2(s) {
  return K4(s);
}
function ue2(s) {
  var _a2;
  if (typeof s != "object" || s == null) return false;
  if (Object.getPrototypeOf(s) === null) return true;
  if (Object.prototype.toString.call(s) !== "[object Object]") {
    const e = s[Symbol.toStringTag];
    return e == null || !((_a2 = Object.getOwnPropertyDescriptor(s, Symbol.toStringTag)) == null ? void 0 : _a2.writable) ? false : s.toString() === `[object ${e}]`;
  }
  let t = s;
  for (; Object.getPrototypeOf(t) !== null; ) t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(s) === t;
}
function le4(s) {
  if (W3(s)) return s;
  if (Array.isArray(s) || K4(s) || s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
  const t = Object.getPrototypeOf(s), e = t.constructor;
  if (s instanceof Date || s instanceof Map || s instanceof Set) return new e(s);
  if (s instanceof RegExp) {
    const i3 = new e(s);
    return i3.lastIndex = s.lastIndex, i3;
  }
  if (s instanceof DataView) return new e(s.buffer.slice(0));
  if (s instanceof Error) {
    const i3 = new e(s.message);
    return i3.stack = s.stack, i3.name = s.name, i3.cause = s.cause, i3;
  }
  if (typeof File < "u" && s instanceof File) return new e([s], s.name, { type: s.type, lastModified: s.lastModified });
  if (typeof s == "object") {
    const i3 = Object.create(t);
    return Object.assign(i3, s);
  }
  return s;
}
function fe4(s, ...t) {
  const e = t.slice(0, -1), i3 = t[t.length - 1];
  let n2 = s;
  for (let a2 = 0; a2 < e.length; a2++) {
    const r2 = e[a2];
    n2 = U3(n2, r2, i3, /* @__PURE__ */ new Map());
  }
  return n2;
}
function U3(s, t, e, i3) {
  if (W3(s) && (s = Object(s)), t == null || typeof t != "object") return s;
  if (i3.has(t)) return le4(i3.get(t));
  if (i3.set(t, s), Array.isArray(t)) {
    t = t.slice();
    for (let a2 = 0; a2 < t.length; a2++) t[a2] = t[a2] ?? void 0;
  }
  const n2 = [...Object.keys(t), ...at2(t)];
  for (let a2 = 0; a2 < n2.length; a2++) {
    const r2 = n2[a2];
    let c4 = t[r2], o2 = s[r2];
    if (lt3(c4) && (c4 = { ...c4 }), lt3(o2) && (o2 = { ...o2 }), typeof Buffer < "u" && Buffer.isBuffer(c4) && (c4 = ut3(c4)), Array.isArray(c4)) if (typeof o2 == "object" && o2 != null) {
      const v3 = [], w = Reflect.ownKeys(o2);
      for (let P4 = 0; P4 < w.length; P4++) {
        const d3 = w[P4];
        v3[d3] = o2[d3];
      }
      o2 = v3;
    } else o2 = [];
    const p2 = e(o2, c4, r2, s, t, i3);
    p2 != null ? s[r2] = p2 : Array.isArray(c4) || ft2(o2) && ft2(c4) ? s[r2] = U3(o2, c4, e, i3) : o2 == null && ue2(c4) ? s[r2] = U3({}, c4, e, i3) : o2 == null && de2(c4) ? s[r2] = ut3(c4) : (o2 === void 0 || c4 !== void 0) && (s[r2] = c4);
  }
  return s;
}
function me4(s, ...t) {
  return fe4(s, ...t, pe4);
}
var ve3 = Object.defineProperty;
var ge2 = Object.defineProperties;
var Pe3 = Object.getOwnPropertyDescriptors;
var mt3 = Object.getOwnPropertySymbols;
var we4 = Object.prototype.hasOwnProperty;
var ye3 = Object.prototype.propertyIsEnumerable;
var vt3 = (s, t, e) => t in s ? ve3(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var x3 = (s, t) => {
  for (var e in t || (t = {})) we4.call(t, e) && vt3(s, e, t[e]);
  if (mt3) for (var e of mt3(t)) ye3.call(t, e) && vt3(s, e, t[e]);
  return s;
};
var be3 = (s, t) => ge2(s, Pe3(t));
function u2(s, t, e) {
  var i3;
  const n2 = Fe(s);
  return ((i3 = t.rpcMap) == null ? void 0 : i3[n2.reference]) || `${rt3}?chainId=${n2.namespace}:${n2.reference}&projectId=${e}`;
}
function b2(s) {
  return s.includes(":") ? s.split(":")[1] : s;
}
function gt3(s) {
  return s.map((t) => `${t.split(":")[0]}:${t.split(":")[1]}`);
}
function Ie2(s, t) {
  const e = Object.keys(t.namespaces).filter((n2) => n2.includes(s));
  if (!e.length) return [];
  const i3 = [];
  return e.forEach((n2) => {
    const a2 = t.namespaces[n2].accounts;
    i3.push(...a2);
  }), i3;
}
function Pt3(s) {
  return Object.fromEntries(Object.entries(s).filter(([t, e]) => {
    var i3, n2;
    return ((i3 = e == null ? void 0 : e.chains) == null ? void 0 : i3.length) && ((n2 = e == null ? void 0 : e.chains) == null ? void 0 : n2.length) > 0;
  }));
}
function L(s = {}, t = {}) {
  const e = Pt3(wt3(s)), i3 = Pt3(wt3(t));
  return me4(e, i3);
}
function wt3(s) {
  var t, e, i3, n2, a2;
  const r2 = {};
  if (!Ve(s)) return r2;
  for (const [c4, o2] of Object.entries(s)) {
    const p2 = Pn(c4) ? [c4] : o2.chains, v3 = o2.methods || [], w = o2.events || [], P4 = o2.rpcMap || {}, d3 = Yo(c4);
    r2[d3] = be3(x3(x3({}, r2[d3]), o2), { chains: ct(p2, (t = r2[d3]) == null ? void 0 : t.chains), methods: ct(v3, (e = r2[d3]) == null ? void 0 : e.methods), events: ct(w, (i3 = r2[d3]) == null ? void 0 : i3.events) }), (Ve(P4) || Ve(((n2 = r2[d3]) == null ? void 0 : n2.rpcMap) || {})) && (r2[d3].rpcMap = x3(x3({}, P4), (a2 = r2[d3]) == null ? void 0 : a2.rpcMap));
  }
  return r2;
}
function yt2(s) {
  return s.includes(":") ? s.split(":")[2] : s;
}
function bt2(s) {
  const t = {};
  for (const [e, i3] of Object.entries(s)) {
    const n2 = i3.methods || [], a2 = i3.events || [], r2 = i3.accounts || [], c4 = Pn(e) ? [e] : i3.chains ? i3.chains : gt3(i3.accounts);
    t[e] = { chains: c4, methods: n2, events: a2, accounts: r2 };
  }
  return t;
}
function V4(s) {
  return typeof s == "number" ? s : s.includes("0x") ? parseInt(s, 16) : (s = s.includes(":") ? s.split(":")[1] : s, isNaN(Number(s)) ? s : Number(s));
}
var It4 = {};
var h3 = (s) => It4[s];
var X3 = (s, t) => {
  It4[s] = t;
};
var $e3 = Object.defineProperty;
var $t3 = Object.getOwnPropertySymbols;
var Oe3 = Object.prototype.hasOwnProperty;
var Ae3 = Object.prototype.propertyIsEnumerable;
var Ot3 = (s, t, e) => t in s ? $e3(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var At3 = (s, t) => {
  for (var e in t || (t = {})) Oe3.call(t, e) && Ot3(s, e, t[e]);
  if ($t3) for (var e of $t3(t)) Ae3.call(t, e) && Ot3(s, e, t[e]);
  return s;
};
var Ct3 = "eip155";
var Ce3 = ["atomic", "flow-control", "paymasterService", "sessionKeys", "auxiliaryFunds"];
var Ee = (s) => s && s.startsWith("0x") ? BigInt(s).toString(10) : s;
var Y3 = (s) => s && s.startsWith("0x") ? s : `0x${BigInt(s).toString(16)}`;
var Et3 = (s) => Object.keys(s).filter((t) => Ce3.includes(t)).reduce((t, e) => (t[e] = s[e], t), {});
var He3 = (s, t, e) => {
  const { sessionProperties: i3 = {}, scopedProperties: n2 = {} } = s, a2 = {};
  if (!Ve(n2) && !Ve(i3)) return;
  const r2 = Et3(i3);
  for (const c4 of e) {
    const o2 = Ee(c4);
    if (!o2) continue;
    a2[Y3(o2)] = r2;
    const p2 = n2 == null ? void 0 : n2[`${Ct3}:${o2}`];
    if (p2) {
      const v3 = p2 == null ? void 0 : p2[`${Ct3}:${o2}:${t}`];
      a2[Y3(o2)] = At3(At3({}, a2[Y3(o2)]), Et3(v3 || p2));
    }
  }
  for (const [c4, o2] of Object.entries(a2)) Object.keys(o2).length === 0 && delete a2[c4];
  return Object.keys(a2).length > 0 ? a2 : void 0;
};
var Ne2 = Object.defineProperty;
var Se3 = (s, t, e) => t in s ? Ne2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var $2 = (s, t, e) => Se3(s, typeof t != "symbol" ? t + "" : t, e);
var De4 = class {
  constructor(t) {
    $2(this, "name", "polkadot"), $2(this, "client"), $2(this, "httpProviders"), $2(this, "events"), $2(this, "namespace"), $2(this, "chainId"), this.namespace = t.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const n2 = b2(e);
      t[n2] = this.createHttpProvider(n2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || u2(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, h3("disableProviderPing")));
  }
};
var qe3 = Object.defineProperty;
var je2 = Object.defineProperties;
var Re3 = Object.getOwnPropertyDescriptors;
var Ht3 = Object.getOwnPropertySymbols;
var _e3 = Object.prototype.hasOwnProperty;
var Fe3 = Object.prototype.propertyIsEnumerable;
var Q3 = (s, t, e) => t in s ? qe3(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var Nt3 = (s, t) => {
  for (var e in t || (t = {})) _e3.call(t, e) && Q3(s, e, t[e]);
  if (Ht3) for (var e of Ht3(t)) Fe3.call(t, e) && Q3(s, e, t[e]);
  return s;
};
var St4 = (s, t) => je2(s, Re3(t));
var O4 = (s, t, e) => Q3(s, typeof t != "symbol" ? t + "" : t, e);
var Ue3 = class {
  constructor(t) {
    O4(this, "name", "eip155"), O4(this, "client"), O4(this, "chainId"), O4(this, "namespace"), O4(this, "httpProviders"), O4(this, "events"), this.namespace = t.namespace, this.events = h3("events"), this.client = h3("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(t) {
    switch (t.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(t);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(t);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(t);
    }
    return this.namespace.methods.includes(t.request.method) ? await this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(parseInt(t), e), this.chainId = parseInt(t), this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  createHttpProvider(t, e) {
    const i3 = e || u2(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, h3("disableProviderPing")));
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const n2 = parseInt(b2(e));
      t[n2] = this.createHttpProvider(n2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const t = this.chainId, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  async handleSwitchChain(t) {
    var e, i3;
    let n2 = t.request.params ? (e = t.request.params[0]) == null ? void 0 : e.chainId : "0x0";
    n2 = n2.startsWith("0x") ? n2 : `0x${n2}`;
    const a2 = parseInt(n2, 16);
    if (this.isChainApproved(a2)) this.setDefaultChain(`${a2}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: t.topic, request: { method: t.request.method, params: [{ chainId: n2 }] }, chainId: (i3 = this.namespace.chains) == null ? void 0 : i3[0] }), this.setDefaultChain(`${a2}`);
    else throw new Error(`Failed to switch to chain 'eip155:${a2}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(t) {
    return this.namespace.chains.includes(`${this.name}:${t}`);
  }
  async getCapabilities(t) {
    var e, i3, n2, a2, r2;
    const c4 = (i3 = (e = t.request) == null ? void 0 : e.params) == null ? void 0 : i3[0], o2 = ((a2 = (n2 = t.request) == null ? void 0 : n2.params) == null ? void 0 : a2[1]) || [];
    if (!c4) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const p2 = this.client.session.get(t.topic), v3 = ((r2 = p2 == null ? void 0 : p2.sessionProperties) == null ? void 0 : r2.capabilities) || {}, w = `${c4}${o2.join(",")}`, P4 = v3 == null ? void 0 : v3[w];
    if (P4) return P4;
    let d3;
    try {
      d3 = He3(p2, c4, o2);
    } catch (G4) {
      console.warn("Failed to extract capabilities from session", G4);
    }
    if (d3) return d3;
    const tt3 = await this.client.request(t);
    try {
      await this.client.session.update(t.topic, { sessionProperties: St4(Nt3({}, p2.sessionProperties || {}), { capabilities: St4(Nt3({}, v3 || {}), { [w]: tt3 }) }) });
    } catch (G4) {
      console.warn("Failed to update session with capabilities", G4);
    }
    return tt3;
  }
  async getCallStatus(t) {
    var e, i3;
    const n2 = this.client.session.get(t.topic), a2 = (e = n2.sessionProperties) == null ? void 0 : e.bundler_name;
    if (a2) {
      const c4 = this.getBundlerUrl(t.chainId, a2);
      try {
        return await this.getUserOperationReceipt(c4, t);
      } catch (o2) {
        console.warn("Failed to fetch call status from bundler", o2, c4);
      }
    }
    const r2 = (i3 = n2.sessionProperties) == null ? void 0 : i3.bundler_url;
    if (r2) try {
      return await this.getUserOperationReceipt(r2, t);
    } catch (c4) {
      console.warn("Failed to fetch call status from custom bundler", c4, r2);
    }
    if (this.namespace.methods.includes(t.request.method)) return await this.client.request(t);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(t, e) {
    var i3;
    const n2 = new URL(t), a2 = await fetch(n2, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(i3 = e.request.params) == null ? void 0 : i3[0]])) });
    if (!a2.ok) throw new Error(`Failed to fetch user operation receipt - ${a2.status}`);
    return await a2.json();
  }
  getBundlerUrl(t, e) {
    return `${Gt3}?projectId=${this.client.core.projectId}&chainId=${t}&bundler=${e}`;
  }
};
var xe3 = Object.defineProperty;
var Le3 = (s, t, e) => t in s ? xe3(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var A3 = (s, t, e) => Le3(s, typeof t != "symbol" ? t + "" : t, e);
var Me4 = class {
  constructor(t) {
    A3(this, "name", "solana"), A3(this, "client"), A3(this, "httpProviders"), A3(this, "events"), A3(this, "namespace"), A3(this, "chainId"), this.namespace = t.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const n2 = b2(e);
      t[n2] = this.createHttpProvider(n2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || u2(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, h3("disableProviderPing")));
  }
};
var Be3 = Object.defineProperty;
var Ge2 = (s, t, e) => t in s ? Be3(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var C3 = (s, t, e) => Ge2(s, typeof t != "symbol" ? t + "" : t, e);
var Je2 = class {
  constructor(t) {
    C3(this, "name", "cosmos"), C3(this, "client"), C3(this, "httpProviders"), C3(this, "events"), C3(this, "namespace"), C3(this, "chainId"), this.namespace = t.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const n2 = b2(e);
      t[n2] = this.createHttpProvider(n2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || u2(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, h3("disableProviderPing")));
  }
};
var ze = Object.defineProperty;
var ke3 = (s, t, e) => t in s ? ze(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var E3 = (s, t, e) => ke3(s, typeof t != "symbol" ? t + "" : t, e);
var We2 = class {
  constructor(t) {
    E3(this, "name", "algorand"), E3(this, "client"), E3(this, "httpProviders"), E3(this, "events"), E3(this, "namespace"), E3(this, "chainId"), this.namespace = t.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (!this.httpProviders[t]) {
      const i3 = e || u2(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
      if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i3);
    }
    this.chainId = t, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      t[e] = this.createHttpProvider(e, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || u2(t, this.namespace, this.client.core.projectId);
    return typeof i3 > "u" ? void 0 : new o(new f2(i3, h3("disableProviderPing")));
  }
};
var Ke4 = Object.defineProperty;
var Ve3 = (s, t, e) => t in s ? Ke4(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var H = (s, t, e) => Ve3(s, typeof t != "symbol" ? t + "" : t, e);
var Xe3 = class {
  constructor(t) {
    H(this, "name", "cip34"), H(this, "client"), H(this, "httpProviders"), H(this, "events"), H(this, "namespace"), H(this, "chainId"), this.namespace = t.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      const i3 = this.getCardanoRPCUrl(e), n2 = b2(e);
      t[n2] = this.createHttpProvider(n2, i3);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  getCardanoRPCUrl(t) {
    const e = this.namespace.rpcMap;
    if (e) return e[t];
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || this.getCardanoRPCUrl(t);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, h3("disableProviderPing")));
  }
};
var Ye3 = Object.defineProperty;
var Qe4 = (s, t, e) => t in s ? Ye3(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var N4 = (s, t, e) => Qe4(s, typeof t != "symbol" ? t + "" : t, e);
var Ze3 = class {
  constructor(t) {
    N4(this, "name", "elrond"), N4(this, "client"), N4(this, "httpProviders"), N4(this, "events"), N4(this, "namespace"), N4(this, "chainId"), this.namespace = t.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const n2 = b2(e);
      t[n2] = this.createHttpProvider(n2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || u2(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, h3("disableProviderPing")));
  }
};
var Te2 = Object.defineProperty;
var ts2 = (s, t, e) => t in s ? Te2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var S2 = (s, t, e) => ts2(s, typeof t != "symbol" ? t + "" : t, e);
var es2 = class {
  constructor(t) {
    S2(this, "name", "multiversx"), S2(this, "client"), S2(this, "httpProviders"), S2(this, "events"), S2(this, "namespace"), S2(this, "chainId"), this.namespace = t.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const n2 = b2(e);
      t[n2] = this.createHttpProvider(n2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || u2(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, h3("disableProviderPing")));
  }
};
var ss2 = Object.defineProperty;
var is2 = (s, t, e) => t in s ? ss2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var D3 = (s, t, e) => is2(s, typeof t != "symbol" ? t + "" : t, e);
var rs2 = class {
  constructor(t) {
    D3(this, "name", "near"), D3(this, "client"), D3(this, "httpProviders"), D3(this, "events"), D3(this, "namespace"), D3(this, "chainId"), this.namespace = t.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (this.chainId = t, !this.httpProviders[t]) {
      const i3 = e || u2(`${this.name}:${t}`, this.namespace);
      if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i3);
    }
    this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      t[e] = this.createHttpProvider(e, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || u2(t, this.namespace);
    return typeof i3 > "u" ? void 0 : new o(new f2(i3, h3("disableProviderPing")));
  }
};
var ns2 = Object.defineProperty;
var as2 = (s, t, e) => t in s ? ns2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var q2 = (s, t, e) => as2(s, typeof t != "symbol" ? t + "" : t, e);
var cs2 = class {
  constructor(t) {
    q2(this, "name", "tezos"), q2(this, "client"), q2(this, "httpProviders"), q2(this, "events"), q2(this, "namespace"), q2(this, "chainId"), this.namespace = t.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (this.chainId = t, !this.httpProviders[t]) {
      const i3 = e || u2(`${this.name}:${t}`, this.namespace);
      if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i3);
    }
    this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      t[e] = this.createHttpProvider(e);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || u2(t, this.namespace);
    return typeof i3 > "u" ? void 0 : new o(new f2(i3));
  }
};
var os2 = Object.defineProperty;
var hs2 = (s, t, e) => t in s ? os2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var j2 = (s, t, e) => hs2(s, typeof t != "symbol" ? t + "" : t, e);
var ps2 = class {
  constructor(t) {
    j2(this, "name", nt2), j2(this, "client"), j2(this, "httpProviders"), j2(this, "events"), j2(this, "namespace"), j2(this, "chainId"), this.namespace = t.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.name = this.getNamespaceName(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(t.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(t.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(t.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(t.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider(t.chainId).request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getNamespaceName() {
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return Fe(t).namespace;
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var t, e;
    const i3 = {};
    return (e = (t = this.namespace) == null ? void 0 : t.accounts) == null || e.forEach((n2) => {
      const a2 = Fe(n2);
      i3[a2.reference] = this.createHttpProvider(n2);
    }), i3;
  }
  getHttpProvider(t) {
    const e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || u2(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i3, h3("disableProviderPing")));
  }
};
var ds3 = Object.defineProperty;
var us2 = Object.defineProperties;
var ls2 = Object.getOwnPropertyDescriptors;
var Dt2 = Object.getOwnPropertySymbols;
var fs2 = Object.prototype.hasOwnProperty;
var ms2 = Object.prototype.propertyIsEnumerable;
var Z = (s, t, e) => t in s ? ds3(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var M4 = (s, t) => {
  for (var e in t || (t = {})) fs2.call(t, e) && Z(s, e, t[e]);
  if (Dt2) for (var e of Dt2(t)) ms2.call(t, e) && Z(s, e, t[e]);
  return s;
};
var T2 = (s, t) => us2(s, ls2(t));
var f6 = (s, t, e) => Z(s, typeof t != "symbol" ? t + "" : t, e);
var B2 = class _B {
  constructor(t) {
    f6(this, "client"), f6(this, "namespaces"), f6(this, "optionalNamespaces"), f6(this, "sessionProperties"), f6(this, "scopedProperties"), f6(this, "events", new import_events5.default()), f6(this, "rpcProviders", {}), f6(this, "session"), f6(this, "providerOpts"), f6(this, "logger"), f6(this, "uri"), f6(this, "disableProviderPing", false), this.providerOpts = t, this.logger = typeof (t == null ? void 0 : t.logger) < "u" && typeof (t == null ? void 0 : t.logger) != "string" ? t.logger : (0, import_pino.default)(k({ level: (t == null ? void 0 : t.logger) || it2 })), this.disableProviderPing = (t == null ? void 0 : t.disableProviderPing) || false;
  }
  static async init(t) {
    const e = new _B(t);
    return await e.initialize(), e;
  }
  async request(t, e, i3) {
    const [n2, a2] = this.validateChain(e);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(n2).request({ request: M4({}, t), chainId: `${n2}:${a2}`, topic: this.session.topic, expiry: i3 });
  }
  sendAsync(t, e, i3, n2) {
    const a2 = (/* @__PURE__ */ new Date()).getTime();
    this.request(t, i3, n2).then((r2) => e(null, formatJsonRpcResult(a2, r2))).catch((r2) => e(r2, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var t;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (t = this.session) == null ? void 0 : t.topic, reason: Kt("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(t) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(t), this.cleanupPendingPairings(), !t.skipPairing) return await this.pair(t.pairingTopic);
  }
  async authenticate(t, e) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(t), await this.cleanupPendingPairings();
    const { uri: i3, response: n2 } = await this.client.authenticate(t, e);
    i3 && (this.uri = i3, this.events.emit("display_uri", i3));
    const a2 = await n2();
    if (this.session = a2.session, this.session) {
      const r2 = bt2(this.session.namespaces);
      this.namespaces = L(this.namespaces, r2), await this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return a2;
  }
  on(t, e) {
    this.events.on(t, e);
  }
  once(t, e) {
    this.events.once(t, e);
  }
  removeListener(t, e) {
    this.events.removeListener(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(t) {
    const { uri: e, approval: i3 } = await this.client.connect({ pairingTopic: t, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties });
    e && (this.uri = e, this.events.emit("display_uri", e));
    const n2 = await i3();
    this.session = n2;
    const a2 = bt2(n2.namespaces);
    return this.namespaces = L(this.namespaces, a2), await this.persist("namespaces", this.namespaces), await this.persist("optionalNamespaces", this.optionalNamespaces), this.onConnect(), this.session;
  }
  setDefaultChain(t, e) {
    try {
      if (!this.session) return;
      const [i3, n2] = this.validateChain(t);
      this.getProvider(i3).setDefaultChain(n2, e);
    } catch (i3) {
      if (!/Please call connect/.test(i3.message)) throw i3;
    }
  }
  async cleanupPendingPairings(t = {}) {
    try {
      this.logger.info("Cleaning up inactive pairings...");
      const e = this.client.pairing.getAll();
      if (!me(e)) return;
      for (const i3 of e) t.deletePairings ? this.client.core.expirer.set(i3.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i3.topic);
      this.logger.info(`Inactive pairings cleared: ${e.length}`);
    } catch (e) {
      this.logger.warn("Failed to cleanup pending pairings", e);
    }
  }
  abortPairingAttempt() {
    this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
  }
  async checkStorage() {
    this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.session && this.createProviders();
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    var t, e;
    if (this.client = this.providerOpts.client || await fe3.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || it2, relayUrl: this.providerOpts.relayUrl || Lt3, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.providerOpts.session) try {
      this.session = this.client.session.get(this.providerOpts.session.topic);
    } catch (i3) {
      throw this.logger.error("Failed to get session", i3), new Error(`The provided session: ${(e = (t = this.providerOpts) == null ? void 0 : t.session) == null ? void 0 : e.topic} doesn't exist in the Sign client`);
    }
    else {
      const i3 = this.client.session.getAll();
      this.session = i3[0];
    }
    this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const t = [...new Set(Object.keys(this.session.namespaces).map((e) => Yo(e)))];
    X3("client", this.client), X3("events", this.events), X3("disableProviderPing", this.disableProviderPing), t.forEach((e) => {
      if (!this.session) return;
      const i3 = Ie2(e, this.session);
      if ((i3 == null ? void 0 : i3.length) === 0) return;
      const n2 = gt3(i3), a2 = L(this.namespaces, this.optionalNamespaces), r2 = T2(M4({}, a2[e]), { accounts: i3, chains: n2 });
      switch (e) {
        case "eip155":
          this.rpcProviders[e] = new Ue3({ namespace: r2 });
          break;
        case "algorand":
          this.rpcProviders[e] = new We2({ namespace: r2 });
          break;
        case "solana":
          this.rpcProviders[e] = new Me4({ namespace: r2 });
          break;
        case "cosmos":
          this.rpcProviders[e] = new Je2({ namespace: r2 });
          break;
        case "polkadot":
          this.rpcProviders[e] = new De4({ namespace: r2 });
          break;
        case "cip34":
          this.rpcProviders[e] = new Xe3({ namespace: r2 });
          break;
        case "elrond":
          this.rpcProviders[e] = new Ze3({ namespace: r2 });
          break;
        case "multiversx":
          this.rpcProviders[e] = new es2({ namespace: r2 });
          break;
        case "near":
          this.rpcProviders[e] = new rs2({ namespace: r2 });
          break;
        case "tezos":
          this.rpcProviders[e] = new cs2({ namespace: r2 });
          break;
        default:
          this.rpcProviders[e] = new ps2({ namespace: r2 });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (t) => {
      var e;
      const { topic: i3 } = t;
      i3 === ((e = this.session) == null ? void 0 : e.topic) && this.events.emit("session_ping", t);
    }), this.client.on("session_event", (t) => {
      var e;
      const { params: i3, topic: n2 } = t;
      if (n2 !== ((e = this.session) == null ? void 0 : e.topic)) return;
      const { event: a2 } = i3;
      if (a2.name === "accountsChanged") {
        const r2 = a2.data;
        r2 && me(r2) && this.events.emit("accountsChanged", r2.map(yt2));
      } else if (a2.name === "chainChanged") {
        const r2 = i3.chainId, c4 = i3.event.data, o2 = Yo(r2), p2 = V4(r2) !== V4(c4) ? `${o2}:${V4(c4)}` : r2;
        this.onChainChanged(p2);
      } else this.events.emit(a2.name, a2.data);
      this.events.emit("session_event", t);
    }), this.client.on("session_update", ({ topic: t, params: e }) => {
      var i3, n2;
      if (t !== ((i3 = this.session) == null ? void 0 : i3.topic)) return;
      const { namespaces: a2 } = e, r2 = (n2 = this.client) == null ? void 0 : n2.session.get(t);
      this.session = T2(M4({}, r2), { namespaces: a2 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: t, params: e });
    }), this.client.on("session_delete", async (t) => {
      var e;
      t.topic === ((e = this.session) == null ? void 0 : e.topic) && (await this.cleanup(), this.events.emit("session_delete", t), this.events.emit("disconnect", T2(M4({}, Kt("USER_DISCONNECTED")), { data: t.topic })));
    }), this.on(l3.DEFAULT_CHAIN_CHANGED, (t) => {
      this.onChainChanged(t, true);
    });
  }
  getProvider(t) {
    return this.rpcProviders[t] || this.rpcProviders[nt2];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((t) => {
      var e;
      this.getProvider(t).updateNamespace((e = this.session) == null ? void 0 : e.namespaces[t]);
    });
  }
  setNamespaces(t) {
    const { namespaces: e = {}, optionalNamespaces: i3 = {}, sessionProperties: n2, scopedProperties: a2 } = t;
    this.optionalNamespaces = L(e, i3), this.sessionProperties = n2, this.scopedProperties = a2;
  }
  validateChain(t) {
    const [e, i3] = (t == null ? void 0 : t.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [e, i3];
    if (e && !Object.keys(this.namespaces || {}).map((r2) => Yo(r2)).includes(e)) throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);
    if (e && i3) return [e, i3];
    const n2 = Yo(Object.keys(this.namespaces)[0]), a2 = this.rpcProviders[n2].getDefaultChain();
    return [n2, a2];
  }
  async requestAccounts() {
    const [t] = this.validateChain();
    return await this.getProvider(t).requestAccounts();
  }
  async onChainChanged(t, e = false) {
    if (!this.namespaces) return;
    const [i3, n2] = this.validateChain(t);
    if (!n2) return;
    this.updateNamespaceChain(i3, n2);
    const a2 = this.getProvider(i3).getDefaultChain();
    e ? (this.events.emit("chainChanged", n2), this.emitAccountsChangedOnChainChange({ namespace: i3, previousChainId: a2, newChainId: t })) : this.getProvider(i3).setDefaultChain(n2), await this.persist("namespaces", this.namespaces);
  }
  emitAccountsChangedOnChainChange({ namespace: t, previousChainId: e, newChainId: i3 }) {
    var n2, a2;
    try {
      if (e === i3) return;
      const r2 = (a2 = (n2 = this.session) == null ? void 0 : n2.namespaces[t]) == null ? void 0 : a2.accounts;
      if (!r2) return;
      const c4 = r2.filter((o2) => o2.includes(`${i3}:`)).map(yt2);
      if (!me(c4)) return;
      this.events.emit("accountsChanged", c4);
    } catch (r2) {
      this.logger.warn("Failed to emit accountsChanged on chain change", r2);
    }
  }
  updateNamespaceChain(t, e) {
    if (!this.namespaces) return;
    const i3 = this.namespaces[t] ? t : `${t}:${e}`, n2 = { chains: [], methods: [], events: [], defaultChain: e };
    this.namespaces[i3] ? this.namespaces[i3] && (this.namespaces[i3].defaultChain = e) : this.namespaces[i3] = n2;
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore("namespaces"), await this.deleteFromStore("optionalNamespaces"), await this.deleteFromStore("sessionProperties"), this.session = void 0, this.cleanupPendingPairings({ deletePairings: true }), await this.cleanupStorage();
  }
  async persist(t, e) {
    var i3;
    const n2 = ((i3 = this.session) == null ? void 0 : i3.topic) || "";
    await this.client.core.storage.setItem(`${F3}/${t}${n2}`, e);
  }
  async getFromStore(t) {
    var e;
    const i3 = ((e = this.session) == null ? void 0 : e.topic) || "";
    return await this.client.core.storage.getItem(`${F3}/${t}${i3}`);
  }
  async deleteFromStore(t) {
    var e;
    const i3 = ((e = this.session) == null ? void 0 : e.topic) || "";
    await this.client.core.storage.removeItem(`${F3}/${t}${i3}`);
  }
  async cleanupStorage() {
    var t;
    try {
      if (((t = this.client) == null ? void 0 : t.session.length) > 0) return;
      const e = await this.client.core.storage.getKeys();
      for (const i3 of e) i3.startsWith(F3) && await this.client.core.storage.removeItem(i3);
    } catch (e) {
      this.logger.warn("Failed to cleanup storage", e);
    }
  }
};

// node_modules/@reown/appkit-utils/dist/esm/src/ethers/EthersHelpersUtil.js
var EthersHelpersUtil = {
  hexStringToNumber(value) {
    const string2 = value.startsWith("0x") ? value.slice(2) : value;
    const number = parseInt(string2, 16);
    return number;
  },
  numberToHexString(value) {
    return `0x${value.toString(16)}`;
  },
  async getUserInfo(provider) {
    const [addresses, chainId] = await Promise.all([
      EthersHelpersUtil.getAddresses(provider),
      EthersHelpersUtil.getChainId(provider)
    ]);
    return { chainId, addresses };
  },
  async getChainId(provider) {
    const chainId = await provider.request({ method: "eth_chainId" });
    return Number(chainId);
  },
  async getAddress(provider) {
    const [address] = await provider.request({ method: "eth_accounts" });
    return address;
  },
  async getAddresses(provider) {
    const addresses = await provider.request({ method: "eth_accounts" });
    return addresses;
  },
  async addEthereumChain(provider, caipNetwork) {
    var _a2, _b;
    const rpcUrls = ((_a2 = caipNetwork.rpcUrls["chainDefault"]) == null ? void 0 : _a2.http) || [];
    await provider.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: EthersHelpersUtil.numberToHexString(caipNetwork.id),
          rpcUrls: [...rpcUrls],
          chainName: caipNetwork.name,
          nativeCurrency: {
            name: caipNetwork.nativeCurrency.name,
            decimals: caipNetwork.nativeCurrency.decimals,
            symbol: caipNetwork.nativeCurrency.symbol
          },
          blockExplorerUrls: [(_b = caipNetwork.blockExplorers) == null ? void 0 : _b.default.url],
          iconUrls: [PresetsUtil.NetworkImageIds[caipNetwork.id]]
        }
      ]
    });
  }
};

// node_modules/@reown/appkit-utils/dist/esm/src/bitcoin/BitcoinConstantsUtil.js
var BitcoinConstantsUtil = {
  ACCOUNT_INDEXES: {
    PAYMENT: 0,
    ORDINAL: 1
  }
};

// node_modules/@reown/appkit/dist/esm/src/connections/ConnectionManager.js
var ConnectionManager = class {
  constructor(params) {
    this.namespace = params.namespace;
  }
  async syncConnections(params) {
    switch (this.namespace) {
      case ConstantsUtil.CHAIN.EVM:
        await this.syncEVMConnections(params);
        break;
      case ConstantsUtil.CHAIN.SOLANA:
        await this.syncSolanaConnections(params);
        break;
      case ConstantsUtil.CHAIN.BITCOIN:
        await this.syncBitcoinConnections(params);
        break;
      default:
        throw new Error(`Unsupported chain namespace: ${this.namespace}`);
    }
  }
  async syncEVMConnections({ connectors, caipNetworks, universalProvider, getConnectionStatusInfo, onConnection, onListenProvider }) {
    await Promise.all(connectors.filter((c4) => {
      const { hasDisconnected, hasConnected } = getConnectionStatusInfo(c4.id);
      return !hasDisconnected && hasConnected;
    }).map(async (connector) => {
      if (connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
        const accounts = WcHelpersUtil.getWalletConnectAccounts(universalProvider, this.namespace);
        const caipNetwork = caipNetworks.find((n2) => {
          var _a2, _b;
          return n2.chainNamespace === this.namespace && n2.id.toString() === ((_b = (_a2 = accounts[0]) == null ? void 0 : _a2.chainId) == null ? void 0 : _b.toString());
        });
        if (accounts.length > 0) {
          onConnection({
            connectorId: connector.id,
            accounts: accounts.map((account) => ({ address: account.address })),
            caipNetwork
          });
        }
      } else {
        const { accounts, chainId } = await ConnectorUtil.fetchProviderData(connector);
        if (accounts.length > 0 && chainId) {
          const caipNetwork = caipNetworks.find((n2) => n2.chainNamespace === this.namespace && n2.id.toString() === chainId.toString());
          onConnection({
            connectorId: connector.id,
            accounts: accounts.map((address) => ({ address })),
            caipNetwork
          });
          if (connector.provider && connector.id !== ConstantsUtil.CONNECTOR_ID.AUTH && connector.id !== ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
            onListenProvider(connector.id, connector.provider);
          }
        }
      }
    }));
  }
  async syncSolanaConnections({ connectors, caipNetwork, universalProvider, getConnectionStatusInfo, onConnection, onListenProvider }) {
    await Promise.all(connectors.filter((c4) => {
      const { hasDisconnected, hasConnected } = getConnectionStatusInfo(c4.id);
      return !hasDisconnected && hasConnected;
    }).map(async (connector) => {
      if (connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
        const accounts = WcHelpersUtil.getWalletConnectAccounts(universalProvider, this.namespace);
        if (accounts.length > 0) {
          onConnection({
            connectorId: connector.id,
            accounts: accounts.map((account) => ({ address: account.address })),
            caipNetwork
          });
        }
      } else {
        const address = await connector.connect({
          chainId: caipNetwork == null ? void 0 : caipNetwork.id
        });
        if (address) {
          onConnection({
            connectorId: connector.id,
            accounts: [{ address }],
            caipNetwork
          });
          onListenProvider(connector.id, connector.provider);
        }
      }
    }));
  }
  async syncBitcoinConnections({ connectors, caipNetwork, universalProvider, getConnectionStatusInfo, onConnection, onListenProvider }) {
    await Promise.all(connectors.filter((c4) => {
      const { hasDisconnected, hasConnected } = getConnectionStatusInfo(c4.id);
      return !hasDisconnected && hasConnected;
    }).map(async (connector) => {
      var _a2, _b, _c2, _d, _e4, _f2;
      if (connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
        const accounts2 = WcHelpersUtil.getWalletConnectAccounts(universalProvider, this.namespace);
        if (accounts2.length > 0) {
          onConnection({
            connectorId: connector.id,
            accounts: accounts2.map((account) => ({ address: account.address })),
            caipNetwork
          });
        }
        return;
      }
      const address = await connector.connect();
      const addresses = await connector.getAccountAddresses();
      let accounts = addresses == null ? void 0 : addresses.map((a2) => CoreHelperUtil.createAccount(ConstantsUtil.CHAIN.BITCOIN, a2.address, a2.purpose || "payment", a2.publicKey, a2.path));
      if (accounts && accounts.length > 1) {
        accounts = [
          {
            namespace: ConstantsUtil.CHAIN.BITCOIN,
            publicKey: ((_a2 = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.PAYMENT]) == null ? void 0 : _a2.publicKey) ?? "",
            path: ((_b = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.PAYMENT]) == null ? void 0 : _b.path) ?? "",
            address: ((_c2 = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.PAYMENT]) == null ? void 0 : _c2.address) ?? "",
            type: "payment"
          },
          {
            namespace: ConstantsUtil.CHAIN.BITCOIN,
            publicKey: ((_d = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.ORDINAL]) == null ? void 0 : _d.publicKey) ?? "",
            path: ((_e4 = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.ORDINAL]) == null ? void 0 : _e4.path) ?? "",
            address: ((_f2 = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.ORDINAL]) == null ? void 0 : _f2.address) ?? "",
            type: "ordinal"
          }
        ];
      }
      const chain = connector.chains.find((c4) => c4.id === (caipNetwork == null ? void 0 : caipNetwork.id)) || connector.chains[0];
      if (!chain) {
        throw new Error("The connector does not support any of the requested chains");
      }
      if (address) {
        onListenProvider(connector.id, connector.provider);
        onConnection({
          connectorId: connector.id,
          accounts: accounts.map((a2) => ({ address: a2.address, type: a2.type })),
          caipNetwork
        });
      }
    }));
  }
  /**
   * Gets a connection based on provided parameters.
   * If connectorId is provided, returns connection for that specific connector.
   * Otherwise, returns the first available valid connection.
   *
   * @param params - Connection parameters
   * @param params.address - Optional address to filter by
   * @param params.connectorId - Optional connector ID to filter by
   * @param params.connections - List of available connections
   * @param params.connectors - List of available connectors
   * @returns Connection or null if none found
   */
  getConnection({ address, connectorId, connections, connectors }) {
    if (connectorId) {
      const connection = connections.find((c4) => HelpersUtil.isLowerCaseMatch(c4.connectorId, connectorId));
      if (!connection) {
        return null;
      }
      const connector = connectors.find((c4) => HelpersUtil.isLowerCaseMatch(c4.id, connection.connectorId));
      const account = address ? connection.accounts.find((a2) => HelpersUtil.isLowerCaseMatch(a2.address, address)) : connection.accounts[0];
      return { ...connection, account, connector };
    }
    const validConnection = connections.find((c4) => c4.accounts.length > 0 && connectors.some((conn) => HelpersUtil.isLowerCaseMatch(conn.id, c4.connectorId)));
    if (validConnection) {
      const [account] = validConnection.accounts;
      const connector = connectors.find((c4) => HelpersUtil.isLowerCaseMatch(c4.id, validConnection.connectorId));
      return {
        ...validConnection,
        account,
        connector
      };
    }
    return null;
  }
};

// node_modules/@reown/appkit/dist/esm/src/connectors/WalletConnectConnector.js
var WalletConnectConnector = class {
  constructor({ provider, namespace }) {
    this.id = ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
    this.name = PresetsUtil.ConnectorNamesMap[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
    this.type = "WALLET_CONNECT";
    this.imageId = PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
    this.getCaipNetworks = ChainController.getCaipNetworks.bind(ChainController);
    this.caipNetworks = this.getCaipNetworks();
    this.provider = provider;
    this.chain = namespace;
  }
  get chains() {
    return this.getCaipNetworks();
  }
  async connectWalletConnect() {
    const isAuthenticated = await this.authenticate();
    if (!isAuthenticated) {
      const caipNetworks = this.getCaipNetworks();
      const universalProviderConfigOverride = OptionsController.state.universalProviderConfigOverride;
      const namespaces = WcHelpersUtil.createNamespaces(caipNetworks, universalProviderConfigOverride);
      await this.provider.connect({ optionalNamespaces: namespaces });
    }
    return {
      clientId: await this.provider.client.core.crypto.getClientId(),
      session: this.provider.session
    };
  }
  async disconnect() {
    await this.provider.disconnect();
  }
  async authenticate() {
    const chains = this.chains.map((network) => network.caipNetworkId);
    return SIWXUtil.universalProviderAuthenticate({
      universalProvider: this.provider,
      chains,
      methods: OPTIONAL_METHODS
    });
  }
};
var OPTIONAL_METHODS = [
  "eth_accounts",
  "eth_requestAccounts",
  "eth_sendRawTransaction",
  "eth_sign",
  "eth_signTransaction",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "personal_sign",
  "wallet_switchEthereumChain",
  "wallet_addEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode",
  // EIP-5792
  "wallet_getCallsStatus",
  "wallet_sendCalls",
  "wallet_getCapabilities",
  // EIP-7715
  "wallet_grantPermissions",
  "wallet_revokePermissions",
  //EIP-7811
  "wallet_getAssets"
];

// node_modules/@reown/appkit/dist/esm/src/adapters/ChainAdapterBlueprint.js
var IGNORED_CONNECTOR_IDS_FOR_LISTENER = [
  ConstantsUtil.CONNECTOR_ID.AUTH,
  ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT
];
var AdapterBlueprint = class {
  /**
   * Creates an instance of AdapterBlueprint.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  constructor(params) {
    this.availableConnectors = [];
    this.availableConnections = [];
    this.providerHandlers = {};
    this.eventListeners = /* @__PURE__ */ new Map();
    this.getCaipNetworks = (namespace) => ChainController.getCaipNetworks(namespace);
    this.getConnectorId = (namespace) => ConnectorController.getConnectorId(namespace);
    if (params) {
      this.construct(params);
    }
    if (params == null ? void 0 : params.namespace) {
      this.connectionManager = new ConnectionManager({
        namespace: params.namespace
      });
    }
  }
  /**
   * Initializes the adapter with the given parameters.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  construct(params) {
    this.projectId = params.projectId;
    this.namespace = params.namespace;
    this.adapterType = params.adapterType;
  }
  /**
   * Gets the available connectors.
   * @returns {Connector[]} An array of available connectors
   */
  get connectors() {
    return this.availableConnectors;
  }
  /**
   * Gets the available connections.
   * @returns {Connection[]} An array of available connections
   */
  get connections() {
    return this.availableConnections;
  }
  /**
   * Gets the supported networks.
   * @returns {CaipNetwork[]} An array of supported networks
   */
  get networks() {
    return this.getCaipNetworks(this.namespace);
  }
  /**
   * Handles the auth connected event.
   * @param {W3mFrameTypes.Responses['FrameGetUserResponse']} user - The user response
   */
  onAuthConnected({ accounts, chainId }) {
    const caipNetwork = this.getCaipNetworks().filter((n2) => n2.chainNamespace === this.namespace).find((n2) => n2.id.toString() === (chainId == null ? void 0 : chainId.toString()));
    if (accounts && caipNetwork) {
      this.addConnection({
        connectorId: ConstantsUtil.CONNECTOR_ID.AUTH,
        accounts,
        caipNetwork
      });
    }
  }
  /**
   * Sets the auth provider.
   * @param {W3mFrameProvider} authProvider - The auth provider instance
   */
  setAuthProvider(authProvider) {
    authProvider.onConnect(this.onAuthConnected.bind(this));
    authProvider.onSocialConnected(this.onAuthConnected.bind(this));
    this.addConnector({
      id: ConstantsUtil.CONNECTOR_ID.AUTH,
      type: "AUTH",
      name: ConstantsUtil.CONNECTOR_NAMES.AUTH,
      provider: authProvider,
      imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.AUTH],
      chain: this.namespace,
      chains: []
    });
  }
  /**
   * Adds one or more connectors to the available connectors list.
   * @param {...Connector} connectors - The connectors to add
   */
  addConnector(...connectors) {
    const connectorsAdded = /* @__PURE__ */ new Set();
    this.availableConnectors = [...connectors, ...this.availableConnectors].filter((connector) => {
      if (connectorsAdded.has(connector.id)) {
        return false;
      }
      connectorsAdded.add(connector.id);
      return true;
    });
    this.emit("connectors", this.availableConnectors);
  }
  /**
   * Adds connections to the available connections list
   * @param {...Connection} connections - The connections to add
   */
  addConnection(...connections) {
    const connectionsAdded = /* @__PURE__ */ new Set();
    this.availableConnections = [...connections, ...this.availableConnections].filter((connection) => {
      if (connectionsAdded.has(connection.connectorId.toLowerCase())) {
        return false;
      }
      connectionsAdded.add(connection.connectorId.toLowerCase());
      return true;
    });
    this.emit("connections", this.availableConnections);
  }
  /**
   * Deletes a connection from the available connections list
   * @param {string} connectorId - The connector ID of the connection to delete
   */
  deleteConnection(connectorId) {
    this.availableConnections = this.availableConnections.filter((c4) => !HelpersUtil.isLowerCaseMatch(c4.connectorId, connectorId));
    this.emit("connections", this.availableConnections);
  }
  /**
   * Clears all connections from the available connections list
   * @param {boolean} emit - Whether to emit the connections event
   */
  clearConnections(emit = false) {
    this.availableConnections = [];
    if (emit) {
      this.emit("connections", this.availableConnections);
    }
  }
  setStatus(status, chainNamespace) {
    AccountController.setStatus(status, chainNamespace);
  }
  /**
   * Adds an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be called when the event is emitted
   */
  on(eventName, callback) {
    var _a2;
    if (!this.eventListeners.has(eventName)) {
      this.eventListeners.set(eventName, /* @__PURE__ */ new Set());
    }
    (_a2 = this.eventListeners.get(eventName)) == null ? void 0 : _a2.add(callback);
  }
  /**
   * Removes an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be removed
   */
  off(eventName, callback) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.delete(callback);
    }
  }
  /**
   * Removes all event listeners.
   */
  removeAllEventListeners() {
    this.eventListeners.forEach((listeners) => {
      listeners.clear();
    });
  }
  /**
   * Emits an event with the given name and optional data.
   * @template T
   * @param {T} eventName - The name of the event to emit
   * @param {EventData[T]} [data] - The optional data to be passed to the event listeners
   */
  emit(eventName, data) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.forEach((callback) => callback(data));
    }
  }
  /**
   * Connects to WalletConnect.
   * @param {number | string} [_chainId] - Optional chain ID to connect to
   */
  async connectWalletConnect(_chainId) {
    const connector = this.getWalletConnectConnector();
    const result = await connector.connectWalletConnect();
    return { clientId: result.clientId };
  }
  /**
   * Switches the network.
   * @param {AdapterBlueprint.SwitchNetworkParams} params - Network switching parameters
   */
  async switchNetwork(params) {
    const { caipNetwork, providerType } = params;
    if (!params.provider) {
      return;
    }
    const provider = "provider" in params.provider ? params.provider.provider : params.provider;
    if (providerType === "WALLET_CONNECT") {
      ;
      provider.setDefaultChain(caipNetwork.caipNetworkId);
      return;
    }
    if (provider && providerType === "AUTH") {
      const authProvider = provider;
      const preferredAccountType = getPreferredAccountType(caipNetwork.chainNamespace);
      await authProvider.switchNetwork({ chainId: caipNetwork.caipNetworkId });
      const user = await authProvider.getUser({
        chainId: caipNetwork.caipNetworkId,
        preferredAccountType
      });
      this.emit("switchNetwork", user);
    }
  }
  getWalletConnectConnector() {
    const connector = this.connectors.find((c4) => c4 instanceof WalletConnectConnector);
    if (!connector) {
      throw new Error("WalletConnectConnector not found");
    }
    return connector;
  }
  /**
   * Handles connect event for a specific connector.
   * @param {string[]} accounts - The accounts that changed
   * @param {string} connectorId - The ID of the connector
   */
  onConnect(accounts, connectorId) {
    if (accounts.length > 0) {
      const { address, chainId } = CoreHelperUtil.getAccount(accounts[0]);
      const caipNetwork = this.getCaipNetworks().filter((n2) => n2.chainNamespace === this.namespace).find((n2) => n2.id.toString() === (chainId == null ? void 0 : chainId.toString()));
      const connector = this.connectors.find((c4) => c4.id === connectorId);
      if (address) {
        this.emit("accountChanged", {
          address,
          chainId,
          connector
        });
        this.addConnection({
          connectorId,
          accounts: accounts.map((_account) => {
            const { address: address2 } = CoreHelperUtil.getAccount(_account);
            return { address: address2 };
          }),
          caipNetwork
        });
      }
    }
  }
  /**
   * Handles accounts changed event for a specific connector.
   * @param {string[]} accounts - The accounts that changed
   * @param {string} connectorId - The ID of the connector
   */
  onAccountsChanged(accounts, connectorId, disconnectIfNoAccounts = true) {
    var _a2, _b;
    if (accounts.length > 0) {
      const { address } = CoreHelperUtil.getAccount(accounts[0]);
      const connection = (_a2 = this.connectionManager) == null ? void 0 : _a2.getConnection({
        connectorId,
        connections: this.connections,
        connectors: this.connectors
      });
      if (address && HelpersUtil.isLowerCaseMatch(this.getConnectorId(ConstantsUtil.CHAIN.EVM), connectorId)) {
        this.emit("accountChanged", {
          address,
          chainId: (_b = connection == null ? void 0 : connection.caipNetwork) == null ? void 0 : _b.id,
          connector: connection == null ? void 0 : connection.connector
        });
      }
      this.addConnection({
        connectorId,
        accounts: accounts.map((_account) => {
          const { address: address2 } = CoreHelperUtil.getAccount(_account);
          return { address: address2 };
        }),
        caipNetwork: connection == null ? void 0 : connection.caipNetwork
      });
    } else if (disconnectIfNoAccounts) {
      this.onDisconnect(connectorId);
    }
  }
  /**
   * Handles disconnect event for a specific connector.
   * @param {string} connectorId - The ID of the connector
   */
  onDisconnect(connectorId) {
    this.removeProviderListeners(connectorId);
    this.deleteConnection(connectorId);
    if (HelpersUtil.isLowerCaseMatch(this.getConnectorId(ConstantsUtil.CHAIN.EVM), connectorId)) {
      this.emitFirstAvailableConnection();
    }
    if (this.connections.length === 0) {
      this.emit("disconnect");
    }
  }
  /**
   * Handles chain changed event for a specific connector.
   * @param {string} chainId - The ID of the chain that changed
   * @param {string} connectorId - The ID of the connector
   */
  onChainChanged(chainId, connectorId) {
    var _a2;
    const formattedChainId = typeof chainId === "string" && chainId.startsWith("0x") ? EthersHelpersUtil.hexStringToNumber(chainId).toString() : chainId.toString();
    const connection = (_a2 = this.connectionManager) == null ? void 0 : _a2.getConnection({
      connectorId,
      connections: this.connections,
      connectors: this.connectors
    });
    const caipNetwork = this.getCaipNetworks().filter((n2) => n2.chainNamespace === this.namespace).find((n2) => n2.id.toString() === formattedChainId);
    if (connection) {
      this.addConnection({
        connectorId,
        accounts: connection.accounts,
        caipNetwork
      });
    }
    if (HelpersUtil.isLowerCaseMatch(this.getConnectorId(ConstantsUtil.CHAIN.EVM), connectorId)) {
      this.emit("switchNetwork", { chainId: formattedChainId });
    }
  }
  /**
   * Listens to provider events for a specific connector.
   * @param {string} connectorId - The ID of the connector
   * @param {Provider | CombinedProvider} provider - The provider to listen to
   */
  listenProviderEvents(connectorId, provider) {
    if (IGNORED_CONNECTOR_IDS_FOR_LISTENER.includes(connectorId)) {
      return;
    }
    const accountsChangedHandler = (accounts) => this.onAccountsChanged(accounts, connectorId);
    const chainChangedHandler = (chainId) => this.onChainChanged(chainId, connectorId);
    const disconnectHandler = () => this.onDisconnect(connectorId);
    if (!this.providerHandlers[connectorId]) {
      provider.on("disconnect", disconnectHandler);
      provider.on("accountsChanged", accountsChangedHandler);
      provider.on("chainChanged", chainChangedHandler);
      this.providerHandlers[connectorId] = {
        provider,
        disconnect: disconnectHandler,
        accountsChanged: accountsChangedHandler,
        chainChanged: chainChangedHandler
      };
    }
  }
  /**
   * Removes provider listeners for a specific connector.
   * @param {string} connectorId - The ID of the connector
   */
  removeProviderListeners(connectorId) {
    if (this.providerHandlers[connectorId]) {
      const { provider, disconnect, accountsChanged, chainChanged } = this.providerHandlers[connectorId];
      provider.removeListener("disconnect", disconnect);
      provider.removeListener("accountsChanged", accountsChanged);
      provider.removeListener("chainChanged", chainChanged);
      this.providerHandlers[connectorId] = null;
    }
  }
  /**
   * Emits the first available connection.
   */
  emitFirstAvailableConnection() {
    var _a2, _b;
    const connection = (_a2 = this.connectionManager) == null ? void 0 : _a2.getConnection({
      connections: this.connections,
      connectors: this.connectors
    });
    if (connection) {
      const [account] = connection.accounts;
      this.emit("accountChanged", {
        address: account == null ? void 0 : account.address,
        chainId: (_b = connection.caipNetwork) == null ? void 0 : _b.id,
        connector: connection.connector
      });
    }
  }
};

// node_modules/@reown/appkit/dist/esm/src/universal-adapter/client.js
var UniversalAdapter = class extends AdapterBlueprint {
  async setUniversalProvider(universalProvider) {
    if (!this.namespace) {
      throw new Error("UniversalAdapter:setUniversalProvider - namespace is required");
    }
    this.addConnector(new WalletConnectConnector({
      provider: universalProvider,
      caipNetworks: this.getCaipNetworks(),
      namespace: this.namespace
    }));
    return Promise.resolve();
  }
  async connect(params) {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: Number(params.chainId),
      provider: this.provider,
      address: ""
    });
  }
  async disconnect() {
    try {
      const connector = this.getWalletConnectConnector();
      await connector.disconnect();
      this.emit("disconnect");
    } catch (error) {
      console.warn("UniversalAdapter:disconnect - error", error);
    }
    return { connections: [] };
  }
  syncConnections() {
    return Promise.resolve();
  }
  async getAccounts({ namespace }) {
    var _a2, _b, _c2, _d;
    const provider = this.provider;
    const addresses = ((_d = (_c2 = (_b = (_a2 = provider == null ? void 0 : provider.session) == null ? void 0 : _a2.namespaces) == null ? void 0 : _b[namespace]) == null ? void 0 : _c2.accounts) == null ? void 0 : _d.map((account) => {
      const [, , address] = account.split(":");
      return address;
    }).filter((address, index, self2) => self2.indexOf(address) === index)) || [];
    return Promise.resolve({
      accounts: addresses.map((address) => CoreHelperUtil.createAccount(namespace, address, namespace === "bip122" ? "payment" : "eoa"))
    });
  }
  async syncConnectors() {
    return Promise.resolve();
  }
  async getBalance(params) {
    var _a2, _b, _c2, _d, _e4;
    const isBalanceSupported = params.caipNetwork && ConstantsUtil2.BALANCE_SUPPORTED_CHAINS.includes((_a2 = params.caipNetwork) == null ? void 0 : _a2.chainNamespace);
    if (!isBalanceSupported || ((_b = params.caipNetwork) == null ? void 0 : _b.testnet)) {
      return {
        balance: "0.00",
        symbol: ((_c2 = params.caipNetwork) == null ? void 0 : _c2.nativeCurrency.symbol) || ""
      };
    }
    if (AccountController.state.balanceLoading && params.chainId === ((_d = ChainController.state.activeCaipNetwork) == null ? void 0 : _d.id)) {
      return {
        balance: AccountController.state.balance || "0.00",
        symbol: AccountController.state.balanceSymbol || ""
      };
    }
    const balances = await AccountController.fetchTokenBalance();
    const balance = balances.find((b3) => {
      var _a3, _b2;
      return b3.chainId === `${(_a3 = params.caipNetwork) == null ? void 0 : _a3.chainNamespace}:${params.chainId}` && b3.symbol === ((_b2 = params.caipNetwork) == null ? void 0 : _b2.nativeCurrency.symbol);
    });
    return {
      balance: (balance == null ? void 0 : balance.quantity.numeric) || "0.00",
      symbol: (balance == null ? void 0 : balance.symbol) || ((_e4 = params.caipNetwork) == null ? void 0 : _e4.nativeCurrency.symbol) || ""
    };
  }
  async signMessage(params) {
    var _a2, _b, _c2;
    const { provider, message, address } = params;
    if (!provider) {
      throw new Error("UniversalAdapter:signMessage - provider is undefined");
    }
    let signature = "";
    if (((_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.chainNamespace) === ConstantsUtil.CHAIN.SOLANA) {
      const response = await provider.request({
        method: "solana_signMessage",
        params: {
          message: esm_default.encode(new TextEncoder().encode(message)),
          pubkey: address
        }
      }, (_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.caipNetworkId);
      signature = response.signature;
    } else {
      signature = await provider.request({
        method: "personal_sign",
        params: [message, address]
      }, (_c2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _c2.caipNetworkId);
    }
    return { signature };
  }
  // -- Transaction methods ---------------------------------------------------
  /**
   *
   * These methods are supported only on `wagmi` and `ethers` since the Solana SDK does not support them in the same way.
   * These function definition is to have a type parity between the clients. Currently not in use.
   */
  async estimateGas() {
    return Promise.resolve({
      gas: BigInt(0)
    });
  }
  async sendTransaction() {
    return Promise.resolve({
      hash: ""
    });
  }
  walletGetAssets(_params) {
    return Promise.resolve({});
  }
  async writeContract() {
    return Promise.resolve({
      hash: ""
    });
  }
  emitFirstAvailableConnection() {
    return void 0;
  }
  parseUnits() {
    return 0n;
  }
  formatUnits() {
    return "0";
  }
  async getCapabilities() {
    return Promise.resolve({});
  }
  async grantPermissions() {
    return Promise.resolve({});
  }
  async revokePermissions() {
    return Promise.resolve("0x");
  }
  async syncConnection() {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: 1,
      provider: this.provider,
      address: ""
    });
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async switchNetwork(params) {
    var _a2, _b, _c2, _d, _e4, _f2;
    const { caipNetwork } = params;
    const connector = this.getWalletConnectConnector();
    if (caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM) {
      try {
        await ((_a2 = connector.provider) == null ? void 0 : _a2.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: toHex(caipNetwork.id) }]
        }));
      } catch (switchError) {
        if (switchError.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_INVALID_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_CODE_DEFAULT || ((_c2 = (_b = switchError == null ? void 0 : switchError.data) == null ? void 0 : _b.originalError) == null ? void 0 : _c2.code) === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
          try {
            await ((_f2 = connector.provider) == null ? void 0 : _f2.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: toHex(caipNetwork.id),
                  rpcUrls: [(_d = caipNetwork == null ? void 0 : caipNetwork.rpcUrls["chainDefault"]) == null ? void 0 : _d.http],
                  chainName: caipNetwork.name,
                  nativeCurrency: caipNetwork.nativeCurrency,
                  blockExplorerUrls: [(_e4 = caipNetwork.blockExplorers) == null ? void 0 : _e4.default.url]
                }
              ]
            }));
          } catch (error) {
            throw new Error("Chain is not supported");
          }
        }
      }
    }
    connector.provider.setDefaultChain(caipNetwork.caipNetworkId);
  }
  getWalletConnectProvider() {
    const connector = this.connectors.find((c4) => c4.type === "WALLET_CONNECT");
    const provider = connector == null ? void 0 : connector.provider;
    return provider;
  }
};

// node_modules/@reown/appkit/dist/esm/src/utils/ConfigUtil.js
var FEATURE_KEYS = [
  "email",
  "socials",
  "swaps",
  "onramp",
  "activity",
  "reownBranding",
  "multiWallet",
  "emailCapture",
  "payWithExchange",
  "payments",
  "reownAuthentication"
];
var featureConfig = {
  email: {
    apiFeatureName: "social_login",
    localFeatureName: "email",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!(apiConfig == null ? void 0 : apiConfig.config)) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.includes("email");
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.email;
      }
      return Boolean(localValue);
    }
  },
  socials: {
    apiFeatureName: "social_login",
    localFeatureName: "socials",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!(apiConfig == null ? void 0 : apiConfig.config)) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config.filter((s) => s !== "email") : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.socials;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.socials : false;
      }
      return localValue;
    }
  },
  swaps: {
    apiFeatureName: "swap",
    localFeatureName: "swaps",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!(apiConfig == null ? void 0 : apiConfig.config)) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.swaps;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.swaps : false;
      }
      return localValue;
    }
  },
  onramp: {
    apiFeatureName: "onramp",
    localFeatureName: "onramp",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!(apiConfig == null ? void 0 : apiConfig.config)) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.onramp;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.onramp : false;
      }
      return localValue;
    }
  },
  activity: {
    apiFeatureName: "activity",
    localFeatureName: "history",
    returnType: false,
    isLegacy: true,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.activity;
      }
      return Boolean(localValue);
    }
  },
  reownBranding: {
    apiFeatureName: "reown_branding",
    localFeatureName: "reownBranding",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.reownBranding;
      }
      return Boolean(localValue);
    }
  },
  emailCapture: {
    apiFeatureName: "email_capture",
    localFeatureName: "emailCapture",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => apiConfig.isEnabled && (apiConfig.config ?? []),
    processFallback: (_localValue) => false
  },
  multiWallet: {
    apiFeatureName: "multi_wallet",
    localFeatureName: "multiWallet",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: () => ConstantsUtil2.DEFAULT_REMOTE_FEATURES.multiWallet
  },
  payWithExchange: {
    apiFeatureName: "fund_from_exchange",
    localFeatureName: "payWithExchange",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: () => ConstantsUtil2.DEFAULT_REMOTE_FEATURES.payWithExchange
  },
  payments: {
    apiFeatureName: "payments",
    localFeatureName: "payments",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: () => ConstantsUtil2.DEFAULT_REMOTE_FEATURES.payments
  },
  reownAuthentication: {
    apiFeatureName: "reown_authentication",
    localFeatureName: "reownAuthentication",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: (localValue) => {
      if (typeof localValue === "undefined") {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.reownAuthentication;
      }
      return Boolean(localValue);
    }
  }
};
var ConfigUtil = {
  localSettingsOverridden: /* @__PURE__ */ new Set(),
  getApiConfig(id, apiProjectConfig) {
    return apiProjectConfig == null ? void 0 : apiProjectConfig.find((f7) => f7.id === id);
  },
  addWarning(localFeatureValue, featureKey) {
    if (localFeatureValue !== void 0) {
      const config = featureConfig[featureKey];
      const warningName = config.isLegacy ? `"features.${config.localFeatureName}" (now "${featureKey}")` : `"features.${featureKey}"`;
      this.localSettingsOverridden.add(warningName);
    }
  },
  processFeature(featureKey, localFeatures, apiProjectConfig, useApi, isBasic) {
    const config = featureConfig[featureKey];
    const localValue = localFeatures[config.localFeatureName];
    if (isBasic && !config.isAvailableOnBasic) {
      return false;
    }
    if (useApi) {
      const apiConfig = this.getApiConfig(config.apiFeatureName, apiProjectConfig);
      if ((apiConfig == null ? void 0 : apiConfig.config) === null) {
        return this.processFallbackFeature(featureKey, localValue);
      }
      if (!(apiConfig == null ? void 0 : apiConfig.config)) {
        return false;
      }
      if (localValue !== void 0) {
        this.addWarning(localValue, featureKey);
      }
      return this.processApiFeature(featureKey, apiConfig);
    }
    return this.processFallbackFeature(featureKey, localValue);
  },
  processApiFeature(featureKey, apiConfig) {
    return featureConfig[featureKey].processApi(apiConfig);
  },
  processFallbackFeature(featureKey, localValue) {
    return featureConfig[featureKey].processFallback(localValue);
  },
  async fetchRemoteFeatures(config) {
    const isBasic = config.basic ?? false;
    const localFeatures = config.features || {};
    this.localSettingsOverridden.clear();
    let apiProjectConfig = null;
    let shouldUseApiConfig = false;
    try {
      apiProjectConfig = await ApiController.fetchProjectConfig();
      shouldUseApiConfig = apiProjectConfig !== null && apiProjectConfig !== void 0;
    } catch (e) {
      console.warn("[Reown Config] Failed to fetch remote project configuration. Using local/default values.", e);
    }
    const remoteFeaturesConfig = shouldUseApiConfig && !isBasic ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES : ConstantsUtil2.DEFAULT_REMOTE_FEATURES_DISABLED;
    try {
      for (const featureKey of FEATURE_KEYS) {
        const result = this.processFeature(featureKey, localFeatures, apiProjectConfig, shouldUseApiConfig, isBasic);
        Object.assign(remoteFeaturesConfig, { [featureKey]: result });
      }
    } catch (e) {
      console.warn("[Reown Config] Failed to process the configuration from Cloud. Using default values.", e);
      return ConstantsUtil2.DEFAULT_REMOTE_FEATURES;
    }
    if (shouldUseApiConfig && this.localSettingsOverridden.size > 0) {
      const warningMessage = `Your local configuration for ${Array.from(this.localSettingsOverridden).join(", ")} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;
      AlertController.open({
        debugMessage: ErrorUtil.ALERT_WARNINGS.LOCAL_CONFIGURATION_IGNORED.debugMessage(warningMessage)
      }, "warning");
    }
    return remoteFeaturesConfig;
  }
};

// node_modules/@reown/appkit/dist/esm/src/client/appkit-base-client.js
var AppKitBaseClient = class {
  constructor(options) {
    this.chainNamespaces = [];
    this.features = {};
    this.remoteFeatures = {};
    this.reportedAlertErrors = {};
    this.getCaipNetwork = (chainNamespace, id) => {
      var _a2, _b, _c2;
      if (chainNamespace) {
        const caipNetworkWithId = (_a2 = ChainController.getCaipNetworks(chainNamespace)) == null ? void 0 : _a2.find((c4) => c4.id === id);
        if (caipNetworkWithId) {
          return caipNetworkWithId;
        }
        const namespaceCaipNetwork = (_b = ChainController.getNetworkData(chainNamespace)) == null ? void 0 : _b.caipNetwork;
        if (namespaceCaipNetwork) {
          return namespaceCaipNetwork;
        }
        const requestedCaipNetworks = ChainController.getRequestedCaipNetworks(chainNamespace);
        return (_c2 = requestedCaipNetworks.filter((c4) => c4.chainNamespace === chainNamespace)) == null ? void 0 : _c2[0];
      }
      return ChainController.state.activeCaipNetwork || this.defaultCaipNetwork;
    };
    this.getCaipNetworkId = () => {
      const network = this.getCaipNetwork();
      if (network) {
        return network.id;
      }
      return void 0;
    };
    this.getCaipNetworks = (namespace) => ChainController.getCaipNetworks(namespace);
    this.getActiveChainNamespace = () => ChainController.state.activeChain;
    this.setRequestedCaipNetworks = (requestedCaipNetworks, chain) => {
      ChainController.setRequestedCaipNetworks(requestedCaipNetworks, chain);
    };
    this.getApprovedCaipNetworkIds = () => ChainController.getAllApprovedCaipNetworkIds();
    this.getCaipAddress = (chainNamespace) => {
      var _a2, _b;
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return ChainController.state.activeCaipAddress;
      }
      return (_b = (_a2 = ChainController.state.chains.get(chainNamespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.caipAddress;
    };
    this.setClientId = (clientId) => {
      BlockchainApiController.setClientId(clientId);
    };
    this.getProvider = (namespace) => ProviderUtil.getProvider(namespace);
    this.getProviderType = (namespace) => ProviderUtil.getProviderId(namespace);
    this.getPreferredAccountType = (namespace) => getPreferredAccountType(namespace);
    this.setCaipAddress = (caipAddress, chain) => {
      AccountController.setCaipAddress(caipAddress, chain);
    };
    this.setBalance = (balance, balanceSymbol, chain) => {
      AccountController.setBalance(balance, balanceSymbol, chain);
    };
    this.setProfileName = (profileName, chain) => {
      AccountController.setProfileName(profileName, chain);
    };
    this.setProfileImage = (profileImage, chain) => {
      AccountController.setProfileImage(profileImage, chain);
    };
    this.setUser = (user, chain) => {
      AccountController.setUser(user, chain);
    };
    this.resetAccount = (chain) => {
      AccountController.resetAccount(chain);
    };
    this.setCaipNetwork = (caipNetwork) => {
      ChainController.setActiveCaipNetwork(caipNetwork);
    };
    this.setCaipNetworkOfNamespace = (caipNetwork, chainNamespace) => {
      ChainController.setChainNetworkData(chainNamespace, { caipNetwork });
    };
    this.setStatus = (status, chain) => {
      AccountController.setStatus(status, chain);
      if (ConnectorController.isConnected()) {
        StorageUtil.setConnectionStatus("connected");
      } else {
        StorageUtil.setConnectionStatus("disconnected");
      }
    };
    this.getAddressByChainNamespace = (chainNamespace) => {
      var _a2, _b;
      return (_b = (_a2 = ChainController.state.chains.get(chainNamespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.address;
    };
    this.setConnectors = (connectors) => {
      const allConnectors = [...ConnectorController.state.allConnectors, ...connectors];
      ConnectorController.setConnectors(allConnectors);
    };
    this.setConnections = (connections, chainNamespace) => {
      StorageUtil.setConnections(connections, chainNamespace);
      ConnectionController.setConnections(connections, chainNamespace);
    };
    this.fetchIdentity = (request) => BlockchainApiController.fetchIdentity(request);
    this.getReownName = (address) => EnsController.getNamesForAddress(address);
    this.getConnectors = () => ConnectorController.getConnectors();
    this.getConnectorImage = (connector) => AssetUtil.getConnectorImage(connector);
    this.getConnections = (namespace) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return [];
      }
      return ConnectionControllerUtil.getConnectionsData(namespace).connections;
    };
    this.getRecentConnections = (namespace) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return [];
      }
      return ConnectionControllerUtil.getConnectionsData(namespace).recentConnections;
    };
    this.switchConnection = async (params) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return;
      }
      await ConnectionController.switchConnection(params);
    };
    this.deleteConnection = (params) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return;
      }
      StorageUtil.deleteAddressFromConnection(params);
      ConnectionController.syncStorageConnections();
    };
    this.setConnectedWalletInfo = (connectedWalletInfo, chain) => {
      const type = ProviderUtil.getProviderId(chain);
      const walletInfo = connectedWalletInfo ? { ...connectedWalletInfo, type } : void 0;
      AccountController.setConnectedWalletInfo(walletInfo, chain);
    };
    this.getIsConnectedState = () => Boolean(ChainController.state.activeCaipAddress);
    this.addAddressLabel = (address, label, chain) => {
      AccountController.addAddressLabel(address, label, chain);
    };
    this.removeAddressLabel = (address, chain) => {
      AccountController.removeAddressLabel(address, chain);
    };
    this.getAddress = (chainNamespace) => {
      var _a2, _b;
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return AccountController.state.address;
      }
      return (_b = (_a2 = ChainController.state.chains.get(chainNamespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.address;
    };
    this.setApprovedCaipNetworksData = (namespace) => ChainController.setApprovedCaipNetworksData(namespace);
    this.resetNetwork = (namespace) => {
      ChainController.resetNetwork(namespace);
    };
    this.addConnector = (connector) => {
      ConnectorController.addConnector(connector);
    };
    this.resetWcConnection = () => {
      ConnectionController.resetWcConnection();
    };
    this.setAddressExplorerUrl = (addressExplorerUrl, chain) => {
      AccountController.setAddressExplorerUrl(addressExplorerUrl, chain);
    };
    this.setSmartAccountDeployed = (isDeployed, chain) => {
      AccountController.setSmartAccountDeployed(isDeployed, chain);
    };
    this.setPreferredAccountType = (preferredAccountType, chain) => {
      ChainController.setAccountProp("preferredAccountType", preferredAccountType, chain);
    };
    this.setEIP6963Enabled = (enabled) => {
      OptionsController.setEIP6963Enabled(enabled);
    };
    this.handleUnsafeRPCRequest = () => {
      if (this.isOpen()) {
        if (this.isTransactionStackEmpty()) {
          return;
        }
        this.redirect("ApproveTransaction");
      } else {
        this.open({ view: "ApproveTransaction" });
      }
    };
    this.options = options;
    this.version = options.sdkVersion;
    this.caipNetworks = this.extendCaipNetworks(options);
    this.chainNamespaces = this.getChainNamespacesSet(options.adapters, this.caipNetworks);
    this.defaultCaipNetwork = this.extendDefaultCaipNetwork(options);
    this.chainAdapters = this.createAdapters(options.adapters);
    this.readyPromise = this.initialize(options);
  }
  getChainNamespacesSet(adapters, caipNetworks) {
    const adapterNamespaces = adapters == null ? void 0 : adapters.map((adapter) => adapter.namespace).filter((namespace) => Boolean(namespace));
    if (adapterNamespaces == null ? void 0 : adapterNamespaces.length) {
      return [...new Set(adapterNamespaces)];
    }
    const networkNamespaces = caipNetworks == null ? void 0 : caipNetworks.map((network) => network.chainNamespace);
    return [...new Set(networkNamespaces)];
  }
  async initialize(options) {
    var _a2, _b, _c2, _d, _e4;
    this.initializeProjectSettings(options);
    this.initControllers(options);
    await this.initChainAdapters();
    this.sendInitializeEvent(options);
    if (OptionsController.state.enableReconnect) {
      await this.syncExistingConnection();
      await this.syncAdapterConnections();
    } else {
      await this.unSyncExistingConnection();
    }
    this.remoteFeatures = await ConfigUtil.fetchRemoteFeatures(options);
    OptionsController.setRemoteFeatures(this.remoteFeatures);
    if (this.remoteFeatures.onramp) {
      OnRampController.setOnrampProviders(this.remoteFeatures.onramp);
    }
    if (((_a2 = OptionsController.state.remoteFeatures) == null ? void 0 : _a2.email) || Array.isArray((_b = OptionsController.state.remoteFeatures) == null ? void 0 : _b.socials) && ((_c2 = OptionsController.state.remoteFeatures) == null ? void 0 : _c2.socials.length) > 0) {
      await this.checkAllowedOrigins();
    }
    if (((_d = OptionsController.state.features) == null ? void 0 : _d.reownAuthentication) || ((_e4 = OptionsController.state.remoteFeatures) == null ? void 0 : _e4.reownAuthentication)) {
      const { ReownAuthentication } = await import("./features-UST5FGFF.js");
      const currentSIWX = OptionsController.state.siwx;
      if (!(currentSIWX instanceof ReownAuthentication)) {
        if (currentSIWX) {
          console.warn("ReownAuthentication option is enabled, SIWX configuration will be overridden.");
        }
        OptionsController.setSIWX(new ReownAuthentication());
      }
    }
  }
  async checkAllowedOrigins() {
    try {
      const allowedOrigins = await ApiController.fetchAllowedOrigins();
      if (!CoreHelperUtil.isClient()) {
        return;
      }
      const currentOrigin = window.location.origin;
      const isOriginAllowed = WcHelpersUtil.isOriginAllowed(currentOrigin, allowedOrigins, WcConstantsUtil.DEFAULT_ALLOWED_ANCESTORS);
      if (!isOriginAllowed) {
        AlertController.open(ErrorUtil.ALERT_ERRORS.ORIGIN_NOT_ALLOWED, "error");
      }
    } catch (error) {
      if (!(error instanceof Error)) {
        return;
      }
      switch (error.message) {
        case "RATE_LIMITED":
          AlertController.open(ErrorUtil.ALERT_ERRORS.RATE_LIMITED_APP_CONFIGURATION, "error");
          break;
        case "SERVER_ERROR": {
          const originalError = error.cause instanceof Error ? error.cause : error;
          AlertController.open({
            displayMessage: ErrorUtil.ALERT_ERRORS.SERVER_ERROR_APP_CONFIGURATION.displayMessage,
            debugMessage: ErrorUtil.ALERT_ERRORS.SERVER_ERROR_APP_CONFIGURATION.debugMessage(originalError.message)
          }, "error");
          break;
        }
        default:
          break;
      }
    }
  }
  sendInitializeEvent(options) {
    var _a2;
    const { ...optionsCopy } = options;
    delete optionsCopy.adapters;
    delete optionsCopy.universalProvider;
    EventsController.sendEvent({
      type: "track",
      event: "INITIALIZE",
      properties: {
        ...optionsCopy,
        networks: options.networks.map((n2) => n2.id),
        siweConfig: {
          options: ((_a2 = options.siweConfig) == null ? void 0 : _a2.options) || {}
        }
      }
    });
  }
  // -- Controllers initialization ---------------------------------------------------
  initControllers(options) {
    this.initializeOptionsController(options);
    this.initializeChainController(options);
    this.initializeThemeController(options);
    this.initializeConnectionController(options);
    this.initializeConnectorController();
  }
  initializeThemeController(options) {
    if (options.themeMode) {
      ThemeController.setThemeMode(options.themeMode);
    }
    if (options.themeVariables) {
      ThemeController.setThemeVariables(options.themeVariables);
    }
  }
  initializeChainController(options) {
    if (!this.connectionControllerClient || !this.networkControllerClient) {
      throw new Error("ConnectionControllerClient and NetworkControllerClient must be set");
    }
    ChainController.initialize(options.adapters ?? [], this.caipNetworks, {
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient
    });
    const network = this.getDefaultNetwork();
    if (network) {
      ChainController.setActiveCaipNetwork(network);
    }
  }
  initializeConnectionController(options) {
    ConnectionController.initialize(options.adapters ?? []);
    ConnectionController.setWcBasic(options.basic ?? false);
  }
  initializeConnectorController() {
    ConnectorController.initialize(this.chainNamespaces);
  }
  initializeProjectSettings(options) {
    OptionsController.setProjectId(options.projectId);
    OptionsController.setSdkVersion(options.sdkVersion);
  }
  initializeOptionsController(options) {
    var _a2;
    OptionsController.setDebug(options.debug !== false);
    OptionsController.setEnableWalletConnect(options.enableWalletConnect !== false);
    OptionsController.setEnableWalletGuide(options.enableWalletGuide !== false);
    OptionsController.setEnableWallets(options.enableWallets !== false);
    OptionsController.setEIP6963Enabled(options.enableEIP6963 !== false);
    OptionsController.setEnableNetworkSwitch(options.enableNetworkSwitch !== false);
    OptionsController.setEnableReconnect(options.enableReconnect !== false);
    OptionsController.setEnableAuthLogger(options.enableAuthLogger !== false);
    OptionsController.setCustomRpcUrls(options.customRpcUrls);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setAllWallets(options.allWallets);
    OptionsController.setIncludeWalletIds(options.includeWalletIds);
    OptionsController.setExcludeWalletIds(options.excludeWalletIds);
    OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
    OptionsController.setTokens(options.tokens);
    OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
    OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
    OptionsController.setCustomWallets(options.customWallets);
    OptionsController.setFeatures(options.features);
    OptionsController.setAllowUnsupportedChain(options.allowUnsupportedChain);
    OptionsController.setUniversalProviderConfigOverride(options.universalProviderConfigOverride);
    OptionsController.setPreferUniversalLinks(options.experimental_preferUniversalLinks);
    OptionsController.setDefaultAccountTypes(options.defaultAccountTypes);
    const defaultMetaData = this.getDefaultMetaData();
    if (!options.metadata && defaultMetaData) {
      options.metadata = defaultMetaData;
    }
    OptionsController.setMetadata(options.metadata);
    OptionsController.setDisableAppend(options.disableAppend);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setSIWX(options.siwx);
    this.features = OptionsController.state.features ?? {};
    if (!options.projectId) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      return;
    }
    const evmAdapter = (_a2 = options.adapters) == null ? void 0 : _a2.find((adapter) => adapter.namespace === ConstantsUtil.CHAIN.EVM);
    if (evmAdapter) {
      if (options.siweConfig) {
        if (options.siwx) {
          throw new Error("Cannot set both `siweConfig` and `siwx` options");
        }
        OptionsController.setSIWX(options.siweConfig.mapToSIWX());
      }
    }
  }
  getDefaultMetaData() {
    var _a2, _b, _c2, _d;
    if (CoreHelperUtil.isClient()) {
      return {
        name: ((_b = (_a2 = document.getElementsByTagName("title")) == null ? void 0 : _a2[0]) == null ? void 0 : _b.textContent) || "",
        description: ((_c2 = document.querySelector('meta[property="og:description"]')) == null ? void 0 : _c2.content) || "",
        url: window.location.origin,
        icons: [((_d = document.querySelector('link[rel~="icon"]')) == null ? void 0 : _d.href) || ""]
      };
    }
    return null;
  }
  // -- Network Initialization ---------------------------------------------------
  setUnsupportedNetwork(chainId) {
    const namespace = this.getActiveChainNamespace();
    if (namespace) {
      const unsupportedNetwork = CaipNetworksUtil.getUnsupportedNetwork(`${namespace}:${chainId}`);
      ChainController.setActiveCaipNetwork(unsupportedNetwork);
    }
  }
  getDefaultNetwork() {
    return CaipNetworksUtil.getCaipNetworkFromStorage(this.defaultCaipNetwork);
  }
  extendCaipNetwork(network, options) {
    const extendedNetwork = CaipNetworksUtil.extendCaipNetwork(network, {
      customNetworkImageUrls: options.chainImages,
      projectId: options.projectId
    });
    return extendedNetwork;
  }
  extendCaipNetworks(options) {
    const extendedNetworks = CaipNetworksUtil.extendCaipNetworks(options.networks, {
      customNetworkImageUrls: options.chainImages,
      customRpcUrls: options.customRpcUrls,
      projectId: options.projectId
    });
    return extendedNetworks;
  }
  extendDefaultCaipNetwork(options) {
    const defaultNetwork = options.networks.find((n2) => {
      var _a2;
      return n2.id === ((_a2 = options.defaultNetwork) == null ? void 0 : _a2.id);
    });
    const extendedNetwork = defaultNetwork ? CaipNetworksUtil.extendCaipNetwork(defaultNetwork, {
      customNetworkImageUrls: options.chainImages,
      customRpcUrls: options.customRpcUrls,
      projectId: options.projectId
    }) : void 0;
    return extendedNetwork;
  }
  async disconnectNamespace(namespace, id) {
    var _a2, _b;
    try {
      this.setLoading(true, namespace);
      let disconnectResult = {
        connections: []
      };
      const adapter = this.getAdapter(namespace);
      const caipAddress = (_b = (_a2 = ChainController.state.chains.get(namespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.caipAddress;
      if ((caipAddress || !OptionsController.state.enableReconnect) && (adapter == null ? void 0 : adapter.disconnect)) {
        disconnectResult = await adapter.disconnect({ id });
      }
      this.setLoading(false, namespace);
      return disconnectResult;
    } catch (error) {
      this.setLoading(false, namespace);
      throw new Error(`Failed to disconnect chains: ${error.message}`);
    }
  }
  // -- Client Initialization ---------------------------------------------------
  createClients() {
    this.connectionControllerClient = {
      connectWalletConnect: async () => {
        var _a2;
        const activeChain = ChainController.state.activeChain;
        const adapter = this.getAdapter(activeChain);
        const chainId = (_a2 = this.getCaipNetwork(activeChain)) == null ? void 0 : _a2.id;
        const connections = ConnectionController.getConnections(activeChain);
        const isMultiWallet = this.remoteFeatures.multiWallet;
        const hasConnections = connections.length > 0;
        if (!adapter) {
          throw new Error("Adapter not found");
        }
        const result = await adapter.connectWalletConnect(chainId);
        const shouldClose = !hasConnections || !isMultiWallet;
        if (shouldClose) {
          this.close();
        }
        this.setClientId((result == null ? void 0 : result.clientId) || null);
        StorageUtil.setConnectedNamespaces([...ChainController.state.chains.keys()]);
        await this.syncWalletConnectAccount();
        await SIWXUtil.initializeIfEnabled();
      },
      connectExternal: async (params) => {
        const connectResult = await this.onConnectExternal(params);
        await this.connectInactiveNamespaces(params, connectResult);
        return connectResult ? { address: connectResult.address } : void 0;
      },
      reconnectExternal: async ({ id, info, type, provider }) => {
        var _a2;
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(namespace);
        if (!namespace) {
          throw new Error("reconnectExternal: namespace not found");
        }
        if (!adapter) {
          throw new Error("reconnectExternal: adapter not found");
        }
        if (adapter == null ? void 0 : adapter.reconnect) {
          await (adapter == null ? void 0 : adapter.reconnect({ id, info, type, provider, chainId: (_a2 = this.getCaipNetwork()) == null ? void 0 : _a2.id }));
          StorageUtil.addConnectedNamespace(namespace);
          this.syncConnectedWalletInfo(namespace);
        }
      },
      disconnect: async (params) => {
        var _a2;
        const { id: connectorIdParam, chainNamespace, initialDisconnect } = params || {};
        const namespace = chainNamespace || ChainController.state.activeChain;
        const namespaceConnectorId = ConnectorController.getConnectorId(namespace);
        const isAuth = connectorIdParam === ConstantsUtil.CONNECTOR_ID.AUTH || namespaceConnectorId === ConstantsUtil.CONNECTOR_ID.AUTH;
        const isWalletConnect = connectorIdParam === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT || namespaceConnectorId === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
        try {
          const namespaces = Array.from(ChainController.state.chains.keys());
          let namespacesToDisconnect = chainNamespace ? [chainNamespace] : namespaces;
          if (isWalletConnect || isAuth) {
            namespacesToDisconnect = namespaces;
          }
          const disconnectPromises = namespacesToDisconnect.map(async (ns3) => {
            const connectorIdToDisconnect = ConnectorController.getConnectorId(ns3);
            const disconnectData = await this.disconnectNamespace(ns3, connectorIdParam || connectorIdToDisconnect);
            if (disconnectData) {
              if (isAuth) {
                StorageUtil.deleteConnectedSocialProvider();
              }
              disconnectData.connections.forEach((connection) => {
                StorageUtil.addDisconnectedConnectorId(connection.connectorId, ns3);
              });
            }
            if (initialDisconnect) {
              this.onDisconnectNamespace({ chainNamespace: ns3, closeModal: false });
            }
          });
          const disconnectResults = await Promise.allSettled(disconnectPromises);
          SendController.resetSend();
          ConnectionController.resetWcConnection();
          if ((_a2 = SIWXUtil.getSIWX()) == null ? void 0 : _a2.signOutOnDisconnect) {
            await SIWXUtil.clearSessions();
          }
          ConnectorController.setFilterByNamespace(void 0);
          ConnectionController.syncStorageConnections();
          const failures = disconnectResults.filter((result) => result.status === "rejected");
          if (failures.length > 0) {
            throw new Error(failures.map((f7) => f7.reason.message).join(", "));
          }
          EventsController.sendEvent({
            type: "track",
            event: "DISCONNECT_SUCCESS",
            properties: {
              namespace: chainNamespace || "all"
            }
          });
        } catch (error) {
          throw new Error(`Failed to disconnect chains: ${error.message}`);
        }
      },
      checkInstalled: (ids) => {
        if (!ids) {
          return Boolean(window.ethereum);
        }
        return ids.some((id) => {
          var _a2;
          return Boolean((_a2 = window.ethereum) == null ? void 0 : _a2[String(id)]);
        });
      },
      signMessage: async (message) => {
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!namespace) {
          throw new Error("signMessage: namespace not found");
        }
        if (!adapter) {
          throw new Error("signMessage: adapter not found");
        }
        const result = await (adapter == null ? void 0 : adapter.signMessage({
          message,
          address: AccountController.state.address,
          provider: ProviderUtil.getProvider(namespace)
        }));
        return (result == null ? void 0 : result.signature) || "";
      },
      sendTransaction: async (args) => {
        const namespace = args.chainNamespace;
        if (!namespace) {
          throw new Error("sendTransaction: namespace not found");
        }
        if (ConstantsUtil2.SEND_SUPPORTED_NAMESPACES.includes(namespace)) {
          const adapter = this.getAdapter(namespace);
          if (!adapter) {
            throw new Error("sendTransaction: adapter not found");
          }
          const provider = ProviderUtil.getProvider(namespace);
          const result = await (adapter == null ? void 0 : adapter.sendTransaction({
            ...args,
            caipNetwork: this.getCaipNetwork(),
            provider
          }));
          return (result == null ? void 0 : result.hash) || "";
        }
        return "";
      },
      estimateGas: async (args) => {
        const namespace = args.chainNamespace;
        if (namespace === ConstantsUtil.CHAIN.EVM) {
          const adapter = this.getAdapter(namespace);
          if (!adapter) {
            throw new Error("estimateGas: adapter is required but got undefined");
          }
          const provider = ProviderUtil.getProvider(namespace);
          const caipNetwork = this.getCaipNetwork();
          if (!caipNetwork) {
            throw new Error("estimateGas: caipNetwork is required but got undefined");
          }
          const result = await (adapter == null ? void 0 : adapter.estimateGas({ ...args, provider, caipNetwork }));
          return (result == null ? void 0 : result.gas) || 0n;
        }
        return 0n;
      },
      getEnsAvatar: async () => {
        var _a2;
        const namespace = ChainController.state.activeChain;
        if (!namespace) {
          throw new Error("getEnsAvatar: namespace is required but got undefined");
        }
        await this.syncIdentity({
          address: AccountController.state.address,
          chainId: Number((_a2 = this.getCaipNetwork()) == null ? void 0 : _a2.id),
          chainNamespace: namespace
        });
        return AccountController.state.profileImage || false;
      },
      getEnsAddress: async (name) => await WcHelpersUtil.resolveReownName(name),
      writeContract: async (args) => {
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(namespace);
        if (!namespace) {
          throw new Error("writeContract: namespace is required but got undefined");
        }
        if (!adapter) {
          throw new Error("writeContract: adapter is required but got undefined");
        }
        const caipNetwork = this.getCaipNetwork();
        const caipAddress = this.getCaipAddress();
        const provider = ProviderUtil.getProvider(namespace);
        if (!caipNetwork || !caipAddress) {
          throw new Error("writeContract: caipNetwork or caipAddress is required but got undefined");
        }
        const result = await (adapter == null ? void 0 : adapter.writeContract({ ...args, caipNetwork, provider, caipAddress }));
        return result == null ? void 0 : result.hash;
      },
      parseUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("parseUnits: adapter is required but got undefined");
        }
        return (adapter == null ? void 0 : adapter.parseUnits({ value, decimals })) ?? 0n;
      },
      formatUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("formatUnits: adapter is required but got undefined");
        }
        return (adapter == null ? void 0 : adapter.formatUnits({ value, decimals })) ?? "0";
      },
      getCapabilities: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("getCapabilities: adapter is required but got undefined");
        }
        return await (adapter == null ? void 0 : adapter.getCapabilities(params));
      },
      grantPermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("grantPermissions: adapter is required but got undefined");
        }
        return await (adapter == null ? void 0 : adapter.grantPermissions(params));
      },
      revokePermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("revokePermissions: adapter is required but got undefined");
        }
        if (adapter == null ? void 0 : adapter.revokePermissions) {
          return await adapter.revokePermissions(params);
        }
        return "0x";
      },
      walletGetAssets: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("walletGetAssets: adapter is required but got undefined");
        }
        return await (adapter == null ? void 0 : adapter.walletGetAssets(params)) ?? {};
      },
      updateBalance: (namespace) => {
        const caipNetwork = this.getCaipNetwork(namespace);
        if (!caipNetwork || !AccountController.state.address) {
          return;
        }
        this.updateNativeBalance(AccountController.state.address, caipNetwork == null ? void 0 : caipNetwork.id, namespace);
      }
    };
    this.networkControllerClient = {
      switchCaipNetwork: async (caipNetwork) => await this.switchCaipNetwork(caipNetwork),
      // eslint-disable-next-line @typescript-eslint/require-await
      getApprovedCaipNetworksData: async () => this.getApprovedCaipNetworksData()
    };
    ConnectionController.setClient(this.connectionControllerClient);
  }
  async onConnectExternal(params) {
    var _a2, _b, _c2, _d, _e4, _f2, _g, _h;
    const activeChain = ChainController.state.activeChain;
    const namespace = params.chain || activeChain;
    const adapter = this.getAdapter(namespace);
    let shouldUpdateNetwork = true;
    if (params.type === ConstantsUtil3.CONNECTOR_TYPE_AUTH) {
      const authNamespaces = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS;
      const hasConnectedAuthNamespace = authNamespaces.some((namespace2) => ConnectorController.getConnectorId(namespace2) === ConstantsUtil.CONNECTOR_ID.AUTH);
      if (hasConnectedAuthNamespace && params.chain !== activeChain) {
        shouldUpdateNetwork = false;
      }
    }
    if (params.chain && params.chain !== activeChain && !params.caipNetwork) {
      const toConnectNetwork = this.getCaipNetworks().find((network) => network.chainNamespace === params.chain);
      if (toConnectNetwork && shouldUpdateNetwork) {
        this.setCaipNetwork(toConnectNetwork);
      }
    }
    if (!namespace) {
      throw new Error("connectExternal: namespace not found");
    }
    if (!adapter) {
      throw new Error("connectExternal: adapter not found");
    }
    const fallbackCaipNetwork = this.getCaipNetwork(namespace);
    const caipNetworkToUse = params.caipNetwork || fallbackCaipNetwork;
    const res = await adapter.connect({
      id: params.id,
      address: params.address,
      info: params.info,
      type: params.type,
      provider: params.provider,
      socialUri: params.socialUri,
      chainId: ((_a2 = params.caipNetwork) == null ? void 0 : _a2.id) || (fallbackCaipNetwork == null ? void 0 : fallbackCaipNetwork.id),
      rpcUrl: ((_e4 = (_d = (_c2 = (_b = params.caipNetwork) == null ? void 0 : _b.rpcUrls) == null ? void 0 : _c2.default) == null ? void 0 : _d.http) == null ? void 0 : _e4[0]) || ((_h = (_g = (_f2 = fallbackCaipNetwork == null ? void 0 : fallbackCaipNetwork.rpcUrls) == null ? void 0 : _f2.default) == null ? void 0 : _g.http) == null ? void 0 : _h[0])
    });
    if (!res) {
      return void 0;
    }
    StorageUtil.addConnectedNamespace(namespace);
    this.syncProvider({ ...res, chainNamespace: namespace });
    this.setStatus("connected", namespace);
    this.syncConnectedWalletInfo(namespace);
    StorageUtil.removeDisconnectedConnectorId(params.id, namespace);
    return { address: res.address, connectedCaipNetwork: caipNetworkToUse };
  }
  async connectInactiveNamespaces(params, connectResult) {
    var _a2;
    const isConnectingToAuth = params.type === ConstantsUtil3.CONNECTOR_TYPE_AUTH;
    const otherAuthNamespaces = HelpersUtil.getOtherAuthNamespaces((_a2 = connectResult == null ? void 0 : connectResult.connectedCaipNetwork) == null ? void 0 : _a2.chainNamespace);
    const activeCaipNetwork = ChainController.state.activeCaipNetwork;
    const activeAdapter = this.getAdapter(activeCaipNetwork == null ? void 0 : activeCaipNetwork.chainNamespace);
    const activeProvider = ProviderUtil.getProvider(activeCaipNetwork == null ? void 0 : activeCaipNetwork.chainNamespace);
    if (isConnectingToAuth) {
      await Promise.all(otherAuthNamespaces.map(async (ns3) => {
        var _a3, _b, _c2;
        try {
          const provider = ProviderUtil.getProvider(ns3);
          const caipNetworkToUse = this.getCaipNetwork(ns3);
          const adapter = this.getAdapter(ns3);
          const res = await (adapter == null ? void 0 : adapter.connect({
            ...params,
            provider,
            socialUri: void 0,
            chainId: caipNetworkToUse == null ? void 0 : caipNetworkToUse.id,
            rpcUrl: (_c2 = (_b = (_a3 = caipNetworkToUse == null ? void 0 : caipNetworkToUse.rpcUrls) == null ? void 0 : _a3.default) == null ? void 0 : _b.http) == null ? void 0 : _c2[0]
          }));
          if (res) {
            StorageUtil.addConnectedNamespace(ns3);
            StorageUtil.removeDisconnectedConnectorId(params.id, ns3);
            this.setStatus("connected", ns3);
            this.syncConnectedWalletInfo(ns3);
          }
        } catch (error) {
          AlertController.warn(ErrorUtil.ALERT_WARNINGS.INACTIVE_NAMESPACE_NOT_CONNECTED.displayMessage, ErrorUtil.ALERT_WARNINGS.INACTIVE_NAMESPACE_NOT_CONNECTED.debugMessage(ns3, error instanceof Error ? error.message : void 0), ErrorUtil.ALERT_WARNINGS.INACTIVE_NAMESPACE_NOT_CONNECTED.code);
        }
      }));
      if (activeCaipNetwork) {
        await (activeAdapter == null ? void 0 : activeAdapter.switchNetwork({
          caipNetwork: activeCaipNetwork,
          provider: activeProvider,
          providerType: params.type
        }));
      }
    }
  }
  getApprovedCaipNetworksData() {
    var _a2, _b, _c2, _d, _e4;
    const providerType = ProviderUtil.getProviderId(ChainController.state.activeChain);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
      const namespaces = (_b = (_a2 = this.universalProvider) == null ? void 0 : _a2.session) == null ? void 0 : _b.namespaces;
      return {
        /*
         * MetaMask Wallet only returns 1 namespace in the session object. This makes it imposible
         * to switch to other networks. Setting supportsAllNetworks to true for MetaMask Wallet
         * will make it possible to switch to other networks.
         */
        supportsAllNetworks: ((_e4 = (_d = (_c2 = this.universalProvider) == null ? void 0 : _c2.session) == null ? void 0 : _d.peer) == null ? void 0 : _e4.metadata.name) === "MetaMask Wallet",
        approvedCaipNetworkIds: this.getChainsFromNamespaces(namespaces)
      };
    }
    return { supportsAllNetworks: true, approvedCaipNetworkIds: [] };
  }
  async switchCaipNetwork(caipNetwork) {
    if (!caipNetwork) {
      return;
    }
    const networkNamespace = caipNetwork.chainNamespace;
    const namespaceAddress = this.getAddressByChainNamespace(caipNetwork.chainNamespace);
    if (namespaceAddress) {
      const provider = ProviderUtil.getProvider(networkNamespace);
      const providerType = ProviderUtil.getProviderId(networkNamespace);
      if (caipNetwork.chainNamespace === ChainController.state.activeChain) {
        const adapter = this.getAdapter(networkNamespace);
        await (adapter == null ? void 0 : adapter.switchNetwork({ caipNetwork, provider, providerType }));
      } else {
        this.setCaipNetwork(caipNetwork);
        if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
          this.syncWalletConnectAccount();
        } else {
          const address = this.getAddressByChainNamespace(networkNamespace);
          if (address) {
            this.syncAccount({
              address,
              chainId: caipNetwork.id,
              chainNamespace: networkNamespace
            });
          }
        }
      }
    } else {
      this.setCaipNetwork(caipNetwork);
    }
  }
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const { chainId, chainNamespace } = ParseUtil.parseCaipAddress(account);
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  }
  // -- Adapter Initialization ---------------------------------------------------
  createAdapters(blueprints) {
    this.createClients();
    return this.chainNamespaces.reduce((adapters, namespace) => {
      var _a2;
      const blueprint = blueprints == null ? void 0 : blueprints.find((b3) => b3.namespace === namespace);
      if (blueprint) {
        blueprint.construct({
          namespace,
          projectId: (_a2 = this.options) == null ? void 0 : _a2.projectId,
          networks: this.getCaipNetworks()
        });
        adapters[namespace] = blueprint;
      } else {
        adapters[namespace] = new UniversalAdapter({
          namespace,
          networks: this.getCaipNetworks()
        });
      }
      return adapters;
    }, {});
  }
  async initChainAdapter(namespace) {
    var _a2;
    this.onConnectors(namespace);
    this.listenAdapter(namespace);
    await ((_a2 = this.chainAdapters) == null ? void 0 : _a2[namespace].syncConnectors(this.options, this));
    await this.createUniversalProviderForAdapter(namespace);
  }
  async initChainAdapters() {
    await Promise.all(this.chainNamespaces.map(async (namespace) => {
      await this.initChainAdapter(namespace);
    }));
  }
  onConnectors(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    adapter == null ? void 0 : adapter.on("connectors", this.setConnectors.bind(this));
  }
  listenAdapter(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    if (!adapter) {
      return;
    }
    const connectionStatus = StorageUtil.getConnectionStatus();
    if (OptionsController.state.enableReconnect === false) {
      this.setStatus("disconnected", chainNamespace);
    } else if (connectionStatus === "connected") {
      this.setStatus("connecting", chainNamespace);
    } else if (connectionStatus === "disconnected") {
      StorageUtil.clearAddressCache();
      this.setStatus(connectionStatus, chainNamespace);
    } else {
      this.setStatus(connectionStatus, chainNamespace);
    }
    adapter.on("switchNetwork", ({ address, chainId }) => {
      var _a2, _b;
      const caipNetwork = this.getCaipNetworks().find((n2) => n2.id.toString() === chainId.toString() || n2.caipNetworkId.toString() === chainId.toString());
      const isSameNamespace = ChainController.state.activeChain === chainNamespace;
      const accountAddress = (_b = (_a2 = ChainController.state.chains.get(chainNamespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.address;
      if (caipNetwork) {
        const account = isSameNamespace && address ? address : accountAddress;
        if (account) {
          this.syncAccount({ address: account, chainId: caipNetwork.id, chainNamespace });
        }
      } else {
        this.setUnsupportedNetwork(chainId);
      }
    });
    adapter.on("disconnect", () => {
      const isMultiWallet = this.remoteFeatures.multiWallet;
      const allConnections = Array.from(ConnectionController.state.connections.values()).flat();
      this.onDisconnectNamespace({
        chainNamespace,
        closeModal: !isMultiWallet || allConnections.length === 0
      });
    });
    adapter.on("connections", (connections) => {
      this.setConnections(connections, chainNamespace);
    });
    adapter.on("pendingTransactions", () => {
      const address = AccountController.state.address;
      const activeCaipNetwork = ChainController.state.activeCaipNetwork;
      if (!address || !(activeCaipNetwork == null ? void 0 : activeCaipNetwork.id)) {
        return;
      }
      this.updateNativeBalance(address, activeCaipNetwork.id, activeCaipNetwork.chainNamespace);
    });
    adapter.on("accountChanged", ({ address, chainId, connector }) => {
      var _a2, _b;
      const isActiveChain = ChainController.state.activeChain === chainNamespace;
      if (connector == null ? void 0 : connector.provider) {
        this.syncProvider({
          id: connector.id,
          type: connector.type,
          provider: connector.provider,
          chainNamespace
        });
        this.syncConnectedWalletInfo(chainNamespace);
      }
      const namespaceNetworkId = (_b = (_a2 = ChainController.getNetworkData(chainNamespace)) == null ? void 0 : _a2.caipNetwork) == null ? void 0 : _b.id;
      const syncAccountChainId = chainId || namespaceNetworkId;
      if (isActiveChain && syncAccountChainId) {
        this.syncAccount({
          address,
          chainId: syncAccountChainId,
          chainNamespace
        });
      } else if (!isActiveChain && syncAccountChainId) {
        this.syncAccountInfo(address, syncAccountChainId, chainNamespace);
        this.syncBalance({ address, chainId: syncAccountChainId, chainNamespace });
      } else {
        this.syncAccountInfo(address, chainId, chainNamespace);
      }
      StorageUtil.addConnectedNamespace(chainNamespace);
    });
  }
  async createUniversalProviderForAdapter(chainNamespace) {
    var _a2, _b, _c2;
    await this.getUniversalProvider();
    if (this.universalProvider) {
      await ((_c2 = (_b = (_a2 = this.chainAdapters) == null ? void 0 : _a2[chainNamespace]) == null ? void 0 : _b.setUniversalProvider) == null ? void 0 : _c2.call(_b, this.universalProvider));
    }
  }
  // -- Connection Sync ---------------------------------------------------
  async syncExistingConnection() {
    await Promise.allSettled(this.chainNamespaces.map((namespace) => this.syncNamespaceConnection(namespace)));
  }
  async unSyncExistingConnection() {
    try {
      await Promise.allSettled(this.chainNamespaces.map((namespace) => ConnectionController.disconnect({ namespace, initialDisconnect: true })));
    } catch (error) {
      console.error("Error disconnecting existing connections:", error);
    }
  }
  async reconnectWalletConnect() {
    var _a2, _b, _c2, _d;
    await this.syncWalletConnectAccount();
    const address = this.getAddress();
    EventsController.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      address,
      properties: {
        method: CoreHelperUtil.isMobile() ? "mobile" : "qrcode",
        name: ((_d = (_c2 = (_b = (_a2 = this.universalProvider) == null ? void 0 : _a2.session) == null ? void 0 : _b.peer) == null ? void 0 : _c2.metadata) == null ? void 0 : _d.name) || "Unknown",
        reconnect: true
      }
    });
  }
  async syncNamespaceConnection(namespace) {
    try {
      if (namespace === ConstantsUtil.CHAIN.EVM && CoreHelperUtil.isSafeApp()) {
        ConnectorController.setConnectorId(ConstantsUtil.CONNECTOR_ID.SAFE, namespace);
      }
      const connectorId = ConnectorController.getConnectorId(namespace);
      this.setStatus("connecting", namespace);
      switch (connectorId) {
        case ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT:
          await this.reconnectWalletConnect();
          break;
        case ConstantsUtil.CONNECTOR_ID.AUTH:
          break;
        default:
          await this.syncAdapterConnection(namespace);
      }
    } catch (err) {
      console.warn("AppKit couldn't sync existing connection", err);
      this.setStatus("disconnected", namespace);
    }
  }
  onDisconnectNamespace(options) {
    const { chainNamespace, closeModal } = options || {};
    ChainController.resetAccount(chainNamespace);
    ChainController.resetNetwork(chainNamespace);
    StorageUtil.removeConnectedNamespace(chainNamespace);
    const namespaces = Array.from(ChainController.state.chains.keys());
    const namespacesToDisconnect = chainNamespace ? [chainNamespace] : namespaces;
    namespacesToDisconnect.forEach((ns3) => StorageUtil.addDisconnectedConnectorId(ConnectorController.getConnectorId(ns3) || "", ns3));
    ConnectorController.removeConnectorId(chainNamespace);
    ProviderUtil.resetChain(chainNamespace);
    this.setUser(void 0, chainNamespace);
    this.setStatus("disconnected", chainNamespace);
    this.setConnectedWalletInfo(void 0, chainNamespace);
    if (closeModal !== false) {
      ModalController.close();
    }
  }
  async syncAdapterConnections() {
    await Promise.allSettled(this.chainNamespaces.map((namespace) => {
      var _a2;
      const caipAddress = this.getCaipAddress(namespace);
      const caipNetwork = this.getCaipNetwork(namespace);
      return (_a2 = this.chainAdapters) == null ? void 0 : _a2[namespace].syncConnections({
        connectToFirstConnector: !caipAddress,
        caipNetwork,
        getConnectorStorageInfo(connectorId) {
          const storageConnectionsByNamespace = StorageUtil.getConnections();
          const storageConnections = storageConnectionsByNamespace[namespace] ?? [];
          return {
            hasDisconnected: StorageUtil.isConnectorDisconnected(connectorId, namespace),
            hasConnected: storageConnections.some((c4) => HelpersUtil.isLowerCaseMatch(c4.connectorId, connectorId))
          };
        }
      });
    }));
  }
  async syncAdapterConnection(namespace) {
    var _a2, _b, _c2, _d;
    const adapter = this.getAdapter(namespace);
    const connectorId = ConnectorController.getConnectorId(namespace);
    const caipNetwork = this.getCaipNetwork(namespace);
    const connectors = ConnectorController.getConnectors(namespace);
    const connector = connectors.find((c4) => c4.id === connectorId);
    try {
      if (!adapter || !connector) {
        throw new Error(`Adapter or connector not found for namespace ${namespace}`);
      }
      if (!(caipNetwork == null ? void 0 : caipNetwork.id)) {
        throw new Error("CaipNetwork not found");
      }
      const connection = await (adapter == null ? void 0 : adapter.syncConnection({
        namespace,
        id: connector.id,
        chainId: caipNetwork.id,
        rpcUrl: (_c2 = (_b = (_a2 = caipNetwork == null ? void 0 : caipNetwork.rpcUrls) == null ? void 0 : _a2.default) == null ? void 0 : _b.http) == null ? void 0 : _c2[0]
      }));
      if (connection) {
        this.syncProvider({ ...connection, chainNamespace: namespace });
        await this.syncAccount({ ...connection, chainNamespace: namespace });
        this.setStatus("connected", namespace);
        EventsController.sendEvent({
          type: "track",
          event: "CONNECT_SUCCESS",
          address: connection.address,
          properties: {
            method: "browser",
            name: ((_d = connector.info) == null ? void 0 : _d.name) || connector.name || "Unknown",
            reconnect: true
          }
        });
      } else {
        this.setStatus("disconnected", namespace);
      }
    } catch (e) {
      this.onDisconnectNamespace({ chainNamespace: namespace, closeModal: false });
    }
  }
  async syncWalletConnectAccount() {
    var _a2, _b;
    const sessionNamespaces = Object.keys(((_b = (_a2 = this.universalProvider) == null ? void 0 : _a2.session) == null ? void 0 : _b.namespaces) || {});
    const syncTasks = this.chainNamespaces.map(async (chainNamespace) => {
      var _a3, _b2, _c2, _d, _e4;
      const adapter = this.getAdapter(chainNamespace);
      if (!adapter) {
        return;
      }
      const namespaceAccounts = ((_d = (_c2 = (_b2 = (_a3 = this.universalProvider) == null ? void 0 : _a3.session) == null ? void 0 : _b2.namespaces) == null ? void 0 : _c2[chainNamespace]) == null ? void 0 : _d.accounts) || [];
      const activeChainId = (_e4 = ChainController.state.activeCaipNetwork) == null ? void 0 : _e4.id;
      const sessionAddress = namespaceAccounts.find((account) => {
        const { chainId } = ParseUtil.parseCaipAddress(account);
        return chainId === (activeChainId == null ? void 0 : activeChainId.toString());
      }) || namespaceAccounts[0];
      if (sessionAddress) {
        const caipAddress = ParseUtil.validateCaipAddress(sessionAddress);
        const { chainId, address } = ParseUtil.parseCaipAddress(caipAddress);
        ProviderUtil.setProviderId(chainNamespace, ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT);
        if (this.caipNetworks && ChainController.state.activeCaipNetwork && adapter.namespace !== ConstantsUtil.CHAIN.EVM) {
          const provider = adapter.getWalletConnectProvider({
            caipNetworks: this.getCaipNetworks(),
            provider: this.universalProvider,
            activeCaipNetwork: ChainController.state.activeCaipNetwork
          });
          ProviderUtil.setProvider(chainNamespace, provider);
        } else {
          ProviderUtil.setProvider(chainNamespace, this.universalProvider);
        }
        ConnectorController.setConnectorId(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT, chainNamespace);
        StorageUtil.addConnectedNamespace(chainNamespace);
        await this.syncAccount({
          address,
          chainId,
          chainNamespace
        });
      } else if (sessionNamespaces.includes(chainNamespace)) {
        this.setStatus("disconnected", chainNamespace);
      }
      this.syncConnectedWalletInfo(chainNamespace);
      await ChainController.setApprovedCaipNetworksData(chainNamespace);
    });
    await Promise.all(syncTasks);
  }
  syncProvider({ type, provider, id, chainNamespace }) {
    ProviderUtil.setProviderId(chainNamespace, type);
    ProviderUtil.setProvider(chainNamespace, provider);
    ConnectorController.setConnectorId(id, chainNamespace);
  }
  async syncAccount(params) {
    var _a2, _b;
    const isActiveNamespace = params.chainNamespace === ChainController.state.activeChain;
    const networkOfChain = ChainController.getCaipNetworkByNamespace(params.chainNamespace, params.chainId);
    const { address, chainId, chainNamespace } = params;
    const { chainId: activeChainId } = StorageUtil.getActiveNetworkProps();
    const chainIdToUse = chainId || activeChainId;
    const isUnsupportedNetwork = ((_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.name) === ConstantsUtil.UNSUPPORTED_NETWORK_NAME;
    const shouldSupportAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", chainNamespace);
    this.setStatus("connected", chainNamespace);
    if (isUnsupportedNetwork && !shouldSupportAllNetworks) {
      return;
    }
    if (chainIdToUse) {
      let caipNetwork = this.getCaipNetworks().find((n2) => n2.id.toString() === chainIdToUse.toString());
      let fallbackCaipNetwork = this.getCaipNetworks().find((n2) => n2.chainNamespace === chainNamespace);
      if (!shouldSupportAllNetworks && !caipNetwork && !fallbackCaipNetwork) {
        const caipNetworkIds = this.getApprovedCaipNetworkIds() || [];
        const caipNetworkId = caipNetworkIds.find((id) => {
          var _a3;
          return ((_a3 = ParseUtil.parseCaipNetworkId(id)) == null ? void 0 : _a3.chainId) === chainIdToUse.toString();
        });
        const fallBackCaipNetworkId = caipNetworkIds.find((id) => {
          var _a3;
          return ((_a3 = ParseUtil.parseCaipNetworkId(id)) == null ? void 0 : _a3.chainNamespace) === chainNamespace;
        });
        caipNetwork = this.getCaipNetworks().find((n2) => n2.caipNetworkId === caipNetworkId);
        fallbackCaipNetwork = this.getCaipNetworks().find((n2) => n2.caipNetworkId === fallBackCaipNetworkId || // This is a workaround used in Solana network to support deprecated caipNetworkId
        "deprecatedCaipNetworkId" in n2 && n2.deprecatedCaipNetworkId === fallBackCaipNetworkId);
      }
      const network = caipNetwork || fallbackCaipNetwork;
      if ((network == null ? void 0 : network.chainNamespace) === ChainController.state.activeChain) {
        if (OptionsController.state.enableNetworkSwitch && !OptionsController.state.allowUnsupportedChain && ((_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.name) === ConstantsUtil.UNSUPPORTED_NETWORK_NAME) {
          ChainController.showUnsupportedChainUI();
        } else {
          this.setCaipNetwork(network);
        }
      } else if (!isActiveNamespace) {
        if (networkOfChain) {
          this.setCaipNetworkOfNamespace(networkOfChain, chainNamespace);
        }
      }
      this.syncConnectedWalletInfo(chainNamespace);
      if (!HelpersUtil.isLowerCaseMatch(address, AccountController.state.address)) {
        this.syncAccountInfo(address, network == null ? void 0 : network.id, chainNamespace);
      }
      if (isActiveNamespace) {
        await this.syncBalance({ address, chainId: network == null ? void 0 : network.id, chainNamespace });
      } else {
        await this.syncBalance({ address, chainId: networkOfChain == null ? void 0 : networkOfChain.id, chainNamespace });
      }
      this.syncIdentity({
        address,
        chainId,
        chainNamespace
      });
    }
  }
  async syncAccountInfo(address, chainId, chainNamespace) {
    const caipAddress = this.getCaipAddress(chainNamespace);
    const newChainId = chainId || (caipAddress == null ? void 0 : caipAddress.split(":")[1]);
    if (!newChainId) {
      return;
    }
    const newCaipAddress = `${chainNamespace}:${newChainId}:${address}`;
    this.setCaipAddress(newCaipAddress, chainNamespace);
    await this.syncIdentity({
      address,
      chainId: newChainId,
      chainNamespace
    });
  }
  async syncReownName(address, chainNamespace) {
    try {
      const registeredWcNames = await this.getReownName(address);
      if (registeredWcNames[0]) {
        const wcName = registeredWcNames[0];
        this.setProfileName(wcName.name, chainNamespace);
      } else {
        this.setProfileName(null, chainNamespace);
      }
    } catch {
      this.setProfileName(null, chainNamespace);
    }
  }
  syncConnectedWalletInfo(chainNamespace) {
    var _a2;
    const connectorId = ConnectorController.getConnectorId(chainNamespace);
    const providerType = ProviderUtil.getProviderId(chainNamespace);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_ANNOUNCED || providerType === ConstantsUtil3.CONNECTOR_TYPE_INJECTED) {
      if (connectorId) {
        const connectors = this.getConnectors();
        const connector = connectors.find((c4) => {
          var _a3, _b;
          const isConnectorId = c4.id === connectorId;
          const isRdns = ((_a3 = c4.info) == null ? void 0 : _a3.rdns) === connectorId;
          const hasMultiChainConnector = (_b = c4.connectors) == null ? void 0 : _b.some((_c2) => {
            var _a4;
            return _c2.id === connectorId || ((_a4 = _c2.info) == null ? void 0 : _a4.rdns) === connectorId;
          });
          return isConnectorId || isRdns || Boolean(hasMultiChainConnector);
        });
        if (connector) {
          const { info, name, imageUrl } = connector;
          const icon = imageUrl || this.getConnectorImage(connector);
          this.setConnectedWalletInfo({ name, icon, ...info }, chainNamespace);
        }
      }
    } else if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
      const provider = ProviderUtil.getProvider(chainNamespace);
      if (provider == null ? void 0 : provider.session) {
        this.setConnectedWalletInfo({
          ...provider.session.peer.metadata,
          name: provider.session.peer.metadata.name,
          icon: (_a2 = provider.session.peer.metadata.icons) == null ? void 0 : _a2[0]
        }, chainNamespace);
      }
    } else if (connectorId) {
      if (connectorId === ConstantsUtil.CONNECTOR_ID.COINBASE_SDK || connectorId === ConstantsUtil.CONNECTOR_ID.COINBASE) {
        const connector = this.getConnectors().find((c4) => c4.id === connectorId);
        const name = (connector == null ? void 0 : connector.name) || "Coinbase Wallet";
        const icon = (connector == null ? void 0 : connector.imageUrl) || this.getConnectorImage(connector);
        const info = connector == null ? void 0 : connector.info;
        this.setConnectedWalletInfo({
          ...info,
          name,
          icon
        }, chainNamespace);
      }
    }
  }
  async syncBalance(params) {
    const caipNetwork = NetworkUtil.getNetworksByNamespace(this.getCaipNetworks(), params.chainNamespace).find((n2) => {
      var _a2;
      return n2.id.toString() === ((_a2 = params.chainId) == null ? void 0 : _a2.toString());
    });
    if (!caipNetwork || !params.chainId) {
      return;
    }
    await this.updateNativeBalance(params.address, params.chainId, params.chainNamespace);
  }
  async ready() {
    await this.readyPromise;
  }
  async updateNativeBalance(address, chainId, namespace) {
    const adapter = this.getAdapter(namespace);
    const caipNetwork = ChainController.getCaipNetworkByNamespace(namespace, chainId);
    if (adapter) {
      const balance = await adapter.getBalance({
        address,
        chainId,
        caipNetwork,
        tokens: this.options.tokens
      });
      this.setBalance(balance.balance, balance.symbol, namespace);
      return balance;
    }
    return void 0;
  }
  // -- Universal Provider ---------------------------------------------------
  async initializeUniversalAdapter() {
    var _a2, _b, _c2, _d, _e4, _f2, _g, _h, _i3, _j;
    const logger = LoggerUtil.createLogger((error, ...args) => {
      if (error) {
        this.handleAlertError(error);
      }
      console.error(...args);
    });
    const universalProviderOptions = {
      projectId: (_a2 = this.options) == null ? void 0 : _a2.projectId,
      metadata: {
        name: ((_b = this.options) == null ? void 0 : _b.metadata) ? (_c2 = this.options) == null ? void 0 : _c2.metadata.name : "",
        description: ((_d = this.options) == null ? void 0 : _d.metadata) ? (_e4 = this.options) == null ? void 0 : _e4.metadata.description : "",
        url: ((_f2 = this.options) == null ? void 0 : _f2.metadata) ? (_g = this.options) == null ? void 0 : _g.metadata.url : "",
        icons: ((_h = this.options) == null ? void 0 : _h.metadata) ? (_i3 = this.options) == null ? void 0 : _i3.metadata.icons : [""]
      },
      logger
    };
    OptionsController.setManualWCControl(Boolean((_j = this.options) == null ? void 0 : _j.manualWCControl));
    this.universalProvider = this.options.universalProvider ?? await B2.init(universalProviderOptions);
    if (OptionsController.state.enableReconnect === false && this.universalProvider.session) {
      await this.universalProvider.disconnect();
    }
    this.listenWalletConnect();
  }
  listenWalletConnect() {
    if (this.universalProvider) {
      this.chainNamespaces.forEach((namespace) => {
        WcHelpersUtil.listenWcProvider({
          universalProvider: this.universalProvider,
          namespace,
          onDisplayUri: (uri) => {
            ConnectionController.setUri(uri);
          },
          onConnect: (accounts) => {
            const { address } = CoreHelperUtil.getAccount(accounts[0]);
            ConnectionController.finalizeWcConnection(address);
          },
          onDisconnect: () => {
            if (ChainController.state.noAdapters) {
              this.resetAccount(namespace);
            }
            ConnectionController.resetWcConnection();
          },
          onChainChanged: (chainId) => {
            const activeNamespace = ChainController.state.activeChain;
            const isCurrentConnectorWalletConnect = activeNamespace && ConnectorController.state.activeConnectorIds[activeNamespace] === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
            if (activeNamespace === namespace && (ChainController.state.noAdapters || isCurrentConnectorWalletConnect)) {
              const caipNetwork = this.getCaipNetworks().find((n2) => n2.id.toString() === chainId.toString() || n2.caipNetworkId.toString() === chainId.toString());
              const currentCaipNetwork = this.getCaipNetwork();
              if (!caipNetwork) {
                this.setUnsupportedNetwork(chainId);
                return;
              }
              if ((currentCaipNetwork == null ? void 0 : currentCaipNetwork.id.toString()) !== (caipNetwork == null ? void 0 : caipNetwork.id.toString()) && (currentCaipNetwork == null ? void 0 : currentCaipNetwork.chainNamespace) === (caipNetwork == null ? void 0 : caipNetwork.chainNamespace)) {
                this.setCaipNetwork(caipNetwork);
              }
            }
          },
          onAccountsChanged: (accounts) => {
            const activeNamespace = ChainController.state.activeChain;
            const isCurrentConnectorWalletConnect = activeNamespace && ConnectorController.state.activeConnectorIds[activeNamespace] === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
            if (activeNamespace === namespace && (ChainController.state.noAdapters || isCurrentConnectorWalletConnect)) {
              const account = accounts == null ? void 0 : accounts[0];
              if (account) {
                this.syncAccount({
                  address: account.address,
                  chainId: account.chainId,
                  chainNamespace: account.chainNamespace
                });
              }
            }
          }
        });
      });
    }
  }
  createUniversalProvider() {
    var _a2;
    if (!this.universalProviderInitPromise && CoreHelperUtil.isClient() && ((_a2 = this.options) == null ? void 0 : _a2.projectId)) {
      this.universalProviderInitPromise = this.initializeUniversalAdapter();
    }
    return this.universalProviderInitPromise;
  }
  async getUniversalProvider() {
    if (!this.universalProvider) {
      try {
        await this.createUniversalProvider();
      } catch (err) {
        EventsController.sendEvent({
          type: "error",
          event: "INTERNAL_SDK_ERROR",
          properties: {
            errorType: "UniversalProviderInitError",
            errorMessage: err instanceof Error ? err.message : "Unknown",
            uncaught: false
          }
        });
        console.error("AppKit:getUniversalProvider - Cannot create provider", err);
      }
    }
    return this.universalProvider;
  }
  // - Utils -------------------------------------------------------------------
  handleAlertError(error) {
    const matchedUniversalProviderError = Object.entries(ErrorUtil.UniversalProviderErrors).find(([, { message: message2 }]) => error.message.includes(message2));
    const [errorKey, errorValue] = matchedUniversalProviderError ?? [];
    const { message, alertErrorKey } = errorValue ?? {};
    if (errorKey && message && !this.reportedAlertErrors[errorKey]) {
      const alertError = ErrorUtil.ALERT_ERRORS[alertErrorKey];
      if (alertError) {
        AlertController.open(alertError, "error");
        this.reportedAlertErrors[errorKey] = true;
      }
    }
  }
  getAdapter(namespace) {
    var _a2;
    if (!namespace) {
      return void 0;
    }
    return (_a2 = this.chainAdapters) == null ? void 0 : _a2[namespace];
  }
  createAdapter(blueprint) {
    var _a2;
    if (!blueprint) {
      return;
    }
    const namespace = blueprint.namespace;
    if (!namespace) {
      return;
    }
    this.createClients();
    const adapterBlueprint = blueprint;
    adapterBlueprint.namespace = namespace;
    adapterBlueprint.construct({
      namespace,
      projectId: (_a2 = this.options) == null ? void 0 : _a2.projectId,
      networks: this.getCaipNetworks()
    });
    if (!this.chainNamespaces.includes(namespace)) {
      this.chainNamespaces.push(namespace);
    }
    if (this.chainAdapters) {
      this.chainAdapters[namespace] = adapterBlueprint;
    }
  }
  // -- Public -------------------------------------------------------------------
  async open(options) {
    await this.injectModalUi();
    if (options == null ? void 0 : options.uri) {
      ConnectionController.setUri(options.uri);
    }
    if (options == null ? void 0 : options.arguments) {
      switch (options == null ? void 0 : options.view) {
        case "Swap":
          return ModalController.open({ ...options, data: { swap: options.arguments } });
        default:
      }
    }
    return ModalController.open(options);
  }
  async close() {
    await this.injectModalUi();
    ModalController.close();
  }
  setLoading(loading, namespace) {
    ModalController.setLoading(loading, namespace);
  }
  async disconnect(chainNamespace) {
    await ConnectionController.disconnect({ namespace: chainNamespace });
  }
  getSIWX() {
    return OptionsController.state.siwx;
  }
  // -- review these -------------------------------------------------------------------
  getError() {
    return "";
  }
  getChainId() {
    var _a2;
    return (_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.id;
  }
  async switchNetwork(appKitNetwork) {
    const network = this.getCaipNetworks().find((n2) => n2.id === appKitNetwork.id);
    if (!network) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, "error");
      return;
    }
    await ChainController.switchActiveNetwork(network);
  }
  getWalletProvider() {
    return ChainController.state.activeChain ? ProviderUtil.state.providers[ChainController.state.activeChain] : null;
  }
  getWalletProviderType() {
    return ProviderUtil.getProviderId(ChainController.state.activeChain);
  }
  subscribeProviders(callback) {
    return ProviderUtil.subscribeProviders(callback);
  }
  getThemeMode() {
    return ThemeController.state.themeMode;
  }
  getThemeVariables() {
    return ThemeController.state.themeVariables;
  }
  setThemeMode(themeMode) {
    ThemeController.setThemeMode(themeMode);
    setColorTheme(ThemeController.state.themeMode);
  }
  setTermsConditionsUrl(termsConditionsUrl) {
    OptionsController.setTermsConditionsUrl(termsConditionsUrl);
  }
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    OptionsController.setPrivacyPolicyUrl(privacyPolicyUrl);
  }
  setThemeVariables(themeVariables) {
    ThemeController.setThemeVariables(themeVariables);
    setThemeVariables(ThemeController.state.themeVariables);
  }
  subscribeTheme(callback) {
    return ThemeController.subscribe(callback);
  }
  subscribeConnections(callback) {
    if (!this.remoteFeatures.multiWallet) {
      AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
      return () => void 0;
    }
    return ConnectionController.subscribe(callback);
  }
  getWalletInfo(namespace) {
    var _a2, _b;
    if (namespace) {
      return (_b = (_a2 = ChainController.state.chains.get(namespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.connectedWalletInfo;
    }
    return AccountController.state.connectedWalletInfo;
  }
  getAccount(_namespace) {
    const namespace = _namespace || ChainController.state.activeChain;
    const authConnector = ConnectorController.getAuthConnector(namespace);
    const accountState = ChainController.getAccountData(namespace);
    const activeConnectorId = StorageUtil.getConnectedConnectorId(ChainController.state.activeChain);
    const connections = ConnectionController.getConnections(namespace);
    if (!namespace) {
      throw new Error("AppKit:getAccount - namespace is required");
    }
    const allAccounts = connections.flatMap((connection) => connection.accounts.map(({ address, type, publicKey }) => CoreHelperUtil.createAccount(namespace, address, type || "eoa", publicKey)));
    if (!accountState) {
      return void 0;
    }
    return {
      allAccounts,
      caipAddress: accountState.caipAddress,
      address: CoreHelperUtil.getPlainAddress(accountState.caipAddress),
      isConnected: Boolean(accountState.caipAddress),
      status: accountState.status,
      embeddedWalletInfo: authConnector && activeConnectorId === ConstantsUtil.CONNECTOR_ID.AUTH ? {
        user: accountState.user ? {
          ...accountState.user,
          /*
           * Getting the username from the chain controller works well for social logins,
           * but Farcaster uses a different connection flow and doesn't emit the username via events.
           * Since the username is stored in local storage before the chain controller updates,
           * it's safe to use the local storage value here.
           */
          username: StorageUtil.getConnectedSocialUsername()
        } : void 0,
        authProvider: accountState.socialProvider || "email",
        accountType: getPreferredAccountType(namespace),
        isSmartAccountDeployed: Boolean(accountState.smartAccountDeployed)
      } : void 0
    };
  }
  subscribeAccount(callback, namespace) {
    const updateVal = () => {
      const account = this.getAccount(namespace);
      if (!account) {
        return;
      }
      callback(account);
    };
    if (namespace) {
      ChainController.subscribeChainProp("accountState", updateVal, namespace);
    } else {
      ChainController.subscribe(updateVal);
    }
    ConnectorController.subscribe(updateVal);
  }
  subscribeNetwork(callback) {
    return ChainController.subscribe(({ activeCaipNetwork }) => {
      callback({
        caipNetwork: activeCaipNetwork,
        chainId: activeCaipNetwork == null ? void 0 : activeCaipNetwork.id,
        caipNetworkId: activeCaipNetwork == null ? void 0 : activeCaipNetwork.caipNetworkId
      });
    });
  }
  subscribeWalletInfo(callback, namespace) {
    if (namespace) {
      return AccountController.subscribeKey("connectedWalletInfo", callback, namespace);
    }
    return AccountController.subscribeKey("connectedWalletInfo", callback);
  }
  subscribeShouldUpdateToAddress(callback) {
    AccountController.subscribeKey("shouldUpdateToAddress", callback);
  }
  subscribeCaipNetworkChange(callback) {
    ChainController.subscribeKey("activeCaipNetwork", callback);
  }
  getState() {
    return PublicStateController.state;
  }
  getRemoteFeatures() {
    return OptionsController.state.remoteFeatures;
  }
  subscribeState(callback) {
    return PublicStateController.subscribe(callback);
  }
  subscribeRemoteFeatures(callback) {
    return OptionsController.subscribeKey("remoteFeatures", callback);
  }
  showErrorMessage(message) {
    SnackController.showError(message);
  }
  showSuccessMessage(message) {
    SnackController.showSuccess(message);
  }
  getEvent() {
    return { ...EventsController.state };
  }
  subscribeEvents(callback) {
    return EventsController.subscribe(callback);
  }
  replace(route) {
    RouterController.replace(route);
  }
  redirect(route) {
    RouterController.push(route);
  }
  popTransactionStack(status) {
    RouterController.popTransactionStack(status);
  }
  isOpen() {
    return ModalController.state.open;
  }
  isTransactionStackEmpty() {
    return RouterController.state.transactionStack.length === 0;
  }
  static getInstance() {
    return this.instance;
  }
  updateFeatures(newFeatures) {
    OptionsController.setFeatures(newFeatures);
  }
  updateRemoteFeatures(newRemoteFeatures) {
    OptionsController.setRemoteFeatures(newRemoteFeatures);
  }
  updateOptions(newOptions) {
    const currentOptions = OptionsController.state || {};
    const updatedOptions = { ...currentOptions, ...newOptions };
    OptionsController.setOptions(updatedOptions);
  }
  setConnectMethodsOrder(connectMethodsOrder) {
    OptionsController.setConnectMethodsOrder(connectMethodsOrder);
  }
  setWalletFeaturesOrder(walletFeaturesOrder) {
    OptionsController.setWalletFeaturesOrder(walletFeaturesOrder);
  }
  setCollapseWallets(collapseWallets) {
    OptionsController.setCollapseWallets(collapseWallets);
  }
  setSocialsOrder(socialsOrder) {
    OptionsController.setSocialsOrder(socialsOrder);
  }
  getConnectMethodsOrder() {
    return WalletUtil.getConnectOrderMethod(OptionsController.state.features, ConnectorController.getConnectors());
  }
  /**
   * Adds a network to an existing adapter in AppKit.
   * @param namespace - The chain namespace to add the network to (e.g. 'eip155', 'solana')
   * @param network - The network configuration to add
   * @throws Error if adapter for namespace doesn't exist
   */
  addNetwork(namespace, network) {
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const extendedNetwork = this.extendCaipNetwork(network, this.options);
    if (!this.getCaipNetworks().find((n2) => n2.id === extendedNetwork.id)) {
      ChainController.addNetwork(extendedNetwork);
    }
  }
  /**
   * Removes a network from an existing adapter in AppKit.
   * @param namespace - The chain namespace the network belongs to
   * @param networkId - The network ID to remove
   * @throws Error if adapter for namespace doesn't exist or if removing last network
   */
  removeNetwork(namespace, networkId) {
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const networkToRemove = this.getCaipNetworks().find((n2) => n2.id === networkId);
    if (!networkToRemove) {
      return;
    }
    ChainController.removeNetwork(namespace, networkId);
  }
};

// node_modules/@reown/appkit/dist/esm/src/client/appkit.js
var isInitialized = false;
var AppKit = class extends AppKitBaseClient {
  // -- Private ------------------------------------------------------------------
  async onAuthProviderConnected(user) {
    const namespace = HelpersUtil.userChainIdToChainNamespace(user == null ? void 0 : user.chainId);
    if (user.message && user.signature && user.siwxMessage) {
      await SIWXUtil.addEmbeddedWalletSession({
        chainId: user.siwxMessage.chainId,
        accountAddress: user.address,
        notBefore: user.siwxMessage.notBefore,
        statement: user.siwxMessage.statement,
        resources: user.siwxMessage.resources,
        requestId: user.siwxMessage.requestId,
        issuedAt: user.siwxMessage.issuedAt,
        domain: user.siwxMessage.domain,
        uri: user.siwxMessage.uri,
        version: user.siwxMessage.version,
        nonce: user.siwxMessage.nonce
      }, user.message, user.signature);
    }
    if (!namespace) {
      throw new Error("AppKit:onAuthProviderConnected - namespace is required");
    }
    const caipAddress = namespace === ConstantsUtil.CHAIN.EVM ? `eip155:${user.chainId}:${user.address}` : `${user.chainId}:${user.address}`;
    const defaultAccountType = OptionsController.state.defaultAccountTypes[namespace];
    const currentAccountType = getPreferredAccountType(namespace);
    const preferredAccountType = user.preferredAccountType || currentAccountType || defaultAccountType;
    this.setCaipAddress(caipAddress, namespace);
    const { signature, siwxMessage, message, ...userWithOutSiwxData } = user;
    this.setUser({ ...AccountController.state.user || {}, ...userWithOutSiwxData }, namespace);
    this.setSmartAccountDeployed(Boolean(user.smartAccountDeployed), namespace);
    this.setPreferredAccountType(preferredAccountType, namespace);
    this.setLoading(false, namespace);
  }
  setupAuthConnectorListeners(provider) {
    provider.onRpcRequest((request) => {
      if (W3mFrameHelpers.checkIfRequestExists(request)) {
        if (!W3mFrameHelpers.checkIfRequestIsSafe(request)) {
          this.handleUnsafeRPCRequest();
        }
      } else {
        this.open();
        console.error(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_MESSAGE, {
          method: request.method
        });
        setTimeout(() => {
          this.showErrorMessage(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
        }, 300);
        provider.rejectRpcRequests();
      }
    });
    provider.onRpcError(() => {
      const isModalOpen = this.isOpen();
      if (isModalOpen) {
        if (this.isTransactionStackEmpty()) {
          this.close();
        } else {
          this.popTransactionStack("error");
        }
      }
    });
    provider.onRpcSuccess((_2, request) => {
      const isSafeRequest = W3mFrameHelpers.checkIfRequestIsSafe(request);
      const address = AccountController.state.address;
      const caipNetwork = ChainController.state.activeCaipNetwork;
      if (isSafeRequest) {
        return;
      }
      if (address && (caipNetwork == null ? void 0 : caipNetwork.id)) {
        this.updateNativeBalance(address, caipNetwork.id, caipNetwork.chainNamespace);
      }
      if (this.isTransactionStackEmpty()) {
        this.close();
      } else {
        this.popTransactionStack("success");
      }
    });
    provider.onNotConnected(() => {
      const namespace = ChainController.state.activeChain;
      if (!namespace) {
        throw new Error("AppKit:onNotConnected - namespace is required");
      }
      const connectorId = ConnectorController.getConnectorId(namespace);
      const isConnectedWithAuth = connectorId === ConstantsUtil.CONNECTOR_ID.AUTH;
      if (isConnectedWithAuth) {
        this.setCaipAddress(void 0, namespace);
        this.setLoading(false, namespace);
      }
    });
    provider.onConnect(this.onAuthProviderConnected.bind(this));
    provider.onSocialConnected(this.onAuthProviderConnected.bind(this));
    provider.onSetPreferredAccount(({ address, type }) => {
      const namespace = ChainController.state.activeChain;
      if (!namespace) {
        throw new Error("AppKit:onSetPreferredAccount - namespace is required");
      }
      if (!address) {
        return;
      }
      this.setPreferredAccountType(type, namespace);
    });
  }
  async syncAuthConnectorTheme(provider) {
    if (!provider) {
      return;
    }
    const theme = ThemeController.getSnapshot();
    const options = OptionsController.getSnapshot();
    await Promise.all([
      provider.syncDappData({
        metadata: options.metadata,
        sdkVersion: options.sdkVersion,
        projectId: options.projectId,
        sdkType: options.sdkType
      }),
      provider.syncTheme({
        themeMode: theme.themeMode,
        themeVariables: theme.themeVariables,
        w3mThemeVariables: getW3mThemeVariables(theme.themeVariables, theme.themeMode)
      })
    ]);
  }
  async syncAuthConnector(provider, chainNamespace) {
    var _a2, _b, _c2, _d, _e4, _f2, _g, _h, _i3;
    const isAuthSupported = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(chainNamespace);
    const shouldSync = chainNamespace === ChainController.state.activeChain;
    if (!isAuthSupported) {
      return;
    }
    this.setLoading(true, chainNamespace);
    const isLoginEmailUsed = provider.getLoginEmailUsed();
    this.setLoading(isLoginEmailUsed, chainNamespace);
    if (isLoginEmailUsed) {
      this.setStatus("connecting", chainNamespace);
    }
    const email = provider.getEmail();
    const username = provider.getUsername();
    this.setUser({ ...((_a2 = AccountController.state) == null ? void 0 : _a2.user) || {}, username, email }, chainNamespace);
    this.setupAuthConnectorListeners(provider);
    const { isConnected } = await provider.isConnected();
    await this.syncAuthConnectorTheme(provider);
    if (chainNamespace && isAuthSupported && shouldSync) {
      const enabledNetworks = await provider.getSmartAccountEnabledNetworks();
      ChainController.setSmartAccountEnabledNetworks((enabledNetworks == null ? void 0 : enabledNetworks.smartAccountEnabledNetworks) || [], chainNamespace);
      if (isConnected && ((_b = this.connectionControllerClient) == null ? void 0 : _b.connectExternal)) {
        await ((_e4 = this.connectionControllerClient) == null ? void 0 : _e4.connectExternal({
          id: ConstantsUtil.CONNECTOR_ID.AUTH,
          info: { name: ConstantsUtil.CONNECTOR_ID.AUTH },
          type: ConstantsUtil3.CONNECTOR_TYPE_AUTH,
          provider,
          chainId: (_d = (_c2 = ChainController.getNetworkData(chainNamespace)) == null ? void 0 : _c2.caipNetwork) == null ? void 0 : _d.id,
          chain: chainNamespace
        }));
        this.setStatus("connected", chainNamespace);
        const socialProvider = StorageUtil.getConnectedSocialProvider();
        if (socialProvider) {
          EventsController.sendEvent({
            type: "track",
            event: "SOCIAL_LOGIN_SUCCESS",
            address: AccountController.state.address,
            properties: {
              provider: socialProvider,
              reconnect: true
            }
          });
        } else {
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            address: AccountController.state.address,
            properties: {
              method: "email",
              name: ((_i3 = (_h = (_g = (_f2 = this.universalProvider) == null ? void 0 : _f2.session) == null ? void 0 : _g.peer) == null ? void 0 : _h.metadata) == null ? void 0 : _i3.name) || "Unknown",
              reconnect: true
            }
          });
        }
      } else if (ConnectorController.getConnectorId(chainNamespace) === ConstantsUtil.CONNECTOR_ID.AUTH) {
        this.setStatus("disconnected", chainNamespace);
        StorageUtil.removeConnectedNamespace(chainNamespace);
      }
    }
    this.setLoading(false, chainNamespace);
  }
  async checkExistingTelegramSocialConnection(chainNamespace) {
    var _a2;
    try {
      if (!CoreHelperUtil.isTelegram()) {
        return;
      }
      const socialProviderToConnect = StorageUtil.getTelegramSocialProvider();
      if (!socialProviderToConnect) {
        return;
      }
      if (!CoreHelperUtil.isClient()) {
        return;
      }
      const url = new URL(window.location.href);
      const resultUri = url.searchParams.get("result_uri");
      if (!resultUri) {
        return;
      }
      AccountController.setSocialProvider(socialProviderToConnect, chainNamespace);
      await ((_a2 = this.authProvider) == null ? void 0 : _a2.init());
      const authConnector = ConnectorController.getAuthConnector();
      if (socialProviderToConnect && authConnector) {
        this.setLoading(true, chainNamespace);
        await ConnectionController.connectExternal({
          id: authConnector.id,
          type: authConnector.type,
          socialUri: resultUri
        }, authConnector.chain);
        StorageUtil.setConnectedSocialProvider(socialProviderToConnect);
        StorageUtil.removeTelegramSocialProvider();
        EventsController.sendEvent({
          type: "track",
          event: "SOCIAL_LOGIN_SUCCESS",
          properties: { provider: socialProviderToConnect }
        });
      }
    } catch (error) {
      this.setLoading(false, chainNamespace);
      console.error("checkExistingSTelegramocialConnection error", error);
    }
    try {
      const url = new URL(window.location.href);
      url.searchParams.delete("result_uri");
      window.history.replaceState({}, document.title, url.toString());
    } catch (error) {
      console.error("tma social login failed", error);
    }
  }
  createAuthProvider(chainNamespace) {
    var _a2, _b, _c2, _d;
    const isSupported = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(chainNamespace);
    if (!isSupported) {
      return;
    }
    const isEmailEnabled = (_a2 = this.remoteFeatures) == null ? void 0 : _a2.email;
    const isSocialsEnabled = Array.isArray((_b = this.remoteFeatures) == null ? void 0 : _b.socials) && this.remoteFeatures.socials.length > 0;
    const isAuthEnabled = isEmailEnabled || isSocialsEnabled;
    const activeNamespaceConnectedToAuth = HelpersUtil.getActiveNamespaceConnectedToAuth();
    const namespaceToConnect = activeNamespaceConnectedToAuth || chainNamespace;
    if (!this.authProvider && ((_c2 = this.options) == null ? void 0 : _c2.projectId) && isAuthEnabled) {
      this.authProvider = W3mFrameProviderSingleton.getInstance({
        projectId: this.options.projectId,
        enableLogger: this.options.enableAuthLogger,
        chainId: (_d = this.getCaipNetwork(namespaceToConnect)) == null ? void 0 : _d.caipNetworkId,
        abortController: ErrorUtil.EmbeddedWalletAbortController,
        onTimeout: (reason) => {
          if (reason === "iframe_load_failed") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error");
          } else if (reason === "iframe_request_timeout") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error");
          } else if (reason === "unverified_domain") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
          }
        },
        getActiveCaipNetwork: (namespace) => getActiveCaipNetwork(namespace),
        getCaipNetworks: (namespace) => ChainController.getCaipNetworks(namespace)
      });
      PublicStateController.subscribeOpen((isOpen) => {
        var _a3;
        if (!isOpen && this.isTransactionStackEmpty()) {
          (_a3 = this.authProvider) == null ? void 0 : _a3.rejectRpcRequests();
        }
      });
    }
    const shouldSyncAccount = chainNamespace === ChainController.state.activeChain && OptionsController.state.enableReconnect;
    if (OptionsController.state.enableReconnect === false) {
      this.syncAuthConnectorTheme(this.authProvider);
    } else if (this.authProvider && shouldSyncAccount) {
      this.syncAuthConnector(this.authProvider, chainNamespace);
      this.checkExistingTelegramSocialConnection(chainNamespace);
    }
  }
  createAuthProviderForAdapter(chainNamespace) {
    var _a2, _b, _c2;
    this.createAuthProvider(chainNamespace);
    if (this.authProvider) {
      (_c2 = (_b = (_a2 = this.chainAdapters) == null ? void 0 : _a2[chainNamespace]) == null ? void 0 : _b.setAuthProvider) == null ? void 0 : _c2.call(_b, this.authProvider);
    }
  }
  // -- Overrides ----------------------------------------------------------------
  initControllers(options) {
    super.initControllers(options);
    if (this.options.excludeWalletIds) {
      ApiController.initializeExcludedWallets({ ids: this.options.excludeWalletIds });
    }
  }
  async switchCaipNetwork(caipNetwork) {
    var _a2, _b;
    if (!caipNetwork) {
      return;
    }
    const currentNamespace = ChainController.state.activeChain;
    const networkNamespace = caipNetwork.chainNamespace;
    const namespaceAddress = this.getAddressByChainNamespace(networkNamespace);
    const isSameNamespace = networkNamespace === currentNamespace;
    if (isSameNamespace && namespaceAddress) {
      const adapter = this.getAdapter(networkNamespace);
      const provider = ProviderUtil.getProvider(networkNamespace);
      const providerType = ProviderUtil.getProviderId(networkNamespace);
      await (adapter == null ? void 0 : adapter.switchNetwork({ caipNetwork, provider, providerType }));
      this.setCaipNetwork(caipNetwork);
    } else {
      const currentNamespaceProviderType = ProviderUtil.getProviderId(currentNamespace);
      const isCurrentNamespaceAuthProvider = currentNamespaceProviderType === ConstantsUtil3.CONNECTOR_TYPE_AUTH;
      const newNamespaceProviderType = ProviderUtil.getProviderId(networkNamespace);
      const isNewNamespaceAuthProvider = newNamespaceProviderType === ConstantsUtil3.CONNECTOR_TYPE_AUTH;
      const isNewNamespaceSupportsAuthConnector = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(networkNamespace);
      if (!networkNamespace) {
        throw new Error("AppKit:switchCaipNetwork - networkNamespace is required");
      }
      if ((isCurrentNamespaceAuthProvider && newNamespaceProviderType === void 0 || isNewNamespaceAuthProvider) && isNewNamespaceSupportsAuthConnector) {
        try {
          ChainController.state.activeChain = caipNetwork.chainNamespace;
          if (namespaceAddress) {
            const adapter = this.getAdapter(networkNamespace);
            await (adapter == null ? void 0 : adapter.switchNetwork({
              caipNetwork,
              provider: this.authProvider,
              providerType: newNamespaceProviderType
            }));
          } else {
            await ((_b = (_a2 = this.connectionControllerClient) == null ? void 0 : _a2.connectExternal) == null ? void 0 : _b.call(_a2, {
              id: ConstantsUtil.CONNECTOR_ID.AUTH,
              provider: this.authProvider,
              chain: networkNamespace,
              chainId: caipNetwork.id,
              type: ConstantsUtil3.CONNECTOR_TYPE_AUTH,
              caipNetwork
            }));
          }
          this.setCaipNetwork(caipNetwork);
        } catch (error) {
          const adapter = this.getAdapter(networkNamespace);
          await (adapter == null ? void 0 : adapter.switchNetwork({
            caipNetwork,
            provider: this.authProvider,
            providerType: newNamespaceProviderType
          }));
        }
      } else if (newNamespaceProviderType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
        if (!ChainController.state.noAdapters) {
          const adapter = this.getAdapter(networkNamespace);
          const provider = ProviderUtil.getProvider(networkNamespace);
          const providerType = ProviderUtil.getProviderId(networkNamespace);
          await (adapter == null ? void 0 : adapter.switchNetwork({ caipNetwork, provider, providerType }));
        }
        this.setCaipNetwork(caipNetwork);
        this.syncWalletConnectAccount();
      } else {
        this.setCaipNetwork(caipNetwork);
        if (namespaceAddress) {
          this.syncAccount({
            address: namespaceAddress,
            chainId: caipNetwork.id,
            chainNamespace: networkNamespace
          });
        }
      }
    }
  }
  async initialize(options) {
    var _a2;
    await super.initialize(options);
    (_a2 = this.chainNamespaces) == null ? void 0 : _a2.forEach((namespace) => {
      this.createAuthProviderForAdapter(namespace);
    });
    await this.injectModalUi();
    PublicStateController.set({ initialized: true });
  }
  async syncIdentity({ address, chainId, chainNamespace }) {
    var _a2;
    const caipNetworkId = `${chainNamespace}:${chainId}`;
    const activeCaipNetwork = (_a2 = this.caipNetworks) == null ? void 0 : _a2.find((n2) => n2.caipNetworkId === caipNetworkId);
    if (activeCaipNetwork == null ? void 0 : activeCaipNetwork.testnet) {
      this.setProfileName(null, chainNamespace);
      this.setProfileImage(null, chainNamespace);
      return;
    }
    const isAuthConnector = ConnectorController.getConnectorId(chainNamespace) === ConstantsUtil.CONNECTOR_ID.AUTH;
    try {
      const { name, avatar } = await this.fetchIdentity({
        address
      });
      if (!name && isAuthConnector) {
        await this.syncReownName(address, chainNamespace);
      } else {
        this.setProfileName(name, chainNamespace);
        this.setProfileImage(avatar, chainNamespace);
      }
    } catch {
      if (chainId !== 1) {
        this.setProfileImage(null, chainNamespace);
      }
    }
  }
  syncConnectedWalletInfo(chainNamespace) {
    const providerType = ProviderUtil.getProviderId(chainNamespace);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_AUTH) {
      const provider = this.authProvider;
      if (provider) {
        const social = StorageUtil.getConnectedSocialProvider() ?? "email";
        const identifier = provider.getEmail() ?? provider.getUsername();
        this.setConnectedWalletInfo({ name: providerType, identifier, social }, chainNamespace);
      }
    } else {
      super.syncConnectedWalletInfo(chainNamespace);
    }
  }
  async injectModalUi() {
    if (!CoreHelperUtil.isClient()) {
      return;
    }
    if (!isInitialized) {
      try {
        const features = { ...ConstantsUtil2.DEFAULT_FEATURES, ...this.options.features };
        const remoteFeatures = this.remoteFeatures;
        await this.loadModalComponents(features, remoteFeatures);
        if (CoreHelperUtil.isClient()) {
          const isElementCreated = document.querySelector("w3m-modal");
          if (!isElementCreated) {
            const modal = document.createElement("w3m-modal");
            if (!OptionsController.state.disableAppend && !OptionsController.state.enableEmbedded) {
              document.body.insertAdjacentElement("beforeend", modal);
            }
          }
        }
        isInitialized = true;
      } catch (error) {
        console.error("Error injecting modal UI:", error);
      }
    }
  }
  // This separate method helps with tree-shaking for SSR builds
  async loadModalComponents(features, remoteFeatures) {
    if (!CoreHelperUtil.isClient()) {
      return;
    }
    const featureImportPromises = [];
    const usingEmbeddedWallet = remoteFeatures.email || remoteFeatures.socials && remoteFeatures.socials.length > 0;
    if (usingEmbeddedWallet) {
      featureImportPromises.push(import("./embedded-wallet-O5A4QCCE.js"));
    }
    if (remoteFeatures.email) {
      featureImportPromises.push(import("./email-VRRKZIUV.js"));
    }
    if (remoteFeatures.socials) {
      featureImportPromises.push(import("./socials-E4V5X2FH.js"));
    }
    if (remoteFeatures.swaps && remoteFeatures.swaps.length > 0) {
      featureImportPromises.push(import("./swaps-FFD3ZJO2.js"));
    }
    if (features.send) {
      featureImportPromises.push(import("./send-TXU5O6YX.js"));
    }
    if (features.receive) {
      featureImportPromises.push(import("./receive-75236DXD.js"));
    }
    if (remoteFeatures.onramp && remoteFeatures.onramp.length > 0) {
      featureImportPromises.push(import("./onramp-XD3GG662.js"));
    }
    if (remoteFeatures.payWithExchange) {
      featureImportPromises.push(import("./pay-with-exchange-ZWBDRKW2.js"));
    }
    if (remoteFeatures.activity) {
      featureImportPromises.push(import("./transactions-5O6DPYFT.js"));
    }
    if (features.pay || remoteFeatures.payments) {
      featureImportPromises.push(import("./exports-SBCNBWBC.js"));
    }
    if (remoteFeatures.emailCapture) {
      featureImportPromises.push(import("./data-capture-IPFU6PWU.js"));
    }
    await Promise.all([
      ...featureImportPromises,
      import("./exports-TNQOD5FW.js"),
      import("./w3m-modal-M32EBIJO.js")
    ]);
  }
};

// node_modules/@reown/appkit/dist/esm/exports/constants.js
var PACKAGE_VERSION = "1.8.0";

export {
  W3mFrameProviderSingleton,
  DEFAULT_METHODS,
  WcHelpersUtil,
  WcConstantsUtil,
  WalletConnectConnector,
  AdapterBlueprint,
  AppKit,
  PACKAGE_VERSION
};
/*! Bundled license information:

@walletconnect/utils/dist/index.es.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-FX2N4IPL.js.map
