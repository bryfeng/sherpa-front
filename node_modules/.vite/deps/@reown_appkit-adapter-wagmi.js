import {
  Chi,
  HashMD,
  Maj
} from "./chunk-TKX3GFLX.js";
import {
  BaseError,
  LruMap,
  concat,
  defineFormatter,
  from,
  fromBoolean,
  fromBytes,
  fromNumber,
  fromString,
  fromString2,
  hexToNumber,
  keccak_256,
  numberToHex as numberToHex2,
  padLeft,
  padRight,
  size
} from "./chunk-FO2KXKO3.js";
import {
  clean,
  createHasher,
  rotl
} from "./chunk-JUOP4WM3.js";
import {
  AdapterBlueprint,
  W3mFrameProviderSingleton,
  WalletConnectConnector,
  WcHelpersUtil
} from "./chunk-PEJFJE2Y.js";
import "./chunk-LCBGVGXT.js";
import "./chunk-EYV6QI4V.js";
import {
  CaipNetworksUtil,
  ErrorUtil,
  HelpersUtil,
  PresetsUtil
} from "./chunk-OQZ3J6JC.js";
import "./chunk-LA7WAKNU.js";
import "./chunk-ZVHMXIVC.js";
import {
  SIWXUtil,
  require_blakejs
} from "./chunk-E3ORAOFH.js";
import {
  bases,
  esm_exports,
  require_cjs,
  require_cjs2,
  require_cjs3
} from "./chunk-3XXDLP5Z.js";
import "./chunk-EGEXBN4Y.js";
import "./chunk-AL7AZVTW.js";
import "./chunk-ANJCMEYS.js";
import {
  require_events
} from "./chunk-SPJEADIR.js";
import "./chunk-BGQWUGYM.js";
import "./chunk-RCC4727E.js";
import "./chunk-QYMIQ3LI.js";
import "./chunk-JSOOL3TP.js";
import "./chunk-ERP5CZPH.js";
import "./chunk-TM73R3C3.js";
import {
  AlertController,
  ChainController,
  ConnectorController,
  ConstantsUtil,
  CoreHelperUtil,
  NetworkUtil,
  OptionsController,
  StorageUtil,
  getActiveCaipNetwork,
  getPreferredAccountType,
  subscribeKey
} from "./chunk-A54KVSXE.js";
import {
  proxy
} from "./chunk-YKYVH74R.js";
import {
  ChainNotConfiguredError,
  ProviderNotFoundError,
  connect,
  createConfig,
  createConnector,
  disconnect,
  estimateGas,
  getAccount,
  getBalance,
  getConnections,
  injected,
  prepareTransactionRequest,
  reconnect,
  sendTransaction,
  signMessage,
  switchChain,
  waitForTransactionReceipt,
  watchAccount,
  watchConnections,
  watchConnectors,
  watchPendingTransactions,
  writeContract
} from "./chunk-BTBLAL3X.js";
import "./chunk-M2Y7NS7B.js";
import {
  parseUnits
} from "./chunk-6TWVM2XI.js";
import "./chunk-4CJI45RL.js";
import "./chunk-E3BPVJ2E.js";
import "./chunk-LYYAVDTP.js";
import {
  SwitchChainError,
  UserRejectedRequestError,
  checksumAddress,
  formatUnits,
  getAddress,
  numberToHex
} from "./chunk-VE6NYZAM.js";
import "./chunk-TQDCCFKX.js";
import "./chunk-F3M2F5R6.js";
import "./chunk-KASMAJTU.js";
import "./chunk-5UBV5ZHI.js";
import {
  __toESM
} from "./chunk-64NT3AJW.js";

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/connectors/AuthConnector.js
function authConnector(parameters) {
  let currentAccounts = [];
  let socialProvider = void 0;
  let connectSocialPromise = void 0;
  function parseChainId(chainId) {
    return NetworkUtil.parseEvmChainId(chainId) || 1;
  }
  function getProviderInstance() {
    var _a2;
    if (!socialProvider) {
      socialProvider = W3mFrameProviderSingleton.getInstance({
        projectId: parameters.options.projectId,
        chainId: (_a2 = getActiveCaipNetwork()) == null ? void 0 : _a2.caipNetworkId,
        enableLogger: parameters.options.enableAuthLogger,
        onTimeout: (reason) => {
          if (reason === "iframe_load_failed") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error");
          } else if (reason === "iframe_request_timeout") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error");
          } else if (reason === "unverified_domain") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
          }
        },
        abortController: ErrorUtil.EmbeddedWalletAbortController,
        getActiveCaipNetwork: (namespace) => getActiveCaipNetwork(namespace),
        getCaipNetworks: (namespace) => ChainController.getCaipNetworks(namespace)
      });
    }
    return socialProvider;
  }
  async function connectSocial(options = {}) {
    var _a2;
    const provider = getProviderInstance();
    let chainId = options.chainId;
    if (options.isReconnecting) {
      const lastUsedChainId = NetworkUtil.parseEvmChainId(provider.getLastUsedChainId() || "");
      const defaultChainId = (_a2 = parameters.chains) == null ? void 0 : _a2[0].id;
      chainId = lastUsedChainId || defaultChainId;
      if (!chainId) {
        throw new Error("ChainId not found in provider");
      }
    }
    const preferredAccountType = getPreferredAccountType("eip155");
    const { address, chainId: frameChainId, accounts } = await SIWXUtil.authConnectorAuthenticate({
      authConnector: provider,
      chainId,
      preferredAccountType,
      socialUri: options.socialUri,
      chainNamespace: ConstantsUtil.CHAIN.EVM
    });
    currentAccounts = (accounts == null ? void 0 : accounts.map((a) => a.address)) || [address];
    const parsedChainId = parseChainId(frameChainId);
    return {
      accounts: currentAccounts,
      account: address,
      chainId: parsedChainId,
      chain: {
        id: parsedChainId,
        unsuported: false
      }
    };
  }
  return createConnector((config) => ({
    id: ConstantsUtil.CONNECTOR_ID.AUTH,
    name: ConstantsUtil.CONNECTOR_NAMES.AUTH,
    type: "AUTH",
    chain: ConstantsUtil.CHAIN.EVM,
    async connect(options = {}) {
      if (connectSocialPromise) {
        return connectSocialPromise;
      }
      if (!connectSocialPromise) {
        connectSocialPromise = new Promise((resolve) => {
          resolve(connectSocial(options));
        });
      }
      const result = await connectSocialPromise;
      connectSocialPromise = void 0;
      return result;
    },
    async disconnect() {
      const provider = await this.getProvider();
      await provider.disconnect();
    },
    getAccounts() {
      if (!(currentAccounts == null ? void 0 : currentAccounts.length)) {
        return Promise.resolve([]);
      }
      config.emitter.emit("change", { accounts: currentAccounts });
      return Promise.resolve(currentAccounts);
    },
    async getProvider() {
      var _a2;
      if (!this.provider) {
        this.provider = W3mFrameProviderSingleton.getInstance({
          projectId: parameters.options.projectId,
          chainId: (_a2 = getActiveCaipNetwork()) == null ? void 0 : _a2.caipNetworkId,
          enableLogger: parameters.options.enableAuthLogger,
          abortController: ErrorUtil.EmbeddedWalletAbortController,
          onTimeout: (reason) => {
            if (reason === "iframe_load_failed") {
              AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error");
            } else if (reason === "iframe_request_timeout") {
              AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error");
            } else if (reason === "unverified_domain") {
              AlertController.open(ErrorUtil.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
            }
          },
          getActiveCaipNetwork: (namespace) => getActiveCaipNetwork(namespace),
          getCaipNetworks: (namespace) => ChainController.getCaipNetworks(namespace)
        });
      }
      return Promise.resolve(this.provider);
    },
    async getChainId() {
      const provider = await this.getProvider();
      const { chainId } = await provider.getChainId();
      return parseChainId(chainId);
    },
    async isAuthorized() {
      const activeChain = ChainController.state.activeChain;
      const isActiveChainEvm = activeChain === ConstantsUtil.CHAIN.EVM;
      const isAnyAuthConnected = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.some((chain) => ConnectorController.getConnectorId(chain) === ConstantsUtil.CONNECTOR_ID.AUTH);
      if (isAnyAuthConnected && !isActiveChainEvm) {
        return false;
      }
      const provider = await this.getProvider();
      return Promise.resolve(provider.getLoginEmailUsed());
    },
    async switchChain({ chainId }) {
      var _a2;
      try {
        const chain = config.chains.find((c2) => c2.id === chainId);
        if (!chain) {
          throw new SwitchChainError(new Error("chain not found on connector."));
        }
        const provider = await this.getProvider();
        const preferredAccountType = getPreferredAccountType("eip155");
        const response = await provider.connect({
          chainId,
          preferredAccountType
        });
        currentAccounts = ((_a2 = response == null ? void 0 : response.accounts) == null ? void 0 : _a2.map((a) => a.address)) || [
          response.address
        ];
        config.emitter.emit("change", {
          chainId: Number(chainId),
          accounts: currentAccounts
        });
        return chain;
      } catch (error) {
        if (error instanceof Error) {
          throw new SwitchChainError(error);
        }
        throw error;
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        this.onDisconnect();
      } else {
        config.emitter.emit("change", { accounts: accounts.map(getAddress) });
      }
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      const provider = await this.getProvider();
      await provider.disconnect();
    }
  }));
}

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/core/dist/index.es.js
var import_events3 = __toESM(require_events());

// node_modules/@reown/appkit-adapter-wagmi/node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var l = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i2;
  function t() {
  }
  i2 = t, i2.prototype.getItem = function(e) {
    return this.hasOwnProperty(e) ? String(this[e]) : null;
  }, i2.prototype.setItem = function(e, n2) {
    this[e] = String(n2);
  }, i2.prototype.removeItem = function(e) {
    delete this[e];
  }, i2.prototype.clear = function() {
    const e = this;
    Object.keys(e).forEach(function(n2) {
      e[n2] = void 0, delete e[n2];
    });
  }, i2.prototype.key = function(e) {
    return e = e || 0, Object.keys(this)[e];
  }, i2.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l < "u" && l.localStorage ? c.exports = l.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
})();

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/types/dist/index.es.js
var import_events2 = __toESM(require_events());

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/utils/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [
      address,
      typeof blockNumber === "bigint" ? numberToHex2(blockNumber) : blockTag
    ]
  }, {
    dedupe: Boolean(blockNumber)
  });
  return hexToNumber(count);
}

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/utils/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendCalls.js
var fallbackTransactionErrorMagicIdentifier = numberToHex2(0, {
  size: 32
});

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache = new LruMap(8192);

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@noble/hashes/esm/legacy.js
var SHA1_IV = Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = new Uint32Array(80);
var SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    this.A = SHA1_IV[0] | 0;
    this.B = SHA1_IV[1] | 0;
    this.C = SHA1_IV[2] | 0;
    this.D = SHA1_IV[3] | 0;
    this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: A3, B, C: C3, D: D2, E: E2 } = this;
    return [A3, B, C3, D2, E2];
  }
  set(A3, B, C3, D2, E2) {
    this.A = A3 | 0;
    this.B = B | 0;
    this.C = C3 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA1_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 80; i2++)
      SHA1_W[i2] = rotl(SHA1_W[i2 - 3] ^ SHA1_W[i2 - 8] ^ SHA1_W[i2 - 14] ^ SHA1_W[i2 - 16], 1);
    let { A: A3, B, C: C3, D: D2, E: E2 } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      let F3, K2;
      if (i2 < 20) {
        F3 = Chi(B, C3, D2);
        K2 = 1518500249;
      } else if (i2 < 40) {
        F3 = B ^ C3 ^ D2;
        K2 = 1859775393;
      } else if (i2 < 60) {
        F3 = Maj(B, C3, D2);
        K2 = 2400959708;
      } else {
        F3 = B ^ C3 ^ D2;
        K2 = 3395469782;
      }
      const T = rotl(A3, 5) + F3 + E2 + K2 + SHA1_W[i2] | 0;
      E2 = D2;
      D2 = C3;
      C3 = rotl(B, 30);
      B = A3;
      A3 = T;
    }
    A3 = A3 + this.A | 0;
    B = B + this.B | 0;
    C3 = C3 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    this.set(A3, B, C3, D2, E2);
  }
  roundClean() {
    clean(SHA1_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var sha1 = createHasher(() => new SHA1());
var p32 = Math.pow(2, 32);
var K = Array.from({ length: 64 }, (_, i2) => Math.floor(p32 * Math.abs(Math.sin(i2 + 1))));
var MD5_IV = SHA1_IV.slice(0, 4);
var MD5_W = new Uint32Array(16);
var MD5 = class extends HashMD {
  constructor() {
    super(64, 16, 8, true);
    this.A = MD5_IV[0] | 0;
    this.B = MD5_IV[1] | 0;
    this.C = MD5_IV[2] | 0;
    this.D = MD5_IV[3] | 0;
  }
  get() {
    const { A: A3, B, C: C3, D: D2 } = this;
    return [A3, B, C3, D2];
  }
  set(A3, B, C3, D2) {
    this.A = A3 | 0;
    this.B = B | 0;
    this.C = C3 | 0;
    this.D = D2 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      MD5_W[i2] = view.getUint32(offset, true);
    let { A: A3, B, C: C3, D: D2 } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      let F3, g, s;
      if (i2 < 16) {
        F3 = Chi(B, C3, D2);
        g = i2;
        s = [7, 12, 17, 22];
      } else if (i2 < 32) {
        F3 = Chi(D2, B, C3);
        g = (5 * i2 + 1) % 16;
        s = [5, 9, 14, 20];
      } else if (i2 < 48) {
        F3 = B ^ C3 ^ D2;
        g = (3 * i2 + 5) % 16;
        s = [4, 11, 16, 23];
      } else {
        F3 = C3 ^ (B | ~D2);
        g = 7 * i2 % 16;
        s = [6, 10, 15, 21];
      }
      F3 = F3 + A3 + K[i2] + MD5_W[g];
      A3 = D2;
      D2 = C3;
      C3 = B;
      B = B + rotl(F3, s[i2 % 4]);
    }
    A3 = A3 + this.A | 0;
    B = B + this.B | 0;
    C3 = C3 + this.C | 0;
    D2 = D2 + this.D | 0;
    this.set(A3, B, C3, D2);
  }
  roundClean() {
    clean(MD5_W);
  }
  destroy() {
    this.set(0, 0, 0, 0);
    clean(this.buffer);
  }
};
var md5 = createHasher(() => new MD5());
var Rho160 = Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_, i2) => i2)))();
var Pi160 = (() => Id160.map((i2) => (9 * i2 + 5) % 16))();
var idxLR = (() => {
  const L = [Id160];
  const R2 = [Pi160];
  const res = [L, R2];
  for (let i2 = 0; i2 < 4; i2++)
    for (let j of res)
      j.push(j[i2].map((k2) => Rho160[k2]));
  return res;
})();
var idxL = (() => idxLR[0])();
var idxR = (() => idxLR[1])();
var shifts160 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i2) => Uint8Array.from(i2));
var shiftsL160 = idxL.map((idx, i2) => idx.map((j) => shifts160[i2][j]));
var shiftsR160 = idxR.map((idx, i2) => idx.map((j) => shifts160[i2][j]));
var Kl160 = Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x, y3, z) {
  if (group === 0)
    return x ^ y3 ^ z;
  if (group === 1)
    return x & y3 | ~x & z;
  if (group === 2)
    return (x | ~y3) ^ z;
  if (group === 3)
    return x & z | y3 & ~z;
  return x ^ (y3 | ~z);
}
var BUF_160 = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3, h4 } = this;
    return [h0, h1, h22, h3, h4];
  }
  set(h0, h1, h22, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      BUF_160[i2] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar2 = al, bl = this.h1 | 0, br2 = bl, cl = this.h2 | 0, cr3 = cl, dl = this.h3 | 0, dr2 = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr2 = idxR[group];
      const sl = shiftsL160[group], sr2 = shiftsR160[group];
      for (let i2 = 0; i2 < 16; i2++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i2]] + hbl, sl[i2]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i2 = 0; i2 < 16; i2++) {
        const tr = rotl(ar2 + ripemd_f(rGroup, br2, cr3, dr2) + BUF_160[rr2[i2]] + hbr, sr2[i2]) + er | 0;
        ar2 = er, er = dr2, dr2 = rotl(cr3, 10) | 0, cr3 = br2, br2 = tr;
      }
    }
    this.set(this.h1 + cl + dr2 | 0, this.h2 + dl + er | 0, this.h3 + el + ar2 | 0, this.h4 + al + br2 | 0, this.h0 + bl + cr3 | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = createHasher(() => new RIPEMD160());

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager = createNonceManager({
  source: jsonRpc()
});

// node_modules/@reown/appkit-adapter-wagmi/node_modules/ox/_esm/core/Hash.js
function keccak2562(value, options = {}) {
  const { as = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const bytes = keccak_256(from(value));
  if (as === "Bytes")
    return bytes;
  return fromBytes(bytes);
}

// node_modules/@reown/appkit-adapter-wagmi/node_modules/ox/_esm/core/internal/lru.js
var LruMap2 = class extends Map {
  constructor(size4) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size4;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== void 0) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/@reown/appkit-adapter-wagmi/node_modules/ox/_esm/core/Caches.js
var caches = {
  checksum: new LruMap2(8192)
};
var checksum = caches.checksum;

// node_modules/@reown/appkit-adapter-wagmi/node_modules/ox/_esm/core/Address.js
var addressRegex = /^0x[a-fA-F0-9]{40}$/;
function assert(value, options = {}) {
  const { strict = true } = options;
  if (!addressRegex.test(value))
    throw new InvalidAddressError2({
      address: value,
      cause: new InvalidInputError()
    });
  if (strict) {
    if (value.toLowerCase() === value)
      return;
    if (checksum2(value) !== value)
      throw new InvalidAddressError2({
        address: value,
        cause: new InvalidChecksumError()
      });
  }
}
function checksum2(address) {
  if (checksum.has(address))
    return checksum.get(address);
  assert(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash = keccak2562(fromString(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hash[i2 >> 1] >> 4 >= 8 && characters[i2]) {
      characters[i2] = characters[i2].toUpperCase();
    }
    if ((hash[i2 >> 1] & 15) >= 8 && characters[i2 + 1]) {
      characters[i2 + 1] = characters[i2 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum.set(address, result);
  return result;
}
var InvalidAddressError2 = class extends BaseError {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError = class extends BaseError {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError = class extends BaseError {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/@reown/appkit-adapter-wagmi/node_modules/ox/_esm/core/Solidity.js
var arrayRegex2 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt8 = 2n ** (8n - 1n) - 1n;
var maxInt16 = 2n ** (16n - 1n) - 1n;
var maxInt24 = 2n ** (24n - 1n) - 1n;
var maxInt32 = 2n ** (32n - 1n) - 1n;
var maxInt40 = 2n ** (40n - 1n) - 1n;
var maxInt48 = 2n ** (48n - 1n) - 1n;
var maxInt56 = 2n ** (56n - 1n) - 1n;
var maxInt64 = 2n ** (64n - 1n) - 1n;
var maxInt72 = 2n ** (72n - 1n) - 1n;
var maxInt80 = 2n ** (80n - 1n) - 1n;
var maxInt88 = 2n ** (88n - 1n) - 1n;
var maxInt96 = 2n ** (96n - 1n) - 1n;
var maxInt104 = 2n ** (104n - 1n) - 1n;
var maxInt112 = 2n ** (112n - 1n) - 1n;
var maxInt120 = 2n ** (120n - 1n) - 1n;
var maxInt128 = 2n ** (128n - 1n) - 1n;
var maxInt136 = 2n ** (136n - 1n) - 1n;
var maxInt144 = 2n ** (144n - 1n) - 1n;
var maxInt152 = 2n ** (152n - 1n) - 1n;
var maxInt160 = 2n ** (160n - 1n) - 1n;
var maxInt168 = 2n ** (168n - 1n) - 1n;
var maxInt176 = 2n ** (176n - 1n) - 1n;
var maxInt184 = 2n ** (184n - 1n) - 1n;
var maxInt192 = 2n ** (192n - 1n) - 1n;
var maxInt200 = 2n ** (200n - 1n) - 1n;
var maxInt208 = 2n ** (208n - 1n) - 1n;
var maxInt216 = 2n ** (216n - 1n) - 1n;
var maxInt224 = 2n ** (224n - 1n) - 1n;
var maxInt232 = 2n ** (232n - 1n) - 1n;
var maxInt240 = 2n ** (240n - 1n) - 1n;
var maxInt248 = 2n ** (248n - 1n) - 1n;
var maxInt256 = 2n ** (256n - 1n) - 1n;
var minInt8 = -(2n ** (8n - 1n));
var minInt16 = -(2n ** (16n - 1n));
var minInt24 = -(2n ** (24n - 1n));
var minInt32 = -(2n ** (32n - 1n));
var minInt40 = -(2n ** (40n - 1n));
var minInt48 = -(2n ** (48n - 1n));
var minInt56 = -(2n ** (56n - 1n));
var minInt64 = -(2n ** (64n - 1n));
var minInt72 = -(2n ** (72n - 1n));
var minInt80 = -(2n ** (80n - 1n));
var minInt88 = -(2n ** (88n - 1n));
var minInt96 = -(2n ** (96n - 1n));
var minInt104 = -(2n ** (104n - 1n));
var minInt112 = -(2n ** (112n - 1n));
var minInt120 = -(2n ** (120n - 1n));
var minInt128 = -(2n ** (128n - 1n));
var minInt136 = -(2n ** (136n - 1n));
var minInt144 = -(2n ** (144n - 1n));
var minInt152 = -(2n ** (152n - 1n));
var minInt160 = -(2n ** (160n - 1n));
var minInt168 = -(2n ** (168n - 1n));
var minInt176 = -(2n ** (176n - 1n));
var minInt184 = -(2n ** (184n - 1n));
var minInt192 = -(2n ** (192n - 1n));
var minInt200 = -(2n ** (200n - 1n));
var minInt208 = -(2n ** (208n - 1n));
var minInt216 = -(2n ** (216n - 1n));
var minInt224 = -(2n ** (224n - 1n));
var minInt232 = -(2n ** (232n - 1n));
var minInt240 = -(2n ** (240n - 1n));
var minInt248 = -(2n ** (248n - 1n));
var minInt256 = -(2n ** (256n - 1n));
var maxUint8 = 2n ** 8n - 1n;
var maxUint16 = 2n ** 16n - 1n;
var maxUint24 = 2n ** 24n - 1n;
var maxUint32 = 2n ** 32n - 1n;
var maxUint40 = 2n ** 40n - 1n;
var maxUint48 = 2n ** 48n - 1n;
var maxUint56 = 2n ** 56n - 1n;
var maxUint64 = 2n ** 64n - 1n;
var maxUint72 = 2n ** 72n - 1n;
var maxUint80 = 2n ** 80n - 1n;
var maxUint88 = 2n ** 88n - 1n;
var maxUint96 = 2n ** 96n - 1n;
var maxUint104 = 2n ** 104n - 1n;
var maxUint112 = 2n ** 112n - 1n;
var maxUint120 = 2n ** 120n - 1n;
var maxUint128 = 2n ** 128n - 1n;
var maxUint136 = 2n ** 136n - 1n;
var maxUint144 = 2n ** 144n - 1n;
var maxUint152 = 2n ** 152n - 1n;
var maxUint160 = 2n ** 160n - 1n;
var maxUint168 = 2n ** 168n - 1n;
var maxUint176 = 2n ** 176n - 1n;
var maxUint184 = 2n ** 184n - 1n;
var maxUint192 = 2n ** 192n - 1n;
var maxUint200 = 2n ** 200n - 1n;
var maxUint208 = 2n ** 208n - 1n;
var maxUint216 = 2n ** 216n - 1n;
var maxUint224 = 2n ** 224n - 1n;
var maxUint232 = 2n ** 232n - 1n;
var maxUint240 = 2n ** 240n - 1n;
var maxUint248 = 2n ** 248n - 1n;
var maxUint2562 = 2n ** 256n - 1n;

// node_modules/@reown/appkit-adapter-wagmi/node_modules/ox/_esm/core/internal/cursor.js
var staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError2({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length, size4) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length);
    this.position += size4 ?? length;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
var NegativeOffsetError = class extends BaseError {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError2 = class extends BaseError {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError = class extends BaseError {
  constructor({ count, limit }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/@reown/appkit-adapter-wagmi/node_modules/ox/_esm/core/AbiParameters.js
function encodePacked2(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i2 = 0; i2 < types.length; i2++) {
    const type = types[i2];
    const value = values[i2];
    data.push(encodePacked2.encode(type, value));
  }
  return concat(...data);
}
(function(encodePacked3) {
  function encode5(type, value, isArray = false) {
    if (type === "address") {
      const address = value;
      assert(address);
      return padLeft(address.toLowerCase(), isArray ? 32 : 0);
    }
    if (type === "string")
      return fromString2(value);
    if (type === "bytes")
      return value;
    if (type === "bool")
      return padLeft(fromBoolean(value), isArray ? 32 : 1);
    const intMatch = type.match(integerRegex2);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size4 = Number.parseInt(bits) / 8;
      return fromNumber(value, {
        size: isArray ? 32 : size4,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(bytesRegex2);
    if (bytesMatch) {
      const [_type, size4] = bytesMatch;
      if (Number.parseInt(size4) !== (value.length - 2) / 2)
        throw new BytesSizeMismatchError2({
          expectedSize: Number.parseInt(size4),
          value
        });
      return padRight(value, isArray ? 32 : 0);
    }
    const arrayMatch = type.match(arrayRegex2);
    if (arrayMatch && Array.isArray(value)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i2 = 0; i2 < value.length; i2++) {
        data.push(encode5(childType, value[i2], true));
      }
      if (data.length === 0)
        return "0x";
      return concat(...data);
    }
    throw new InvalidTypeError(type);
  }
  encodePacked3.encode = encode5;
})(encodePacked2 || (encodePacked2 = {}));
var BytesSizeMismatchError2 = class extends BaseError {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError = class extends BaseError {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidTypeError = class extends BaseError {
  constructor(type) {
    super(`Type \`${type}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/@reown/appkit-adapter-wagmi/node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/@reown/appkit-adapter-wagmi/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size4 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size4));
  }
  return new Uint8Array(size4);
}

// node_modules/@reown/appkit-adapter-wagmi/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name, prefix, encode5, decode3) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode: encode5
    },
    decoder: { decode: decode3 }
  };
}
var string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i2 = 0; i2 < buf.length; i2++) {
    string2 += String.fromCharCode(buf[i2]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf[i2] = str.charCodeAt(i2);
  }
  return buf;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/utils/dist/index.es.js
var import_blakejs = __toESM(require_blakejs());
var Be = BigInt(2 ** 32 - 1);
var yr = BigInt(32);
function mr(t, e = false) {
  return e ? { h: Number(t & Be), l: Number(t >> yr & Be) } : { h: Number(t >> yr & Be) | 0, l: Number(t & Be) | 0 };
}
function wr(t, e = false) {
  const n2 = t.length;
  let r2 = new Uint32Array(n2), o2 = new Uint32Array(n2);
  for (let s = 0; s < n2; s++) {
    const { h: i2, l: f4 } = mr(t[s], e);
    [r2[s], o2[s]] = [i2, f4];
  }
  return [r2, o2];
}
var xr = (t, e, n2) => t >>> n2;
var vr = (t, e, n2) => t << 32 - n2 | e >>> n2;
var At = (t, e, n2) => t >>> n2 | e << 32 - n2;
var St = (t, e, n2) => t << 32 - n2 | e >>> n2;
var se = (t, e, n2) => t << 64 - n2 | e >>> n2 - 32;
var ie = (t, e, n2) => t >>> n2 - 32 | e << 64 - n2;
var bi = (t, e) => e;
var yi = (t, e) => t;
var mi = (t, e, n2) => t << n2 | e >>> 32 - n2;
var wi = (t, e, n2) => e << n2 | t >>> 32 - n2;
var xi = (t, e, n2) => e << n2 - 32 | t >>> 64 - n2;
var vi = (t, e, n2) => t << n2 - 32 | e >>> 64 - n2;
function dt(t, e, n2, r2) {
  const o2 = (e >>> 0) + (r2 >>> 0);
  return { h: t + n2 + (o2 / 2 ** 32 | 0) | 0, l: o2 | 0 };
}
var tn = (t, e, n2) => (t >>> 0) + (e >>> 0) + (n2 >>> 0);
var en = (t, e, n2, r2) => e + n2 + r2 + (t / 2 ** 32 | 0) | 0;
var Ei = (t, e, n2, r2) => (t >>> 0) + (e >>> 0) + (n2 >>> 0) + (r2 >>> 0);
var Bi = (t, e, n2, r2, o2) => e + n2 + r2 + o2 + (t / 2 ** 32 | 0) | 0;
var Ii = (t, e, n2, r2, o2) => (t >>> 0) + (e >>> 0) + (n2 >>> 0) + (r2 >>> 0) + (o2 >>> 0);
var Ai = (t, e, n2, r2, o2, s) => e + n2 + r2 + o2 + s + (t / 2 ** 32 | 0) | 0;
var Gt = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function nn(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function mt(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function at(t, ...e) {
  if (!nn(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function rn(t) {
  if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
  mt(t.outputLen), mt(t.blockLen);
}
function Nt(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function on(t, e) {
  at(t);
  const n2 = e.outputLen;
  if (t.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
function fe(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function ut(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
function sn2(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function gt(t, e) {
  return t << 32 - e | t >>> e;
}
var Er = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Br(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
var wt = Er ? (t) => t : (t) => Br(t);
function Si(t) {
  for (let e = 0; e < t.length; e++) t[e] = Br(t[e]);
  return t;
}
var Ot = Er ? (t) => t : Si;
var Ir = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function";
var Ni = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function ce(t) {
  if (at(t), Ir) return t.toHex();
  let e = "";
  for (let n2 = 0; n2 < t.length; n2++) e += Ni[t[n2]];
  return e;
}
var xt = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Ar(t) {
  if (t >= xt._0 && t <= xt._9) return t - xt._0;
  if (t >= xt.A && t <= xt.F) return t - (xt.A - 10);
  if (t >= xt.a && t <= xt.f) return t - (xt.a - 10);
}
function fn(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  if (Ir) return Uint8Array.fromHex(t);
  const e = t.length, n2 = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const r2 = new Uint8Array(n2);
  for (let o2 = 0, s = 0; o2 < n2; o2++, s += 2) {
    const i2 = Ar(t.charCodeAt(s)), f4 = Ar(t.charCodeAt(s + 1));
    if (i2 === void 0 || f4 === void 0) {
      const a = t[s] + t[s + 1];
      throw new Error('hex string expected, got non-hex character "' + a + '" at index ' + s);
    }
    r2[o2] = i2 * 16 + f4;
  }
  return r2;
}
function Oi(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function ht(t) {
  return typeof t == "string" && (t = Oi(t)), at(t), t;
}
function Ht(...t) {
  let e = 0;
  for (let r2 = 0; r2 < t.length; r2++) {
    const o2 = t[r2];
    at(o2), e += o2.length;
  }
  const n2 = new Uint8Array(e);
  for (let r2 = 0, o2 = 0; r2 < t.length; r2++) {
    const s = t[r2];
    n2.set(s, o2), o2 += s.length;
  }
  return n2;
}
var Ie = class {
};
function ae(t) {
  const e = (r2) => t().update(ht(r2)).digest(), n2 = t();
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = () => t(), e;
}
function Ui(t) {
  const e = (r2, o2) => t(o2).update(ht(r2)).digest(), n2 = t({});
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = (r2) => t(r2), e;
}
function Zt(t = 32) {
  if (Gt && typeof Gt.getRandomValues == "function") return Gt.getRandomValues(new Uint8Array(t));
  if (Gt && typeof Gt.randomBytes == "function") return Uint8Array.from(Gt.randomBytes(t));
  throw new Error("crypto.getRandomValues must be defined");
}
var _i = BigInt(0);
var ue = BigInt(1);
var Ti = BigInt(2);
var Ri = BigInt(7);
var $i = BigInt(256);
var Ci = BigInt(113);
var Sr = [];
var Nr = [];
var Or = [];
for (let t = 0, e = ue, n2 = 1, r2 = 0; t < 24; t++) {
  [n2, r2] = [r2, (2 * n2 + 3 * r2) % 5], Sr.push(2 * (5 * r2 + n2)), Nr.push((t + 1) * (t + 2) / 2 % 64);
  let o2 = _i;
  for (let s = 0; s < 7; s++) e = (e << ue ^ (e >> Ri) * Ci) % $i, e & Ti && (o2 ^= ue << (ue << BigInt(s)) - ue);
  Or.push(o2);
}
var Ur = wr(Or, true);
var Li = Ur[0];
var ji = Ur[1];
var _r = (t, e, n2) => n2 > 32 ? xi(t, e, n2) : mi(t, e, n2);
var Tr = (t, e, n2) => n2 > 32 ? vi(t, e, n2) : wi(t, e, n2);
function ki(t, e = 24) {
  const n2 = new Uint32Array(10);
  for (let r2 = 24 - e; r2 < 24; r2++) {
    for (let i2 = 0; i2 < 10; i2++) n2[i2] = t[i2] ^ t[i2 + 10] ^ t[i2 + 20] ^ t[i2 + 30] ^ t[i2 + 40];
    for (let i2 = 0; i2 < 10; i2 += 2) {
      const f4 = (i2 + 8) % 10, a = (i2 + 2) % 10, l3 = n2[a], c2 = n2[a + 1], u = _r(l3, c2, 1) ^ n2[f4], h3 = Tr(l3, c2, 1) ^ n2[f4 + 1];
      for (let g = 0; g < 50; g += 10) t[i2 + g] ^= u, t[i2 + g + 1] ^= h3;
    }
    let o2 = t[2], s = t[3];
    for (let i2 = 0; i2 < 24; i2++) {
      const f4 = Nr[i2], a = _r(o2, s, f4), l3 = Tr(o2, s, f4), c2 = Sr[i2];
      o2 = t[c2], s = t[c2 + 1], t[c2] = a, t[c2 + 1] = l3;
    }
    for (let i2 = 0; i2 < 50; i2 += 10) {
      for (let f4 = 0; f4 < 10; f4++) n2[f4] = t[i2 + f4];
      for (let f4 = 0; f4 < 10; f4++) t[i2 + f4] ^= ~n2[(f4 + 2) % 10] & n2[(f4 + 4) % 10];
    }
    t[0] ^= Li[r2], t[1] ^= ji[r2];
  }
  ut(n2);
}
var qn = class _qn extends Ie {
  constructor(e, n2, r2, o2 = false, s = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e, this.suffix = n2, this.outputLen = r2, this.enableXOF = o2, this.rounds = s, mt(r2), !(0 < e && e < 200)) throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = fe(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Ot(this.state32), ki(this.state32, this.rounds), Ot(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Nt(this), e = ht(e), at(e);
    const { blockLen: n2, state: r2 } = this, o2 = e.length;
    for (let s = 0; s < o2; ) {
      const i2 = Math.min(n2 - this.pos, o2 - s);
      for (let f4 = 0; f4 < i2; f4++) r2[this.pos++] ^= e[s++];
      this.pos === n2 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e, suffix: n2, pos: r2, blockLen: o2 } = this;
    e[r2] ^= n2, (n2 & 128) !== 0 && r2 === o2 - 1 && this.keccak(), e[o2 - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Nt(this, false), at(e), this.finish();
    const n2 = this.state, { blockLen: r2 } = this;
    for (let o2 = 0, s = e.length; o2 < s; ) {
      this.posOut >= r2 && this.keccak();
      const i2 = Math.min(r2 - this.posOut, s - o2);
      e.set(n2.subarray(this.posOut, this.posOut + i2), o2), this.posOut += i2, o2 += i2;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return mt(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (on(e, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, ut(this.state);
  }
  _cloneInto(e) {
    const { blockLen: n2, suffix: r2, outputLen: o2, rounds: s, enableXOF: i2 } = this;
    return e || (e = new _qn(n2, r2, o2, i2, s)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s, e.suffix = r2, e.outputLen = o2, e.enableXOF = i2, e.destroyed = this.destroyed, e;
  }
};
var Pi = (t, e, n2) => ae(() => new qn(e, t, n2));
var Hi = Pi(1, 136, 256 / 8);
function Di(t, e, n2, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n2, r2);
  const o2 = BigInt(32), s = BigInt(4294967295), i2 = Number(n2 >> o2 & s), f4 = Number(n2 & s), a = r2 ? 4 : 0, l3 = r2 ? 0 : 4;
  t.setUint32(e + a, i2, r2), t.setUint32(e + l3, f4, r2);
}
function Mi(t, e, n2) {
  return t & e ^ ~t & n2;
}
function Vi(t, e, n2) {
  return t & e ^ t & n2 ^ e & n2;
}
var Rr = class extends Ie {
  constructor(e, n2, r2, o2) {
    super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e, this.outputLen = n2, this.padOffset = r2, this.isLE = o2, this.buffer = new Uint8Array(e), this.view = sn2(this.buffer);
  }
  update(e) {
    Nt(this), e = ht(e), at(e);
    const { view: n2, buffer: r2, blockLen: o2 } = this, s = e.length;
    for (let i2 = 0; i2 < s; ) {
      const f4 = Math.min(o2 - this.pos, s - i2);
      if (f4 === o2) {
        const a = sn2(e);
        for (; o2 <= s - i2; i2 += o2) this.process(a, i2);
        continue;
      }
      r2.set(e.subarray(i2, i2 + f4), this.pos), this.pos += f4, i2 += f4, this.pos === o2 && (this.process(n2, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Nt(this), on(e, this), this.finished = true;
    const { buffer: n2, view: r2, blockLen: o2, isLE: s } = this;
    let { pos: i2 } = this;
    n2[i2++] = 128, ut(this.buffer.subarray(i2)), this.padOffset > o2 - i2 && (this.process(r2, 0), i2 = 0);
    for (let u = i2; u < o2; u++) n2[u] = 0;
    Di(r2, o2 - 8, BigInt(this.length * 8), s), this.process(r2, 0);
    const f4 = sn2(e), a = this.outputLen;
    if (a % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l3 = a / 4, c2 = this.get();
    if (l3 > c2.length) throw new Error("_sha2: outputLen bigger than state");
    for (let u = 0; u < l3; u++) f4.setUint32(4 * u, c2[u], s);
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n2, buffer: r2, length: o2, finished: s, destroyed: i2, pos: f4 } = this;
    return e.destroyed = i2, e.finished = s, e.length = o2, e.pos = f4, o2 % n2 && e.buffer.set(r2), e;
  }
  clone() {
    return this._cloneInto();
  }
};
var Ut = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var W = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]);
var Y = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]);
var qi = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var _t = new Uint32Array(64);
var Ki = class extends Rr {
  constructor(e = 32) {
    super(64, e, 8, false), this.A = Ut[0] | 0, this.B = Ut[1] | 0, this.C = Ut[2] | 0, this.D = Ut[3] | 0, this.E = Ut[4] | 0, this.F = Ut[5] | 0, this.G = Ut[6] | 0, this.H = Ut[7] | 0;
  }
  get() {
    const { A: e, B: n2, C: r2, D: o2, E: s, F: i2, G: f4, H: a } = this;
    return [e, n2, r2, o2, s, i2, f4, a];
  }
  set(e, n2, r2, o2, s, i2, f4, a) {
    this.A = e | 0, this.B = n2 | 0, this.C = r2 | 0, this.D = o2 | 0, this.E = s | 0, this.F = i2 | 0, this.G = f4 | 0, this.H = a | 0;
  }
  process(e, n2) {
    for (let u = 0; u < 16; u++, n2 += 4) _t[u] = e.getUint32(n2, false);
    for (let u = 16; u < 64; u++) {
      const h3 = _t[u - 15], g = _t[u - 2], w = gt(h3, 7) ^ gt(h3, 18) ^ h3 >>> 3, y3 = gt(g, 17) ^ gt(g, 19) ^ g >>> 10;
      _t[u] = y3 + _t[u - 7] + w + _t[u - 16] | 0;
    }
    let { A: r2, B: o2, C: s, D: i2, E: f4, F: a, G: l3, H: c2 } = this;
    for (let u = 0; u < 64; u++) {
      const h3 = gt(f4, 6) ^ gt(f4, 11) ^ gt(f4, 25), g = c2 + h3 + Mi(f4, a, l3) + qi[u] + _t[u] | 0, y3 = (gt(r2, 2) ^ gt(r2, 13) ^ gt(r2, 22)) + Vi(r2, o2, s) | 0;
      c2 = l3, l3 = a, a = f4, f4 = i2 + g | 0, i2 = s, s = o2, o2 = r2, r2 = g + y3 | 0;
    }
    r2 = r2 + this.A | 0, o2 = o2 + this.B | 0, s = s + this.C | 0, i2 = i2 + this.D | 0, f4 = f4 + this.E | 0, a = a + this.F | 0, l3 = l3 + this.G | 0, c2 = c2 + this.H | 0, this.set(r2, o2, s, i2, f4, a, l3, c2);
  }
  roundClean() {
    ut(_t);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), ut(this.buffer);
  }
};
var $r = wr(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t) => BigInt(t)));
var Fi = $r[0];
var zi = $r[1];
var Tt = new Uint32Array(80);
var Rt = new Uint32Array(80);
var cn = class extends Rr {
  constructor(e = 64) {
    super(128, e, 16, false), this.Ah = Y[0] | 0, this.Al = Y[1] | 0, this.Bh = Y[2] | 0, this.Bl = Y[3] | 0, this.Ch = Y[4] | 0, this.Cl = Y[5] | 0, this.Dh = Y[6] | 0, this.Dl = Y[7] | 0, this.Eh = Y[8] | 0, this.El = Y[9] | 0, this.Fh = Y[10] | 0, this.Fl = Y[11] | 0, this.Gh = Y[12] | 0, this.Gl = Y[13] | 0, this.Hh = Y[14] | 0, this.Hl = Y[15] | 0;
  }
  get() {
    const { Ah: e, Al: n2, Bh: r2, Bl: o2, Ch: s, Cl: i2, Dh: f4, Dl: a, Eh: l3, El: c2, Fh: u, Fl: h3, Gh: g, Gl: w, Hh: y3, Hl: x } = this;
    return [e, n2, r2, o2, s, i2, f4, a, l3, c2, u, h3, g, w, y3, x];
  }
  set(e, n2, r2, o2, s, i2, f4, a, l3, c2, u, h3, g, w, y3, x) {
    this.Ah = e | 0, this.Al = n2 | 0, this.Bh = r2 | 0, this.Bl = o2 | 0, this.Ch = s | 0, this.Cl = i2 | 0, this.Dh = f4 | 0, this.Dl = a | 0, this.Eh = l3 | 0, this.El = c2 | 0, this.Fh = u | 0, this.Fl = h3 | 0, this.Gh = g | 0, this.Gl = w | 0, this.Hh = y3 | 0, this.Hl = x | 0;
  }
  process(e, n2) {
    for (let L = 0; L < 16; L++, n2 += 4) Tt[L] = e.getUint32(n2), Rt[L] = e.getUint32(n2 += 4);
    for (let L = 16; L < 80; L++) {
      const V3 = Tt[L - 15] | 0, _ = Rt[L - 15] | 0, k2 = At(V3, _, 1) ^ At(V3, _, 8) ^ xr(V3, _, 7), j = St(V3, _, 1) ^ St(V3, _, 8) ^ vr(V3, _, 7), $2 = Tt[L - 2] | 0, d2 = Rt[L - 2] | 0, m2 = At($2, d2, 19) ^ se($2, d2, 61) ^ xr($2, d2, 6), p = St($2, d2, 19) ^ ie($2, d2, 61) ^ vr($2, d2, 6), b = Ei(j, p, Rt[L - 7], Rt[L - 16]), v = Bi(b, k2, m2, Tt[L - 7], Tt[L - 16]);
      Tt[L] = v | 0, Rt[L] = b | 0;
    }
    let { Ah: r2, Al: o2, Bh: s, Bl: i2, Ch: f4, Cl: a, Dh: l3, Dl: c2, Eh: u, El: h3, Fh: g, Fl: w, Gh: y3, Gl: x, Hh: R2, Hl: M2 } = this;
    for (let L = 0; L < 80; L++) {
      const V3 = At(u, h3, 14) ^ At(u, h3, 18) ^ se(u, h3, 41), _ = St(u, h3, 14) ^ St(u, h3, 18) ^ ie(u, h3, 41), k2 = u & g ^ ~u & y3, j = h3 & w ^ ~h3 & x, $2 = Ii(M2, _, j, zi[L], Rt[L]), d2 = Ai($2, R2, V3, k2, Fi[L], Tt[L]), m2 = $2 | 0, p = At(r2, o2, 28) ^ se(r2, o2, 34) ^ se(r2, o2, 39), b = St(r2, o2, 28) ^ ie(r2, o2, 34) ^ ie(r2, o2, 39), v = r2 & s ^ r2 & f4 ^ s & f4, B = o2 & i2 ^ o2 & a ^ i2 & a;
      R2 = y3 | 0, M2 = x | 0, y3 = g | 0, x = w | 0, g = u | 0, w = h3 | 0, { h: u, l: h3 } = dt(l3 | 0, c2 | 0, d2 | 0, m2 | 0), l3 = f4 | 0, c2 = a | 0, f4 = s | 0, a = i2 | 0, s = r2 | 0, i2 = o2 | 0;
      const E2 = tn(m2, b, B);
      r2 = en(E2, d2, p, v), o2 = E2 | 0;
    }
    ({ h: r2, l: o2 } = dt(this.Ah | 0, this.Al | 0, r2 | 0, o2 | 0)), { h: s, l: i2 } = dt(this.Bh | 0, this.Bl | 0, s | 0, i2 | 0), { h: f4, l: a } = dt(this.Ch | 0, this.Cl | 0, f4 | 0, a | 0), { h: l3, l: c2 } = dt(this.Dh | 0, this.Dl | 0, l3 | 0, c2 | 0), { h: u, l: h3 } = dt(this.Eh | 0, this.El | 0, u | 0, h3 | 0), { h: g, l: w } = dt(this.Fh | 0, this.Fl | 0, g | 0, w | 0), { h: y3, l: x } = dt(this.Gh | 0, this.Gl | 0, y3 | 0, x | 0), { h: R2, l: M2 } = dt(this.Hh | 0, this.Hl | 0, R2 | 0, M2 | 0), this.set(r2, o2, s, i2, f4, a, l3, c2, u, h3, g, w, y3, x, R2, M2);
  }
  roundClean() {
    ut(Tt, Rt);
  }
  destroy() {
    ut(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Gi = class extends cn {
  constructor() {
    super(48), this.Ah = W[0] | 0, this.Al = W[1] | 0, this.Bh = W[2] | 0, this.Bl = W[3] | 0, this.Ch = W[4] | 0, this.Cl = W[5] | 0, this.Dh = W[6] | 0, this.Dl = W[7] | 0, this.Eh = W[8] | 0, this.El = W[9] | 0, this.Fh = W[10] | 0, this.Fl = W[11] | 0, this.Gh = W[12] | 0, this.Gl = W[13] | 0, this.Hh = W[14] | 0, this.Hl = W[15] | 0;
  }
};
var X = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
var Zi = class extends cn {
  constructor() {
    super(32), this.Ah = X[0] | 0, this.Al = X[1] | 0, this.Bh = X[2] | 0, this.Bl = X[3] | 0, this.Ch = X[4] | 0, this.Cl = X[5] | 0, this.Dh = X[6] | 0, this.Dl = X[7] | 0, this.Eh = X[8] | 0, this.El = X[9] | 0, this.Fh = X[10] | 0, this.Fl = X[11] | 0, this.Gh = X[12] | 0, this.Gl = X[13] | 0, this.Hh = X[14] | 0, this.Hl = X[15] | 0;
  }
};
var Ae = ae(() => new Ki());
var Wi = ae(() => new cn());
var Yi = ae(() => new Gi());
var Xi = ae(() => new Zi());
var Ji = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]);
var F = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]);
var N = new Uint32Array(32);
function $t(t, e, n2, r2, o2, s) {
  const i2 = o2[s], f4 = o2[s + 1];
  let a = N[2 * t], l3 = N[2 * t + 1], c2 = N[2 * e], u = N[2 * e + 1], h3 = N[2 * n2], g = N[2 * n2 + 1], w = N[2 * r2], y3 = N[2 * r2 + 1], x = tn(a, c2, i2);
  l3 = en(x, l3, u, f4), a = x | 0, { Dh: y3, Dl: w } = { Dh: y3 ^ l3, Dl: w ^ a }, { Dh: y3, Dl: w } = { Dh: bi(y3, w), Dl: yi(y3) }, { h: g, l: h3 } = dt(g, h3, y3, w), { Bh: u, Bl: c2 } = { Bh: u ^ g, Bl: c2 ^ h3 }, { Bh: u, Bl: c2 } = { Bh: At(u, c2, 24), Bl: St(u, c2, 24) }, N[2 * t] = a, N[2 * t + 1] = l3, N[2 * e] = c2, N[2 * e + 1] = u, N[2 * n2] = h3, N[2 * n2 + 1] = g, N[2 * r2] = w, N[2 * r2 + 1] = y3;
}
function Ct(t, e, n2, r2, o2, s) {
  const i2 = o2[s], f4 = o2[s + 1];
  let a = N[2 * t], l3 = N[2 * t + 1], c2 = N[2 * e], u = N[2 * e + 1], h3 = N[2 * n2], g = N[2 * n2 + 1], w = N[2 * r2], y3 = N[2 * r2 + 1], x = tn(a, c2, i2);
  l3 = en(x, l3, u, f4), a = x | 0, { Dh: y3, Dl: w } = { Dh: y3 ^ l3, Dl: w ^ a }, { Dh: y3, Dl: w } = { Dh: At(y3, w, 16), Dl: St(y3, w, 16) }, { h: g, l: h3 } = dt(g, h3, y3, w), { Bh: u, Bl: c2 } = { Bh: u ^ g, Bl: c2 ^ h3 }, { Bh: u, Bl: c2 } = { Bh: se(u, c2, 63), Bl: ie(u, c2, 63) }, N[2 * t] = a, N[2 * t + 1] = l3, N[2 * e] = c2, N[2 * e + 1] = u, N[2 * n2] = h3, N[2 * n2 + 1] = g, N[2 * r2] = w, N[2 * r2 + 1] = y3;
}
function Qi(t, e = {}, n2, r2, o2) {
  if (mt(n2), t < 0 || t > n2) throw new Error("outputLen bigger than keyLen");
  const { key: s, salt: i2, personalization: f4 } = e;
  if (s !== void 0 && (s.length < 1 || s.length > n2)) throw new Error("key length must be undefined or 1.." + n2);
  if (i2 !== void 0 && i2.length !== r2) throw new Error("salt must be undefined or " + r2);
  if (f4 !== void 0 && f4.length !== o2) throw new Error("personalization must be undefined or " + o2);
}
var tf = class extends Ie {
  constructor(e, n2) {
    super(), this.finished = false, this.destroyed = false, this.length = 0, this.pos = 0, mt(e), mt(n2), this.blockLen = e, this.outputLen = n2, this.buffer = new Uint8Array(e), this.buffer32 = fe(this.buffer);
  }
  update(e) {
    Nt(this), e = ht(e), at(e);
    const { blockLen: n2, buffer: r2, buffer32: o2 } = this, s = e.length, i2 = e.byteOffset, f4 = e.buffer;
    for (let a = 0; a < s; ) {
      this.pos === n2 && (Ot(o2), this.compress(o2, 0, false), Ot(o2), this.pos = 0);
      const l3 = Math.min(n2 - this.pos, s - a), c2 = i2 + a;
      if (l3 === n2 && !(c2 % 4) && a + l3 < s) {
        const u = new Uint32Array(f4, c2, Math.floor((s - a) / 4));
        Ot(u);
        for (let h3 = 0; a + n2 < s; h3 += o2.length, a += n2) this.length += n2, this.compress(u, h3, false);
        Ot(u);
        continue;
      }
      r2.set(e.subarray(a, a + l3), this.pos), this.pos += l3, this.length += l3, a += l3;
    }
    return this;
  }
  digestInto(e) {
    Nt(this), on(e, this);
    const { pos: n2, buffer32: r2 } = this;
    this.finished = true, ut(this.buffer.subarray(n2)), Ot(r2), this.compress(r2, 0, true), Ot(r2);
    const o2 = fe(e);
    this.get().forEach((s, i2) => o2[i2] = wt(s));
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
  _cloneInto(e) {
    const { buffer: n2, length: r2, finished: o2, destroyed: s, outputLen: i2, pos: f4 } = this;
    return e || (e = new this.constructor({ dkLen: i2 })), e.set(...this.get()), e.buffer.set(n2), e.destroyed = s, e.finished = o2, e.length = r2, e.pos = f4, e.outputLen = i2, e;
  }
  clone() {
    return this._cloneInto();
  }
};
var ef = class extends tf {
  constructor(e = {}) {
    const n2 = e.dkLen === void 0 ? 64 : e.dkLen;
    super(128, n2), this.v0l = F[0] | 0, this.v0h = F[1] | 0, this.v1l = F[2] | 0, this.v1h = F[3] | 0, this.v2l = F[4] | 0, this.v2h = F[5] | 0, this.v3l = F[6] | 0, this.v3h = F[7] | 0, this.v4l = F[8] | 0, this.v4h = F[9] | 0, this.v5l = F[10] | 0, this.v5h = F[11] | 0, this.v6l = F[12] | 0, this.v6h = F[13] | 0, this.v7l = F[14] | 0, this.v7h = F[15] | 0, Qi(n2, e, 64, 16, 16);
    let { key: r2, personalization: o2, salt: s } = e, i2 = 0;
    if (r2 !== void 0 && (r2 = ht(r2), i2 = r2.length), this.v0l ^= this.outputLen | i2 << 8 | 65536 | 1 << 24, s !== void 0) {
      s = ht(s);
      const f4 = fe(s);
      this.v4l ^= wt(f4[0]), this.v4h ^= wt(f4[1]), this.v5l ^= wt(f4[2]), this.v5h ^= wt(f4[3]);
    }
    if (o2 !== void 0) {
      o2 = ht(o2);
      const f4 = fe(o2);
      this.v6l ^= wt(f4[0]), this.v6h ^= wt(f4[1]), this.v7l ^= wt(f4[2]), this.v7h ^= wt(f4[3]);
    }
    if (r2 !== void 0) {
      const f4 = new Uint8Array(this.blockLen);
      f4.set(r2), this.update(f4);
    }
  }
  get() {
    let { v0l: e, v0h: n2, v1l: r2, v1h: o2, v2l: s, v2h: i2, v3l: f4, v3h: a, v4l: l3, v4h: c2, v5l: u, v5h: h3, v6l: g, v6h: w, v7l: y3, v7h: x } = this;
    return [e, n2, r2, o2, s, i2, f4, a, l3, c2, u, h3, g, w, y3, x];
  }
  set(e, n2, r2, o2, s, i2, f4, a, l3, c2, u, h3, g, w, y3, x) {
    this.v0l = e | 0, this.v0h = n2 | 0, this.v1l = r2 | 0, this.v1h = o2 | 0, this.v2l = s | 0, this.v2h = i2 | 0, this.v3l = f4 | 0, this.v3h = a | 0, this.v4l = l3 | 0, this.v4h = c2 | 0, this.v5l = u | 0, this.v5h = h3 | 0, this.v6l = g | 0, this.v6h = w | 0, this.v7l = y3 | 0, this.v7h = x | 0;
  }
  compress(e, n2, r2) {
    this.get().forEach((a, l3) => N[l3] = a), N.set(F, 16);
    let { h: o2, l: s } = mr(BigInt(this.length));
    N[24] = F[8] ^ s, N[25] = F[9] ^ o2, r2 && (N[28] = ~N[28], N[29] = ~N[29]);
    let i2 = 0;
    const f4 = Ji;
    for (let a = 0; a < 12; a++) $t(0, 4, 8, 12, e, n2 + 2 * f4[i2++]), Ct(0, 4, 8, 12, e, n2 + 2 * f4[i2++]), $t(1, 5, 9, 13, e, n2 + 2 * f4[i2++]), Ct(1, 5, 9, 13, e, n2 + 2 * f4[i2++]), $t(2, 6, 10, 14, e, n2 + 2 * f4[i2++]), Ct(2, 6, 10, 14, e, n2 + 2 * f4[i2++]), $t(3, 7, 11, 15, e, n2 + 2 * f4[i2++]), Ct(3, 7, 11, 15, e, n2 + 2 * f4[i2++]), $t(0, 5, 10, 15, e, n2 + 2 * f4[i2++]), Ct(0, 5, 10, 15, e, n2 + 2 * f4[i2++]), $t(1, 6, 11, 12, e, n2 + 2 * f4[i2++]), Ct(1, 6, 11, 12, e, n2 + 2 * f4[i2++]), $t(2, 7, 8, 13, e, n2 + 2 * f4[i2++]), Ct(2, 7, 8, 13, e, n2 + 2 * f4[i2++]), $t(3, 4, 9, 14, e, n2 + 2 * f4[i2++]), Ct(3, 4, 9, 14, e, n2 + 2 * f4[i2++]);
    this.v0l ^= N[0] ^ N[16], this.v0h ^= N[1] ^ N[17], this.v1l ^= N[2] ^ N[18], this.v1h ^= N[3] ^ N[19], this.v2l ^= N[4] ^ N[20], this.v2h ^= N[5] ^ N[21], this.v3l ^= N[6] ^ N[22], this.v3h ^= N[7] ^ N[23], this.v4l ^= N[8] ^ N[24], this.v4h ^= N[9] ^ N[25], this.v5l ^= N[10] ^ N[26], this.v5h ^= N[11] ^ N[27], this.v6l ^= N[12] ^ N[28], this.v6h ^= N[13] ^ N[29], this.v7l ^= N[14] ^ N[30], this.v7h ^= N[15] ^ N[31], ut(N);
  }
  destroy() {
    this.destroyed = true, ut(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var nf = Ui((t) => new ef(t));
function Qr(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function bn(t) {
  if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
}
function yn(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function nt(t, ...e) {
  if (!Qr(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function to(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function Sf(t, e) {
  nt(t);
  const n2 = e.outputLen;
  if (t.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
function jt(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function Wt(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
function Nf(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
var Of = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Uf(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function mn(t) {
  if (typeof t == "string") t = Uf(t);
  else if (Qr(t)) t = wn(t);
  else throw new Error("Uint8Array expected, got " + typeof t);
  return t;
}
function _f(t, e) {
  if (e == null || typeof e != "object") throw new Error("options must be defined");
  return Object.assign(t, e);
}
function Tf(t, e) {
  if (t.length !== e.length) return false;
  let n2 = 0;
  for (let r2 = 0; r2 < t.length; r2++) n2 |= t[r2] ^ e[r2];
  return n2 === 0;
}
var Rf = (t, e) => {
  function n2(r2, ...o2) {
    if (nt(r2), !Of) throw new Error("Non little-endian hardware is not yet supported");
    if (t.nonceLength !== void 0) {
      const c2 = o2[0];
      if (!c2) throw new Error("nonce / iv required");
      t.varSizeNonce ? nt(c2) : nt(c2, t.nonceLength);
    }
    const s = t.tagLength;
    s && o2[1] !== void 0 && nt(o2[1]);
    const i2 = e(r2, ...o2), f4 = (c2, u) => {
      if (u !== void 0) {
        if (c2 !== 2) throw new Error("cipher output not supported");
        nt(u);
      }
    };
    let a = false;
    return { encrypt(c2, u) {
      if (a) throw new Error("cannot encrypt() twice with same key + nonce");
      return a = true, nt(c2), f4(i2.encrypt.length, u), i2.encrypt(c2, u);
    }, decrypt(c2, u) {
      if (nt(c2), s && c2.length < s) throw new Error("invalid ciphertext length: smaller than tagLength=" + s);
      return f4(i2.decrypt.length, u), i2.decrypt(c2, u);
    } };
  }
  return Object.assign(n2, t), n2;
};
function eo(t, e, n2 = true) {
  if (e === void 0) return new Uint8Array(t);
  if (e.length !== t) throw new Error("invalid output length, expected " + t + ", got: " + e.length);
  if (n2 && !Cf(e)) throw new Error("invalid output, must be aligned");
  return e;
}
function no(t, e, n2, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n2, r2);
  const o2 = BigInt(32), s = BigInt(4294967295), i2 = Number(n2 >> o2 & s), f4 = Number(n2 & s), a = r2 ? 4 : 0, l3 = r2 ? 0 : 4;
  t.setUint32(e + a, i2, r2), t.setUint32(e + l3, f4, r2);
}
function $f(t, e, n2) {
  bn(n2);
  const r2 = new Uint8Array(16), o2 = Nf(r2);
  return no(o2, 0, BigInt(e), n2), no(o2, 8, BigInt(t), n2), r2;
}
function Cf(t) {
  return t.byteOffset % 4 === 0;
}
function wn(t) {
  return Uint8Array.from(t);
}
var ro = (t) => Uint8Array.from(t.split("").map((e) => e.charCodeAt(0)));
var Lf = ro("expand 16-byte k");
var jf = ro("expand 32-byte k");
var kf = jt(Lf);
var Pf = jt(jf);
function D(t, e) {
  return t << e | t >>> 32 - e;
}
function xn(t) {
  return t.byteOffset % 4 === 0;
}
var Ue = 64;
var Hf = 16;
var oo = 2 ** 32 - 1;
var so = new Uint32Array();
function Df(t, e, n2, r2, o2, s, i2, f4) {
  const a = o2.length, l3 = new Uint8Array(Ue), c2 = jt(l3), u = xn(o2) && xn(s), h3 = u ? jt(o2) : so, g = u ? jt(s) : so;
  for (let w = 0; w < a; i2++) {
    if (t(e, n2, r2, c2, i2, f4), i2 >= oo) throw new Error("arx: counter overflow");
    const y3 = Math.min(Ue, a - w);
    if (u && y3 === Ue) {
      const x = w / 4;
      if (w % 4 !== 0) throw new Error("arx: invalid block position");
      for (let R2 = 0, M2; R2 < Hf; R2++) M2 = x + R2, g[M2] = h3[M2] ^ c2[R2];
      w += Ue;
      continue;
    }
    for (let x = 0, R2; x < y3; x++) R2 = w + x, s[R2] = o2[R2] ^ l3[x];
    w += y3;
  }
}
function Mf(t, e) {
  const { allowShortKeys: n2, extendNonceFn: r2, counterLength: o2, counterRight: s, rounds: i2 } = _f({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e);
  if (typeof t != "function") throw new Error("core must be a function");
  return yn(o2), yn(i2), bn(s), bn(n2), (f4, a, l3, c2, u = 0) => {
    nt(f4), nt(a), nt(l3);
    const h3 = l3.length;
    if (c2 === void 0 && (c2 = new Uint8Array(h3)), nt(c2), yn(u), u < 0 || u >= oo) throw new Error("arx: counter overflow");
    if (c2.length < h3) throw new Error(`arx: output (${c2.length}) is shorter than data (${h3})`);
    const g = [];
    let w = f4.length, y3, x;
    if (w === 32) g.push(y3 = wn(f4)), x = Pf;
    else if (w === 16 && n2) y3 = new Uint8Array(32), y3.set(f4), y3.set(f4, 16), x = kf, g.push(y3);
    else throw new Error(`arx: invalid 32-byte key, got length=${w}`);
    xn(a) || g.push(a = wn(a));
    const R2 = jt(y3);
    if (r2) {
      if (a.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r2(x, R2, jt(a.subarray(0, 16)), R2), a = a.subarray(16);
    }
    const M2 = 16 - o2;
    if (M2 !== a.length) throw new Error(`arx: nonce must be ${M2} or 16 bytes`);
    if (M2 !== 12) {
      const V3 = new Uint8Array(12);
      V3.set(a, s ? 0 : 12 - a.length), a = V3, g.push(a);
    }
    const L = jt(a);
    return Df(t, x, R2, L, l3, c2, u, i2), Wt(...g), c2;
  };
}
var G = (t, e) => t[e++] & 255 | (t[e++] & 255) << 8;
var Vf = class {
  constructor(e) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e = mn(e), nt(e, 32);
    const n2 = G(e, 0), r2 = G(e, 2), o2 = G(e, 4), s = G(e, 6), i2 = G(e, 8), f4 = G(e, 10), a = G(e, 12), l3 = G(e, 14);
    this.r[0] = n2 & 8191, this.r[1] = (n2 >>> 13 | r2 << 3) & 8191, this.r[2] = (r2 >>> 10 | o2 << 6) & 7939, this.r[3] = (o2 >>> 7 | s << 9) & 8191, this.r[4] = (s >>> 4 | i2 << 12) & 255, this.r[5] = i2 >>> 1 & 8190, this.r[6] = (i2 >>> 14 | f4 << 2) & 8191, this.r[7] = (f4 >>> 11 | a << 5) & 8065, this.r[8] = (a >>> 8 | l3 << 8) & 8191, this.r[9] = l3 >>> 5 & 127;
    for (let c2 = 0; c2 < 8; c2++) this.pad[c2] = G(e, 16 + 2 * c2);
  }
  process(e, n2, r2 = false) {
    const o2 = r2 ? 0 : 2048, { h: s, r: i2 } = this, f4 = i2[0], a = i2[1], l3 = i2[2], c2 = i2[3], u = i2[4], h3 = i2[5], g = i2[6], w = i2[7], y3 = i2[8], x = i2[9], R2 = G(e, n2 + 0), M2 = G(e, n2 + 2), L = G(e, n2 + 4), V3 = G(e, n2 + 6), _ = G(e, n2 + 8), k2 = G(e, n2 + 10), j = G(e, n2 + 12), $2 = G(e, n2 + 14);
    let d2 = s[0] + (R2 & 8191), m2 = s[1] + ((R2 >>> 13 | M2 << 3) & 8191), p = s[2] + ((M2 >>> 10 | L << 6) & 8191), b = s[3] + ((L >>> 7 | V3 << 9) & 8191), v = s[4] + ((V3 >>> 4 | _ << 12) & 8191), B = s[5] + (_ >>> 1 & 8191), E2 = s[6] + ((_ >>> 14 | k2 << 2) & 8191), I2 = s[7] + ((k2 >>> 11 | j << 5) & 8191), S2 = s[8] + ((j >>> 8 | $2 << 8) & 8191), O2 = s[9] + ($2 >>> 5 | o2), A3 = 0, T = A3 + d2 * f4 + m2 * (5 * x) + p * (5 * y3) + b * (5 * w) + v * (5 * g);
    A3 = T >>> 13, T &= 8191, T += B * (5 * h3) + E2 * (5 * u) + I2 * (5 * c2) + S2 * (5 * l3) + O2 * (5 * a), A3 += T >>> 13, T &= 8191;
    let U2 = A3 + d2 * a + m2 * f4 + p * (5 * x) + b * (5 * y3) + v * (5 * w);
    A3 = U2 >>> 13, U2 &= 8191, U2 += B * (5 * g) + E2 * (5 * h3) + I2 * (5 * u) + S2 * (5 * c2) + O2 * (5 * l3), A3 += U2 >>> 13, U2 &= 8191;
    let C3 = A3 + d2 * l3 + m2 * a + p * f4 + b * (5 * x) + v * (5 * y3);
    A3 = C3 >>> 13, C3 &= 8191, C3 += B * (5 * w) + E2 * (5 * g) + I2 * (5 * h3) + S2 * (5 * u) + O2 * (5 * c2), A3 += C3 >>> 13, C3 &= 8191;
    let H = A3 + d2 * c2 + m2 * l3 + p * a + b * f4 + v * (5 * x);
    A3 = H >>> 13, H &= 8191, H += B * (5 * y3) + E2 * (5 * w) + I2 * (5 * g) + S2 * (5 * h3) + O2 * (5 * u), A3 += H >>> 13, H &= 8191;
    let q2 = A3 + d2 * u + m2 * c2 + p * l3 + b * a + v * f4;
    A3 = q2 >>> 13, q2 &= 8191, q2 += B * (5 * x) + E2 * (5 * y3) + I2 * (5 * w) + S2 * (5 * g) + O2 * (5 * h3), A3 += q2 >>> 13, q2 &= 8191;
    let P2 = A3 + d2 * h3 + m2 * u + p * c2 + b * l3 + v * a;
    A3 = P2 >>> 13, P2 &= 8191, P2 += B * f4 + E2 * (5 * x) + I2 * (5 * y3) + S2 * (5 * w) + O2 * (5 * g), A3 += P2 >>> 13, P2 &= 8191;
    let K2 = A3 + d2 * g + m2 * h3 + p * u + b * c2 + v * l3;
    A3 = K2 >>> 13, K2 &= 8191, K2 += B * a + E2 * f4 + I2 * (5 * x) + S2 * (5 * y3) + O2 * (5 * w), A3 += K2 >>> 13, K2 &= 8191;
    let et = A3 + d2 * w + m2 * g + p * h3 + b * u + v * c2;
    A3 = et >>> 13, et &= 8191, et += B * l3 + E2 * a + I2 * f4 + S2 * (5 * x) + O2 * (5 * y3), A3 += et >>> 13, et &= 8191;
    let Z = A3 + d2 * y3 + m2 * w + p * g + b * h3 + v * u;
    A3 = Z >>> 13, Z &= 8191, Z += B * c2 + E2 * l3 + I2 * a + S2 * f4 + O2 * (5 * x), A3 += Z >>> 13, Z &= 8191;
    let z = A3 + d2 * x + m2 * y3 + p * w + b * g + v * h3;
    A3 = z >>> 13, z &= 8191, z += B * u + E2 * c2 + I2 * l3 + S2 * a + O2 * f4, A3 += z >>> 13, z &= 8191, A3 = (A3 << 2) + A3 | 0, A3 = A3 + T | 0, T = A3 & 8191, A3 = A3 >>> 13, U2 += A3, s[0] = T, s[1] = U2, s[2] = C3, s[3] = H, s[4] = q2, s[5] = P2, s[6] = K2, s[7] = et, s[8] = Z, s[9] = z;
  }
  finalize() {
    const { h: e, pad: n2 } = this, r2 = new Uint16Array(10);
    let o2 = e[1] >>> 13;
    e[1] &= 8191;
    for (let f4 = 2; f4 < 10; f4++) e[f4] += o2, o2 = e[f4] >>> 13, e[f4] &= 8191;
    e[0] += o2 * 5, o2 = e[0] >>> 13, e[0] &= 8191, e[1] += o2, o2 = e[1] >>> 13, e[1] &= 8191, e[2] += o2, r2[0] = e[0] + 5, o2 = r2[0] >>> 13, r2[0] &= 8191;
    for (let f4 = 1; f4 < 10; f4++) r2[f4] = e[f4] + o2, o2 = r2[f4] >>> 13, r2[f4] &= 8191;
    r2[9] -= 8192;
    let s = (o2 ^ 1) - 1;
    for (let f4 = 0; f4 < 10; f4++) r2[f4] &= s;
    s = ~s;
    for (let f4 = 0; f4 < 10; f4++) e[f4] = e[f4] & s | r2[f4];
    e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
    let i2 = e[0] + n2[0];
    e[0] = i2 & 65535;
    for (let f4 = 1; f4 < 8; f4++) i2 = (e[f4] + n2[f4] | 0) + (i2 >>> 16) | 0, e[f4] = i2 & 65535;
    Wt(r2);
  }
  update(e) {
    to(this), e = mn(e), nt(e);
    const { buffer: n2, blockLen: r2 } = this, o2 = e.length;
    for (let s = 0; s < o2; ) {
      const i2 = Math.min(r2 - this.pos, o2 - s);
      if (i2 === r2) {
        for (; r2 <= o2 - s; s += r2) this.process(e, s);
        continue;
      }
      n2.set(e.subarray(s, s + i2), this.pos), this.pos += i2, s += i2, this.pos === r2 && (this.process(n2, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Wt(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e) {
    to(this), Sf(e, this), this.finished = true;
    const { buffer: n2, h: r2 } = this;
    let { pos: o2 } = this;
    if (o2) {
      for (n2[o2++] = 1; o2 < 16; o2++) n2[o2] = 0;
      this.process(n2, 0, true);
    }
    this.finalize();
    let s = 0;
    for (let i2 = 0; i2 < 8; i2++) e[s++] = r2[i2] >>> 0, e[s++] = r2[i2] >>> 8;
    return e;
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
};
function qf(t) {
  const e = (r2, o2) => t(o2).update(mn(r2)).digest(), n2 = t(new Uint8Array(32));
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = (r2) => t(r2), e;
}
var Kf = qf((t) => new Vf(t));
function Ff(t, e, n2, r2, o2, s = 20) {
  let i2 = t[0], f4 = t[1], a = t[2], l3 = t[3], c2 = e[0], u = e[1], h3 = e[2], g = e[3], w = e[4], y3 = e[5], x = e[6], R2 = e[7], M2 = o2, L = n2[0], V3 = n2[1], _ = n2[2], k2 = i2, j = f4, $2 = a, d2 = l3, m2 = c2, p = u, b = h3, v = g, B = w, E2 = y3, I2 = x, S2 = R2, O2 = M2, A3 = L, T = V3, U2 = _;
  for (let H = 0; H < s; H += 2) k2 = k2 + m2 | 0, O2 = D(O2 ^ k2, 16), B = B + O2 | 0, m2 = D(m2 ^ B, 12), k2 = k2 + m2 | 0, O2 = D(O2 ^ k2, 8), B = B + O2 | 0, m2 = D(m2 ^ B, 7), j = j + p | 0, A3 = D(A3 ^ j, 16), E2 = E2 + A3 | 0, p = D(p ^ E2, 12), j = j + p | 0, A3 = D(A3 ^ j, 8), E2 = E2 + A3 | 0, p = D(p ^ E2, 7), $2 = $2 + b | 0, T = D(T ^ $2, 16), I2 = I2 + T | 0, b = D(b ^ I2, 12), $2 = $2 + b | 0, T = D(T ^ $2, 8), I2 = I2 + T | 0, b = D(b ^ I2, 7), d2 = d2 + v | 0, U2 = D(U2 ^ d2, 16), S2 = S2 + U2 | 0, v = D(v ^ S2, 12), d2 = d2 + v | 0, U2 = D(U2 ^ d2, 8), S2 = S2 + U2 | 0, v = D(v ^ S2, 7), k2 = k2 + p | 0, U2 = D(U2 ^ k2, 16), I2 = I2 + U2 | 0, p = D(p ^ I2, 12), k2 = k2 + p | 0, U2 = D(U2 ^ k2, 8), I2 = I2 + U2 | 0, p = D(p ^ I2, 7), j = j + b | 0, O2 = D(O2 ^ j, 16), S2 = S2 + O2 | 0, b = D(b ^ S2, 12), j = j + b | 0, O2 = D(O2 ^ j, 8), S2 = S2 + O2 | 0, b = D(b ^ S2, 7), $2 = $2 + v | 0, A3 = D(A3 ^ $2, 16), B = B + A3 | 0, v = D(v ^ B, 12), $2 = $2 + v | 0, A3 = D(A3 ^ $2, 8), B = B + A3 | 0, v = D(v ^ B, 7), d2 = d2 + m2 | 0, T = D(T ^ d2, 16), E2 = E2 + T | 0, m2 = D(m2 ^ E2, 12), d2 = d2 + m2 | 0, T = D(T ^ d2, 8), E2 = E2 + T | 0, m2 = D(m2 ^ E2, 7);
  let C3 = 0;
  r2[C3++] = i2 + k2 | 0, r2[C3++] = f4 + j | 0, r2[C3++] = a + $2 | 0, r2[C3++] = l3 + d2 | 0, r2[C3++] = c2 + m2 | 0, r2[C3++] = u + p | 0, r2[C3++] = h3 + b | 0, r2[C3++] = g + v | 0, r2[C3++] = w + B | 0, r2[C3++] = y3 + E2 | 0, r2[C3++] = x + I2 | 0, r2[C3++] = R2 + S2 | 0, r2[C3++] = M2 + O2 | 0, r2[C3++] = L + A3 | 0, r2[C3++] = V3 + T | 0, r2[C3++] = _ + U2 | 0;
}
var zf = Mf(Ff, { counterRight: false, counterLength: 4, allowShortKeys: false });
var Gf = new Uint8Array(16);
var io = (t, e) => {
  t.update(e);
  const n2 = e.length % 16;
  n2 && t.update(Gf.subarray(n2));
};
var Zf = new Uint8Array(32);
function fo(t, e, n2, r2, o2) {
  const s = t(e, n2, Zf), i2 = Kf.create(s);
  o2 && io(i2, o2), io(i2, r2);
  const f4 = $f(r2.length, o2 ? o2.length : 0, true);
  i2.update(f4);
  const a = i2.digest();
  return Wt(s, f4), a;
}
var Wf = (t) => (e, n2, r2) => ({ encrypt(s, i2) {
  const f4 = s.length;
  i2 = eo(f4 + 16, i2, false), i2.set(s);
  const a = i2.subarray(0, -16);
  t(e, n2, a, a, 1);
  const l3 = fo(t, e, n2, a, r2);
  return i2.set(l3, f4), Wt(l3), i2;
}, decrypt(s, i2) {
  i2 = eo(s.length - 16, i2, false);
  const f4 = s.subarray(0, -16), a = s.subarray(-16), l3 = fo(t, e, n2, f4, r2);
  if (!Tf(a, l3)) throw new Error("invalid tag");
  return i2.set(s.subarray(0, -16)), t(e, n2, i2, i2, 1), Wt(l3), i2;
} });
var co = Rf({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Wf(zf));
var ao = class extends Ie {
  constructor(e, n2) {
    super(), this.finished = false, this.destroyed = false, rn(e);
    const r2 = ht(n2);
    if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o2 = this.blockLen, s = new Uint8Array(o2);
    s.set(r2.length > o2 ? e.create().update(r2).digest() : r2);
    for (let i2 = 0; i2 < s.length; i2++) s[i2] ^= 54;
    this.iHash.update(s), this.oHash = e.create();
    for (let i2 = 0; i2 < s.length; i2++) s[i2] ^= 106;
    this.oHash.update(s), ut(s);
  }
  update(e) {
    return Nt(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Nt(this), at(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n2, iHash: r2, finished: o2, destroyed: s, blockLen: i2, outputLen: f4 } = this;
    return e = e, e.finished = o2, e.destroyed = s, e.blockLen = i2, e.outputLen = f4, e.oHash = n2._cloneInto(e.oHash), e.iHash = r2._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var _e = (t, e, n2) => new ao(t, e).update(n2).digest();
_e.create = (t, e) => new ao(t, e);
var vn = Uint8Array.from([0]);
var uo = Uint8Array.of();
var En = BigInt(0);
var Bn = BigInt(1);
function Re(t, e) {
  if (typeof e != "boolean") throw new Error(t + " boolean expected, got " + e);
}
function $e(t) {
  const e = t.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function lo(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  return t === "" ? En : BigInt("0x" + t);
}
function Ce(t) {
  return lo(ce(t));
}
function Le(t) {
  return at(t), lo(ce(Uint8Array.from(t).reverse()));
}
function In(t, e) {
  return fn(t.toString(16).padStart(e * 2, "0"));
}
function An(t, e) {
  return In(t, e).reverse();
}
function rt(t, e, n2) {
  let r2;
  if (typeof e == "string") try {
    r2 = fn(e);
  } catch (s) {
    throw new Error(t + " must be hex string or Uint8Array, cause: " + s);
  }
  else if (nn(e)) r2 = Uint8Array.from(e);
  else throw new Error(t + " must be hex string or Uint8Array");
  const o2 = r2.length;
  if (typeof n2 == "number" && o2 !== n2) throw new Error(t + " of length " + n2 + " expected, got " + o2);
  return r2;
}
var Sn = (t) => typeof t == "bigint" && En <= t;
function Qf(t, e, n2) {
  return Sn(t) && Sn(e) && Sn(n2) && e <= t && t < n2;
}
function Nn(t, e, n2, r2) {
  if (!Qf(e, n2, r2)) throw new Error("expected valid " + t + ": " + n2 + " <= n < " + r2 + ", got " + e);
}
function tc(t) {
  let e;
  for (e = 0; t > En; t >>= Bn, e += 1) ;
  return e;
}
var je = (t) => (Bn << BigInt(t)) - Bn;
function ec(t, e, n2) {
  if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
  if (typeof n2 != "function") throw new Error("hmacFn must be a function");
  const r2 = (g) => new Uint8Array(g), o2 = (g) => Uint8Array.of(g);
  let s = r2(t), i2 = r2(t), f4 = 0;
  const a = () => {
    s.fill(1), i2.fill(0), f4 = 0;
  }, l3 = (...g) => n2(i2, s, ...g), c2 = (g = r2(0)) => {
    i2 = l3(o2(0), g), s = l3(), g.length !== 0 && (i2 = l3(o2(1), g), s = l3());
  }, u = () => {
    if (f4++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let g = 0;
    const w = [];
    for (; g < e; ) {
      s = l3();
      const y3 = s.slice();
      w.push(y3), g += s.length;
    }
    return Ht(...w);
  };
  return (g, w) => {
    a(), c2(g);
    let y3;
    for (; !(y3 = w(u())); ) c2();
    return a(), y3;
  };
}
function ke(t, e, n2 = {}) {
  if (!t || typeof t != "object") throw new Error("expected valid options object");
  function r2(o2, s, i2) {
    const f4 = t[o2];
    if (i2 && f4 === void 0) return;
    const a = typeof f4;
    if (a !== s || f4 === null) throw new Error(`param "${o2}" is invalid: expected ${s}, got ${a}`);
  }
  Object.entries(e).forEach(([o2, s]) => r2(o2, s, false)), Object.entries(n2).forEach(([o2, s]) => r2(o2, s, true));
}
function ho(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n2, ...r2) => {
    const o2 = e.get(n2);
    if (o2 !== void 0) return o2;
    const s = t(n2, ...r2);
    return e.set(n2, s), s;
  };
}
var ot = BigInt(0);
var Q = BigInt(1);
var Dt = BigInt(2);
var nc = BigInt(3);
var po = BigInt(4);
var go = BigInt(5);
var bo = BigInt(8);
function lt(t, e) {
  const n2 = t % e;
  return n2 >= ot ? n2 : e + n2;
}
function pt(t, e, n2) {
  let r2 = t;
  for (; e-- > ot; ) r2 *= r2, r2 %= n2;
  return r2;
}
function yo(t, e) {
  if (t === ot) throw new Error("invert: expected non-zero number");
  if (e <= ot) throw new Error("invert: expected positive modulus, got " + e);
  let n2 = lt(t, e), r2 = e, o2 = ot, s = Q;
  for (; n2 !== ot; ) {
    const f4 = r2 / n2, a = r2 % n2, l3 = o2 - s * f4;
    r2 = n2, n2 = a, o2 = s, s = l3;
  }
  if (r2 !== Q) throw new Error("invert: does not exist");
  return lt(o2, e);
}
function mo(t, e) {
  const n2 = (t.ORDER + Q) / po, r2 = t.pow(e, n2);
  if (!t.eql(t.sqr(r2), e)) throw new Error("Cannot find square root");
  return r2;
}
function rc(t, e) {
  const n2 = (t.ORDER - go) / bo, r2 = t.mul(e, Dt), o2 = t.pow(r2, n2), s = t.mul(e, o2), i2 = t.mul(t.mul(s, Dt), o2), f4 = t.mul(s, t.sub(i2, t.ONE));
  if (!t.eql(t.sqr(f4), e)) throw new Error("Cannot find square root");
  return f4;
}
function oc(t) {
  if (t < BigInt(3)) throw new Error("sqrt is not defined for small field");
  let e = t - Q, n2 = 0;
  for (; e % Dt === ot; ) e /= Dt, n2++;
  let r2 = Dt;
  const o2 = Yt(t);
  for (; xo(o2, r2) === 1; ) if (r2++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
  if (n2 === 1) return mo;
  let s = o2.pow(r2, e);
  const i2 = (e + Q) / Dt;
  return function(a, l3) {
    if (a.is0(l3)) return l3;
    if (xo(a, l3) !== 1) throw new Error("Cannot find square root");
    let c2 = n2, u = a.mul(a.ONE, s), h3 = a.pow(l3, e), g = a.pow(l3, i2);
    for (; !a.eql(h3, a.ONE); ) {
      if (a.is0(h3)) return a.ZERO;
      let w = 1, y3 = a.sqr(h3);
      for (; !a.eql(y3, a.ONE); ) if (w++, y3 = a.sqr(y3), w === c2) throw new Error("Cannot find square root");
      const x = Q << BigInt(c2 - w - 1), R2 = a.pow(u, x);
      c2 = w, u = a.sqr(R2), h3 = a.mul(h3, u), g = a.mul(g, R2);
    }
    return g;
  };
}
function sc(t) {
  return t % po === nc ? mo : t % bo === go ? rc : oc(t);
}
var ic = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function fc(t) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }, n2 = ic.reduce((r2, o2) => (r2[o2] = "function", r2), e);
  return ke(t, n2), t;
}
function cc(t, e, n2) {
  if (n2 < ot) throw new Error("invalid exponent, negatives unsupported");
  if (n2 === ot) return t.ONE;
  if (n2 === Q) return e;
  let r2 = t.ONE, o2 = e;
  for (; n2 > ot; ) n2 & Q && (r2 = t.mul(r2, o2)), o2 = t.sqr(o2), n2 >>= Q;
  return r2;
}
function wo(t, e, n2 = false) {
  const r2 = new Array(e.length).fill(n2 ? t.ZERO : void 0), o2 = e.reduce((i2, f4, a) => t.is0(f4) ? i2 : (r2[a] = i2, t.mul(i2, f4)), t.ONE), s = t.inv(o2);
  return e.reduceRight((i2, f4, a) => t.is0(f4) ? i2 : (r2[a] = t.mul(i2, r2[a]), t.mul(i2, f4)), s), r2;
}
function xo(t, e) {
  const n2 = (t.ORDER - Q) / Dt, r2 = t.pow(e, n2), o2 = t.eql(r2, t.ONE), s = t.eql(r2, t.ZERO), i2 = t.eql(r2, t.neg(t.ONE));
  if (!o2 && !s && !i2) throw new Error("invalid Legendre symbol result");
  return o2 ? 1 : s ? 0 : -1;
}
function ac(t, e) {
  e !== void 0 && mt(e);
  const n2 = e !== void 0 ? e : t.toString(2).length, r2 = Math.ceil(n2 / 8);
  return { nBitLength: n2, nByteLength: r2 };
}
function Yt(t, e, n2 = false, r2 = {}) {
  if (t <= ot) throw new Error("invalid field: expected ORDER > 0, got " + t);
  let o2, s;
  if (typeof e == "object" && e != null) {
    if (r2.sqrt || n2) throw new Error("cannot specify opts in two arguments");
    const c2 = e;
    c2.BITS && (o2 = c2.BITS), c2.sqrt && (s = c2.sqrt), typeof c2.isLE == "boolean" && (n2 = c2.isLE);
  } else typeof e == "number" && (o2 = e), r2.sqrt && (s = r2.sqrt);
  const { nBitLength: i2, nByteLength: f4 } = ac(t, o2);
  if (f4 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a;
  const l3 = Object.freeze({ ORDER: t, isLE: n2, BITS: i2, BYTES: f4, MASK: je(i2), ZERO: ot, ONE: Q, create: (c2) => lt(c2, t), isValid: (c2) => {
    if (typeof c2 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c2);
    return ot <= c2 && c2 < t;
  }, is0: (c2) => c2 === ot, isValidNot0: (c2) => !l3.is0(c2) && l3.isValid(c2), isOdd: (c2) => (c2 & Q) === Q, neg: (c2) => lt(-c2, t), eql: (c2, u) => c2 === u, sqr: (c2) => lt(c2 * c2, t), add: (c2, u) => lt(c2 + u, t), sub: (c2, u) => lt(c2 - u, t), mul: (c2, u) => lt(c2 * u, t), pow: (c2, u) => cc(l3, c2, u), div: (c2, u) => lt(c2 * yo(u, t), t), sqrN: (c2) => c2 * c2, addN: (c2, u) => c2 + u, subN: (c2, u) => c2 - u, mulN: (c2, u) => c2 * u, inv: (c2) => yo(c2, t), sqrt: s || ((c2) => (a || (a = sc(t)), a(l3, c2))), toBytes: (c2) => n2 ? An(c2, f4) : In(c2, f4), fromBytes: (c2) => {
    if (c2.length !== f4) throw new Error("Field.fromBytes: expected " + f4 + " bytes, got " + c2.length);
    return n2 ? Le(c2) : Ce(c2);
  }, invertBatch: (c2) => wo(l3, c2), cmov: (c2, u, h3) => h3 ? u : c2 });
  return Object.freeze(l3);
}
function vo(t) {
  if (typeof t != "bigint") throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function Eo(t) {
  const e = vo(t);
  return e + Math.ceil(e / 2);
}
function uc(t, e, n2 = false) {
  const r2 = t.length, o2 = vo(e), s = Eo(e);
  if (r2 < 16 || r2 < s || r2 > 1024) throw new Error("expected " + s + "-1024 bytes of input, got " + r2);
  const i2 = n2 ? Le(t) : Ce(t), f4 = lt(i2, e - Q) + Q;
  return n2 ? An(f4, o2) : In(f4, o2);
}
var Xt = BigInt(0);
var Mt = BigInt(1);
function le(t, e) {
  const n2 = e.negate();
  return t ? n2 : e;
}
function lc(t, e, n2) {
  const r2 = e === "pz" ? (i2) => i2.pz : (i2) => i2.ez, o2 = wo(t.Fp, n2.map(r2));
  return n2.map((i2, f4) => i2.toAffine(o2[f4])).map(t.fromAffine);
}
function Bo(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function On(t, e) {
  Bo(t, e);
  const n2 = Math.ceil(e / t) + 1, r2 = 2 ** (t - 1), o2 = 2 ** t, s = je(t), i2 = BigInt(t);
  return { windows: n2, windowSize: r2, mask: s, maxNumber: o2, shiftBy: i2 };
}
function Io(t, e, n2) {
  const { windowSize: r2, mask: o2, maxNumber: s, shiftBy: i2 } = n2;
  let f4 = Number(t & o2), a = t >> i2;
  f4 > r2 && (f4 -= s, a += Mt);
  const l3 = e * r2, c2 = l3 + Math.abs(f4) - 1, u = f4 === 0, h3 = f4 < 0, g = e % 2 !== 0;
  return { nextN: a, offset: c2, isZero: u, isNeg: h3, isNegF: g, offsetF: l3 };
}
function dc(t, e) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n2, r2) => {
    if (!(n2 instanceof e)) throw new Error("invalid point at index " + r2);
  });
}
function hc(t, e) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n2, r2) => {
    if (!e.isValid(n2)) throw new Error("invalid scalar at index " + r2);
  });
}
var Un = /* @__PURE__ */ new WeakMap();
var Ao = /* @__PURE__ */ new WeakMap();
function _n(t) {
  return Ao.get(t) || 1;
}
function So(t) {
  if (t !== Xt) throw new Error("invalid wNAF");
}
function pc(t, e) {
  return { constTimeNegate: le, hasPrecomputes(n2) {
    return _n(n2) !== 1;
  }, unsafeLadder(n2, r2, o2 = t.ZERO) {
    let s = n2;
    for (; r2 > Xt; ) r2 & Mt && (o2 = o2.add(s)), s = s.double(), r2 >>= Mt;
    return o2;
  }, precomputeWindow(n2, r2) {
    const { windows: o2, windowSize: s } = On(r2, e), i2 = [];
    let f4 = n2, a = f4;
    for (let l3 = 0; l3 < o2; l3++) {
      a = f4, i2.push(a);
      for (let c2 = 1; c2 < s; c2++) a = a.add(f4), i2.push(a);
      f4 = a.double();
    }
    return i2;
  }, wNAF(n2, r2, o2) {
    let s = t.ZERO, i2 = t.BASE;
    const f4 = On(n2, e);
    for (let a = 0; a < f4.windows; a++) {
      const { nextN: l3, offset: c2, isZero: u, isNeg: h3, isNegF: g, offsetF: w } = Io(o2, a, f4);
      o2 = l3, u ? i2 = i2.add(le(g, r2[w])) : s = s.add(le(h3, r2[c2]));
    }
    return So(o2), { p: s, f: i2 };
  }, wNAFUnsafe(n2, r2, o2, s = t.ZERO) {
    const i2 = On(n2, e);
    for (let f4 = 0; f4 < i2.windows && o2 !== Xt; f4++) {
      const { nextN: a, offset: l3, isZero: c2, isNeg: u } = Io(o2, f4, i2);
      if (o2 = a, !c2) {
        const h3 = r2[l3];
        s = s.add(u ? h3.negate() : h3);
      }
    }
    return So(o2), s;
  }, getPrecomputes(n2, r2, o2) {
    let s = Un.get(r2);
    return s || (s = this.precomputeWindow(r2, n2), n2 !== 1 && (typeof o2 == "function" && (s = o2(s)), Un.set(r2, s))), s;
  }, wNAFCached(n2, r2, o2) {
    const s = _n(n2);
    return this.wNAF(s, this.getPrecomputes(s, n2, o2), r2);
  }, wNAFCachedUnsafe(n2, r2, o2, s) {
    const i2 = _n(n2);
    return i2 === 1 ? this.unsafeLadder(n2, r2, s) : this.wNAFUnsafe(i2, this.getPrecomputes(i2, n2, o2), r2, s);
  }, setWindowSize(n2, r2) {
    Bo(r2, e), Ao.set(n2, r2), Un.delete(n2);
  } };
}
function gc(t, e, n2, r2) {
  let o2 = e, s = t.ZERO, i2 = t.ZERO;
  for (; n2 > Xt || r2 > Xt; ) n2 & Mt && (s = s.add(o2)), r2 & Mt && (i2 = i2.add(o2)), o2 = o2.double(), n2 >>= Mt, r2 >>= Mt;
  return { p1: s, p2: i2 };
}
function bc(t, e, n2, r2) {
  dc(n2, t), hc(r2, e);
  const o2 = n2.length, s = r2.length;
  if (o2 !== s) throw new Error("arrays of points and scalars must have equal length");
  const i2 = t.ZERO, f4 = tc(BigInt(o2));
  let a = 1;
  f4 > 12 ? a = f4 - 3 : f4 > 4 ? a = f4 - 2 : f4 > 0 && (a = 2);
  const l3 = je(a), c2 = new Array(Number(l3) + 1).fill(i2), u = Math.floor((e.BITS - 1) / a) * a;
  let h3 = i2;
  for (let g = u; g >= 0; g -= a) {
    c2.fill(i2);
    for (let y3 = 0; y3 < s; y3++) {
      const x = r2[y3], R2 = Number(x >> BigInt(g) & l3);
      c2[R2] = c2[R2].add(n2[y3]);
    }
    let w = i2;
    for (let y3 = c2.length - 1, x = i2; y3 > 0; y3--) x = x.add(c2[y3]), w = w.add(x);
    if (h3 = h3.add(w), g !== 0) for (let y3 = 0; y3 < a; y3++) h3 = h3.double();
  }
  return h3;
}
function No(t, e) {
  if (e) {
    if (e.ORDER !== t) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return fc(e), e;
  } else return Yt(t);
}
function yc(t, e, n2 = {}) {
  if (!e || typeof e != "object") throw new Error(`expected valid ${t} CURVE object`);
  for (const f4 of ["p", "n", "h"]) {
    const a = e[f4];
    if (!(typeof a == "bigint" && a > Xt)) throw new Error(`CURVE.${f4} must be positive bigint`);
  }
  const r2 = No(e.p, n2.Fp), o2 = No(e.n, n2.Fn), i2 = ["Gx", "Gy", "a", t === "weierstrass" ? "b" : "d"];
  for (const f4 of i2) if (!r2.isValid(e[f4])) throw new Error(`CURVE.${f4} must be valid field element of CURVE.Fp`);
  return { Fp: r2, Fn: o2 };
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var de = BigInt(0);
var Jt = BigInt(1);
var Pe = BigInt(2);
function mc(t) {
  return ke(t, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...t });
}
function wc(t) {
  const e = mc(t), { P: n2, type: r2, adjustScalarBytes: o2, powPminus2: s, randomBytes: i2 } = e, f4 = r2 === "x25519";
  if (!f4 && r2 !== "x448") throw new Error("invalid type");
  const a = i2 || Zt, l3 = f4 ? 255 : 448, c2 = f4 ? 32 : 56, u = BigInt(f4 ? 9 : 5), h3 = BigInt(f4 ? 121665 : 39081), g = f4 ? Pe ** BigInt(254) : Pe ** BigInt(447), w = f4 ? BigInt(8) * Pe ** BigInt(251) - Jt : BigInt(4) * Pe ** BigInt(445) - Jt, y3 = g + w + Jt, x = (d2) => lt(d2, n2), R2 = M2(u);
  function M2(d2) {
    return An(x(d2), c2);
  }
  function L(d2) {
    const m2 = rt("u coordinate", d2, c2);
    return f4 && (m2[31] &= 127), x(Le(m2));
  }
  function V3(d2) {
    return Le(o2(rt("scalar", d2, c2)));
  }
  function _(d2, m2) {
    const p = $2(L(m2), V3(d2));
    if (p === de) throw new Error("invalid private or public key received");
    return M2(p);
  }
  function k2(d2) {
    return _(d2, R2);
  }
  function j(d2, m2, p) {
    const b = x(d2 * (m2 - p));
    return m2 = x(m2 - b), p = x(p + b), { x_2: m2, x_3: p };
  }
  function $2(d2, m2) {
    Nn("u", d2, de, n2), Nn("scalar", m2, g, y3);
    const p = m2, b = d2;
    let v = Jt, B = de, E2 = d2, I2 = Jt, S2 = de;
    for (let A3 = BigInt(l3 - 1); A3 >= de; A3--) {
      const T = p >> A3 & Jt;
      S2 ^= T, { x_2: v, x_3: E2 } = j(S2, v, E2), { x_2: B, x_3: I2 } = j(S2, B, I2), S2 = T;
      const U2 = v + B, C3 = x(U2 * U2), H = v - B, q2 = x(H * H), P2 = C3 - q2, K2 = E2 + I2, et = E2 - I2, Z = x(et * U2), z = x(K2 * H), Ft = Z + z, yt = Z - z;
      E2 = x(Ft * Ft), I2 = x(b * x(yt * yt)), v = x(C3 * q2), B = x(P2 * (C3 + x(h3 * P2)));
    }
    ({ x_2: v, x_3: E2 } = j(S2, v, E2)), { x_2: B, x_3: I2 } = j(S2, B, I2);
    const O2 = s(B);
    return x(v * O2);
  }
  return { scalarMult: _, scalarMultBase: k2, getSharedSecret: (d2, m2) => _(d2, m2), getPublicKey: (d2) => k2(d2), utils: { randomPrivateKey: () => a(c2) }, GuBytes: R2.slice() };
}
BigInt(0);
var xc = BigInt(1);
var Oo = BigInt(2);
var vc = BigInt(3);
var Ec = BigInt(5);
var Bc = BigInt(8);
var Uo = { p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"), n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"), h: Bc, a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"), d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"), Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"), Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658") };
function Ic(t) {
  const e = BigInt(10), n2 = BigInt(20), r2 = BigInt(40), o2 = BigInt(80), s = Uo.p, f4 = t * t % s * t % s, a = pt(f4, Oo, s) * f4 % s, l3 = pt(a, xc, s) * t % s, c2 = pt(l3, Ec, s) * l3 % s, u = pt(c2, e, s) * c2 % s, h3 = pt(u, n2, s) * u % s, g = pt(h3, r2, s) * h3 % s, w = pt(g, o2, s) * g % s, y3 = pt(w, o2, s) * g % s, x = pt(y3, e, s) * c2 % s;
  return { pow_p_5_8: pt(x, Oo, s) * t % s, b2: f4 };
}
function Ac(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
var Tn = (() => {
  const t = Uo.p;
  return wc({ P: t, type: "x25519", powPminus2: (e) => {
    const { pow_p_5_8: n2, b2: r2 } = Ic(e);
    return lt(pt(n2, vc, t) * r2, t);
  }, adjustScalarBytes: Ac });
})();
function _o(t) {
  t.lowS !== void 0 && Re("lowS", t.lowS), t.prehash !== void 0 && Re("prehash", t.prehash);
}
var Sc = class extends Error {
  constructor(e = "") {
    super(e);
  }
};
var vt = { Err: Sc, _tlv: { encode: (t, e) => {
  const { Err: n2 } = vt;
  if (t < 0 || t > 256) throw new n2("tlv.encode: wrong tag");
  if (e.length & 1) throw new n2("tlv.encode: unpadded data");
  const r2 = e.length / 2, o2 = $e(r2);
  if (o2.length / 2 & 128) throw new n2("tlv.encode: long form length too big");
  const s = r2 > 127 ? $e(o2.length / 2 | 128) : "";
  return $e(t) + s + o2 + e;
}, decode(t, e) {
  const { Err: n2 } = vt;
  let r2 = 0;
  if (t < 0 || t > 256) throw new n2("tlv.encode: wrong tag");
  if (e.length < 2 || e[r2++] !== t) throw new n2("tlv.decode: wrong tlv");
  const o2 = e[r2++], s = !!(o2 & 128);
  let i2 = 0;
  if (!s) i2 = o2;
  else {
    const a = o2 & 127;
    if (!a) throw new n2("tlv.decode(long): indefinite length not supported");
    if (a > 4) throw new n2("tlv.decode(long): byte length is too big");
    const l3 = e.subarray(r2, r2 + a);
    if (l3.length !== a) throw new n2("tlv.decode: length bytes not complete");
    if (l3[0] === 0) throw new n2("tlv.decode(long): zero leftmost byte");
    for (const c2 of l3) i2 = i2 << 8 | c2;
    if (r2 += a, i2 < 128) throw new n2("tlv.decode(long): not minimal encoding");
  }
  const f4 = e.subarray(r2, r2 + i2);
  if (f4.length !== i2) throw new n2("tlv.decode: wrong value length");
  return { v: f4, l: e.subarray(r2 + i2) };
} }, _int: { encode(t) {
  const { Err: e } = vt;
  if (t < he) throw new e("integer: negative integers are not allowed");
  let n2 = $e(t);
  if (Number.parseInt(n2[0], 16) & 8 && (n2 = "00" + n2), n2.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
  return n2;
}, decode(t) {
  const { Err: e } = vt;
  if (t[0] & 128) throw new e("invalid signature integer: negative");
  if (t[0] === 0 && !(t[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
  return Ce(t);
} }, toSig(t) {
  const { Err: e, _int: n2, _tlv: r2 } = vt, o2 = rt("signature", t), { v: s, l: i2 } = r2.decode(48, o2);
  if (i2.length) throw new e("invalid signature: left bytes after parsing");
  const { v: f4, l: a } = r2.decode(2, s), { v: l3, l: c2 } = r2.decode(2, a);
  if (c2.length) throw new e("invalid signature: left bytes after parsing");
  return { r: n2.decode(f4), s: n2.decode(l3) };
}, hexFromSig(t) {
  const { _tlv: e, _int: n2 } = vt, r2 = e.encode(2, n2.encode(t.r)), o2 = e.encode(2, n2.encode(t.s)), s = r2 + o2;
  return e.encode(48, s);
} };
var he = BigInt(0);
var pe = BigInt(1);
var Nc = BigInt(2);
var He = BigInt(3);
var Oc = BigInt(4);
function Uc(t, e, n2) {
  function r2(o2) {
    const s = t.sqr(o2), i2 = t.mul(s, o2);
    return t.add(t.add(i2, t.mul(o2, e)), n2);
  }
  return r2;
}
function To(t, e, n2) {
  const { BYTES: r2 } = t;
  function o2(s) {
    let i2;
    if (typeof s == "bigint") i2 = s;
    else {
      let f4 = rt("private key", s);
      if (e) {
        if (!e.includes(f4.length * 2)) throw new Error("invalid private key");
        const a = new Uint8Array(r2);
        a.set(f4, a.length - f4.length), f4 = a;
      }
      try {
        i2 = t.fromBytes(f4);
      } catch {
        throw new Error(`invalid private key: expected ui8a of size ${r2}, got ${typeof s}`);
      }
    }
    if (n2 && (i2 = t.create(i2)), !t.isValidNot0(i2)) throw new Error("invalid private key: out of range [1..N-1]");
    return i2;
  }
  return o2;
}
function _c(t, e = {}) {
  const { Fp: n2, Fn: r2 } = yc("weierstrass", t, e), { h: o2, n: s } = t;
  ke(e, {}, { allowInfinityPoint: "boolean", clearCofactor: "function", isTorsionFree: "function", fromBytes: "function", toBytes: "function", endo: "object", wrapPrivateKey: "boolean" });
  const { endo: i2 } = e;
  if (i2 && (!n2.is0(t.a) || typeof i2.beta != "bigint" || typeof i2.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
  function f4() {
    if (!n2.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function a($2, d2, m2) {
    const { x: p, y: b } = d2.toAffine(), v = n2.toBytes(p);
    if (Re("isCompressed", m2), m2) {
      f4();
      const B = !n2.isOdd(b);
      return Ht(Ro(B), v);
    } else return Ht(Uint8Array.of(4), v, n2.toBytes(b));
  }
  function l3($2) {
    at($2);
    const d2 = n2.BYTES, m2 = d2 + 1, p = 2 * d2 + 1, b = $2.length, v = $2[0], B = $2.subarray(1);
    if (b === m2 && (v === 2 || v === 3)) {
      const E2 = n2.fromBytes(B);
      if (!n2.isValid(E2)) throw new Error("bad point: is not on curve, wrong x");
      const I2 = h3(E2);
      let S2;
      try {
        S2 = n2.sqrt(I2);
      } catch (T) {
        const U2 = T instanceof Error ? ": " + T.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + U2);
      }
      f4();
      const O2 = n2.isOdd(S2);
      return (v & 1) === 1 !== O2 && (S2 = n2.neg(S2)), { x: E2, y: S2 };
    } else if (b === p && v === 4) {
      const E2 = n2.fromBytes(B.subarray(d2 * 0, d2 * 1)), I2 = n2.fromBytes(B.subarray(d2 * 1, d2 * 2));
      if (!g(E2, I2)) throw new Error("bad point: is not on curve");
      return { x: E2, y: I2 };
    } else throw new Error(`bad point: got length ${b}, expected compressed=${m2} or uncompressed=${p}`);
  }
  const c2 = e.toBytes || a, u = e.fromBytes || l3, h3 = Uc(n2, t.a, t.b);
  function g($2, d2) {
    const m2 = n2.sqr(d2), p = h3($2);
    return n2.eql(m2, p);
  }
  if (!g(t.Gx, t.Gy)) throw new Error("bad curve params: generator point");
  const w = n2.mul(n2.pow(t.a, He), Oc), y3 = n2.mul(n2.sqr(t.b), BigInt(27));
  if (n2.is0(n2.add(w, y3))) throw new Error("bad curve params: a or b");
  function x($2, d2, m2 = false) {
    if (!n2.isValid(d2) || m2 && n2.is0(d2)) throw new Error(`bad point coordinate ${$2}`);
    return d2;
  }
  function R2($2) {
    if (!($2 instanceof _)) throw new Error("ProjectivePoint expected");
  }
  const M2 = ho(($2, d2) => {
    const { px: m2, py: p, pz: b } = $2;
    if (n2.eql(b, n2.ONE)) return { x: m2, y: p };
    const v = $2.is0();
    d2 == null && (d2 = v ? n2.ONE : n2.inv(b));
    const B = n2.mul(m2, d2), E2 = n2.mul(p, d2), I2 = n2.mul(b, d2);
    if (v) return { x: n2.ZERO, y: n2.ZERO };
    if (!n2.eql(I2, n2.ONE)) throw new Error("invZ was invalid");
    return { x: B, y: E2 };
  }), L = ho(($2) => {
    if ($2.is0()) {
      if (e.allowInfinityPoint && !n2.is0($2.py)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: d2, y: m2 } = $2.toAffine();
    if (!n2.isValid(d2) || !n2.isValid(m2)) throw new Error("bad point: x or y not field elements");
    if (!g(d2, m2)) throw new Error("bad point: equation left != right");
    if (!$2.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function V3($2, d2, m2, p, b) {
    return m2 = new _(n2.mul(m2.px, $2), m2.py, m2.pz), d2 = le(p, d2), m2 = le(b, m2), d2.add(m2);
  }
  class _ {
    constructor(d2, m2, p) {
      this.px = x("x", d2), this.py = x("y", m2, true), this.pz = x("z", p), Object.freeze(this);
    }
    static fromAffine(d2) {
      const { x: m2, y: p } = d2 || {};
      if (!d2 || !n2.isValid(m2) || !n2.isValid(p)) throw new Error("invalid affine point");
      if (d2 instanceof _) throw new Error("projective point not allowed");
      return n2.is0(m2) && n2.is0(p) ? _.ZERO : new _(m2, p, n2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(d2) {
      return lc(_, "pz", d2);
    }
    static fromBytes(d2) {
      return at(d2), _.fromHex(d2);
    }
    static fromHex(d2) {
      const m2 = _.fromAffine(u(rt("pointHex", d2)));
      return m2.assertValidity(), m2;
    }
    static fromPrivateKey(d2) {
      const m2 = To(r2, e.allowedPrivateKeyLengths, e.wrapPrivateKey);
      return _.BASE.multiply(m2(d2));
    }
    static msm(d2, m2) {
      return bc(_, r2, d2, m2);
    }
    precompute(d2 = 8, m2 = true) {
      return j.setWindowSize(this, d2), m2 || this.multiply(He), this;
    }
    _setWindowSize(d2) {
      this.precompute(d2);
    }
    assertValidity() {
      L(this);
    }
    hasEvenY() {
      const { y: d2 } = this.toAffine();
      if (!n2.isOdd) throw new Error("Field doesn't support isOdd");
      return !n2.isOdd(d2);
    }
    equals(d2) {
      R2(d2);
      const { px: m2, py: p, pz: b } = this, { px: v, py: B, pz: E2 } = d2, I2 = n2.eql(n2.mul(m2, E2), n2.mul(v, b)), S2 = n2.eql(n2.mul(p, E2), n2.mul(B, b));
      return I2 && S2;
    }
    negate() {
      return new _(this.px, n2.neg(this.py), this.pz);
    }
    double() {
      const { a: d2, b: m2 } = t, p = n2.mul(m2, He), { px: b, py: v, pz: B } = this;
      let E2 = n2.ZERO, I2 = n2.ZERO, S2 = n2.ZERO, O2 = n2.mul(b, b), A3 = n2.mul(v, v), T = n2.mul(B, B), U2 = n2.mul(b, v);
      return U2 = n2.add(U2, U2), S2 = n2.mul(b, B), S2 = n2.add(S2, S2), E2 = n2.mul(d2, S2), I2 = n2.mul(p, T), I2 = n2.add(E2, I2), E2 = n2.sub(A3, I2), I2 = n2.add(A3, I2), I2 = n2.mul(E2, I2), E2 = n2.mul(U2, E2), S2 = n2.mul(p, S2), T = n2.mul(d2, T), U2 = n2.sub(O2, T), U2 = n2.mul(d2, U2), U2 = n2.add(U2, S2), S2 = n2.add(O2, O2), O2 = n2.add(S2, O2), O2 = n2.add(O2, T), O2 = n2.mul(O2, U2), I2 = n2.add(I2, O2), T = n2.mul(v, B), T = n2.add(T, T), O2 = n2.mul(T, U2), E2 = n2.sub(E2, O2), S2 = n2.mul(T, A3), S2 = n2.add(S2, S2), S2 = n2.add(S2, S2), new _(E2, I2, S2);
    }
    add(d2) {
      R2(d2);
      const { px: m2, py: p, pz: b } = this, { px: v, py: B, pz: E2 } = d2;
      let I2 = n2.ZERO, S2 = n2.ZERO, O2 = n2.ZERO;
      const A3 = t.a, T = n2.mul(t.b, He);
      let U2 = n2.mul(m2, v), C3 = n2.mul(p, B), H = n2.mul(b, E2), q2 = n2.add(m2, p), P2 = n2.add(v, B);
      q2 = n2.mul(q2, P2), P2 = n2.add(U2, C3), q2 = n2.sub(q2, P2), P2 = n2.add(m2, b);
      let K2 = n2.add(v, E2);
      return P2 = n2.mul(P2, K2), K2 = n2.add(U2, H), P2 = n2.sub(P2, K2), K2 = n2.add(p, b), I2 = n2.add(B, E2), K2 = n2.mul(K2, I2), I2 = n2.add(C3, H), K2 = n2.sub(K2, I2), O2 = n2.mul(A3, P2), I2 = n2.mul(T, H), O2 = n2.add(I2, O2), I2 = n2.sub(C3, O2), O2 = n2.add(C3, O2), S2 = n2.mul(I2, O2), C3 = n2.add(U2, U2), C3 = n2.add(C3, U2), H = n2.mul(A3, H), P2 = n2.mul(T, P2), C3 = n2.add(C3, H), H = n2.sub(U2, H), H = n2.mul(A3, H), P2 = n2.add(P2, H), U2 = n2.mul(C3, P2), S2 = n2.add(S2, U2), U2 = n2.mul(K2, P2), I2 = n2.mul(q2, I2), I2 = n2.sub(I2, U2), U2 = n2.mul(q2, C3), O2 = n2.mul(K2, O2), O2 = n2.add(O2, U2), new _(I2, S2, O2);
    }
    subtract(d2) {
      return this.add(d2.negate());
    }
    is0() {
      return this.equals(_.ZERO);
    }
    multiply(d2) {
      const { endo: m2 } = e;
      if (!r2.isValidNot0(d2)) throw new Error("invalid scalar: out of range");
      let p, b;
      const v = (B) => j.wNAFCached(this, B, _.normalizeZ);
      if (m2) {
        const { k1neg: B, k1: E2, k2neg: I2, k2: S2 } = m2.splitScalar(d2), { p: O2, f: A3 } = v(E2), { p: T, f: U2 } = v(S2);
        b = A3.add(U2), p = V3(m2.beta, O2, T, B, I2);
      } else {
        const { p: B, f: E2 } = v(d2);
        p = B, b = E2;
      }
      return _.normalizeZ([p, b])[0];
    }
    multiplyUnsafe(d2) {
      const { endo: m2 } = e, p = this;
      if (!r2.isValid(d2)) throw new Error("invalid scalar: out of range");
      if (d2 === he || p.is0()) return _.ZERO;
      if (d2 === pe) return p;
      if (j.hasPrecomputes(this)) return this.multiply(d2);
      if (m2) {
        const { k1neg: b, k1: v, k2neg: B, k2: E2 } = m2.splitScalar(d2), { p1: I2, p2: S2 } = gc(_, p, v, E2);
        return V3(m2.beta, I2, S2, b, B);
      } else return j.wNAFCachedUnsafe(p, d2);
    }
    multiplyAndAddUnsafe(d2, m2, p) {
      const b = this.multiplyUnsafe(m2).add(d2.multiplyUnsafe(p));
      return b.is0() ? void 0 : b;
    }
    toAffine(d2) {
      return M2(this, d2);
    }
    isTorsionFree() {
      const { isTorsionFree: d2 } = e;
      return o2 === pe ? true : d2 ? d2(_, this) : j.wNAFCachedUnsafe(this, s).is0();
    }
    clearCofactor() {
      const { clearCofactor: d2 } = e;
      return o2 === pe ? this : d2 ? d2(_, this) : this.multiplyUnsafe(o2);
    }
    toBytes(d2 = true) {
      return Re("isCompressed", d2), this.assertValidity(), c2(_, this, d2);
    }
    toRawBytes(d2 = true) {
      return this.toBytes(d2);
    }
    toHex(d2 = true) {
      return ce(this.toBytes(d2));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  _.BASE = new _(t.Gx, t.Gy, n2.ONE), _.ZERO = new _(n2.ZERO, n2.ONE, n2.ZERO), _.Fp = n2, _.Fn = r2;
  const k2 = r2.BITS, j = pc(_, e.endo ? Math.ceil(k2 / 2) : k2);
  return _;
}
function Ro(t) {
  return Uint8Array.of(t ? 2 : 3);
}
function Tc(t, e, n2 = {}) {
  ke(e, { hash: "function" }, { hmac: "function", lowS: "boolean", randomBytes: "function", bits2int: "function", bits2int_modN: "function" });
  const r2 = e.randomBytes || Zt, o2 = e.hmac || ((p, ...b) => _e(e.hash, p, Ht(...b))), { Fp: s, Fn: i2 } = t, { ORDER: f4, BITS: a } = i2;
  function l3(p) {
    const b = f4 >> pe;
    return p > b;
  }
  function c2(p) {
    return l3(p) ? i2.neg(p) : p;
  }
  function u(p, b) {
    if (!i2.isValidNot0(b)) throw new Error(`invalid signature ${p}: out of range 1..CURVE.n`);
  }
  class h3 {
    constructor(b, v, B) {
      u("r", b), u("s", v), this.r = b, this.s = v, B != null && (this.recovery = B), Object.freeze(this);
    }
    static fromCompact(b) {
      const v = i2.BYTES, B = rt("compactSignature", b, v * 2);
      return new h3(i2.fromBytes(B.subarray(0, v)), i2.fromBytes(B.subarray(v, v * 2)));
    }
    static fromDER(b) {
      const { r: v, s: B } = vt.toSig(rt("DER", b));
      return new h3(v, B);
    }
    assertValidity() {
    }
    addRecoveryBit(b) {
      return new h3(this.r, this.s, b);
    }
    recoverPublicKey(b) {
      const v = s.ORDER, { r: B, s: E2, recovery: I2 } = this;
      if (I2 == null || ![0, 1, 2, 3].includes(I2)) throw new Error("recovery id invalid");
      if (f4 * Nc < v && I2 > 1) throw new Error("recovery id is ambiguous for h>1 curve");
      const O2 = I2 === 2 || I2 === 3 ? B + f4 : B;
      if (!s.isValid(O2)) throw new Error("recovery id 2 or 3 invalid");
      const A3 = s.toBytes(O2), T = t.fromHex(Ht(Ro((I2 & 1) === 0), A3)), U2 = i2.inv(O2), C3 = L(rt("msgHash", b)), H = i2.create(-C3 * U2), q2 = i2.create(E2 * U2), P2 = t.BASE.multiplyUnsafe(H).add(T.multiplyUnsafe(q2));
      if (P2.is0()) throw new Error("point at infinify");
      return P2.assertValidity(), P2;
    }
    hasHighS() {
      return l3(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new h3(this.r, i2.neg(this.s), this.recovery) : this;
    }
    toBytes(b) {
      if (b === "compact") return Ht(i2.toBytes(this.r), i2.toBytes(this.s));
      if (b === "der") return fn(vt.hexFromSig(this));
      throw new Error("invalid format");
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return ce(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return ce(this.toBytes("compact"));
    }
  }
  const g = To(i2, n2.allowedPrivateKeyLengths, n2.wrapPrivateKey), w = { isValidPrivateKey(p) {
    try {
      return g(p), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: g, randomPrivateKey: () => {
    const p = f4;
    return uc(r2(Eo(p)), p);
  }, precompute(p = 8, b = t.BASE) {
    return b.precompute(p, false);
  } };
  function y3(p, b = true) {
    return t.fromPrivateKey(p).toBytes(b);
  }
  function x(p) {
    if (typeof p == "bigint") return false;
    if (p instanceof t) return true;
    const v = rt("key", p).length, B = s.BYTES, E2 = B + 1, I2 = 2 * B + 1;
    if (!(n2.allowedPrivateKeyLengths || i2.BYTES === E2)) return v === E2 || v === I2;
  }
  function R2(p, b, v = true) {
    if (x(p) === true) throw new Error("first arg must be private key");
    if (x(b) === false) throw new Error("second arg must be public key");
    return t.fromHex(b).multiply(g(p)).toBytes(v);
  }
  const M2 = e.bits2int || function(p) {
    if (p.length > 8192) throw new Error("input is too large");
    const b = Ce(p), v = p.length * 8 - a;
    return v > 0 ? b >> BigInt(v) : b;
  }, L = e.bits2int_modN || function(p) {
    return i2.create(M2(p));
  }, V3 = je(a);
  function _(p) {
    return Nn("num < 2^" + a, p, he, V3), i2.toBytes(p);
  }
  function k2(p, b, v = j) {
    if (["recovered", "canonical"].some((q2) => q2 in v)) throw new Error("sign() legacy options not supported");
    const { hash: B } = e;
    let { lowS: E2, prehash: I2, extraEntropy: S2 } = v;
    E2 == null && (E2 = true), p = rt("msgHash", p), _o(v), I2 && (p = rt("prehashed msgHash", B(p)));
    const O2 = L(p), A3 = g(b), T = [_(A3), _(O2)];
    if (S2 != null && S2 !== false) {
      const q2 = S2 === true ? r2(s.BYTES) : S2;
      T.push(rt("extraEntropy", q2));
    }
    const U2 = Ht(...T), C3 = O2;
    function H(q2) {
      const P2 = M2(q2);
      if (!i2.isValidNot0(P2)) return;
      const K2 = i2.inv(P2), et = t.BASE.multiply(P2).toAffine(), Z = i2.create(et.x);
      if (Z === he) return;
      const z = i2.create(K2 * i2.create(C3 + Z * A3));
      if (z === he) return;
      let Ft = (et.x === Z ? 0 : 2) | Number(et.y & pe), yt = z;
      return E2 && l3(z) && (yt = c2(z), Ft ^= 1), new h3(Z, yt, Ft);
    }
    return { seed: U2, k2sig: H };
  }
  const j = { lowS: e.lowS, prehash: false }, $2 = { lowS: e.lowS, prehash: false };
  function d2(p, b, v = j) {
    const { seed: B, k2sig: E2 } = k2(p, b, v);
    return ec(e.hash.outputLen, i2.BYTES, o2)(B, E2);
  }
  t.BASE.precompute(8);
  function m2(p, b, v, B = $2) {
    const E2 = p;
    b = rt("msgHash", b), v = rt("publicKey", v), _o(B);
    const { lowS: I2, prehash: S2, format: O2 } = B;
    if ("strict" in B) throw new Error("options.strict was renamed to lowS");
    if (O2 !== void 0 && !["compact", "der", "js"].includes(O2)) throw new Error('format must be "compact", "der" or "js"');
    const A3 = typeof E2 == "string" || nn(E2), T = !A3 && !O2 && typeof E2 == "object" && E2 !== null && typeof E2.r == "bigint" && typeof E2.s == "bigint";
    if (!A3 && !T) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let U2, C3;
    try {
      if (T) if (O2 === void 0 || O2 === "js") U2 = new h3(E2.r, E2.s);
      else throw new Error("invalid format");
      if (A3) {
        try {
          O2 !== "compact" && (U2 = h3.fromDER(E2));
        } catch (yt) {
          if (!(yt instanceof vt.Err)) throw yt;
        }
        !U2 && O2 !== "der" && (U2 = h3.fromCompact(E2));
      }
      C3 = t.fromHex(v);
    } catch {
      return false;
    }
    if (!U2 || I2 && U2.hasHighS()) return false;
    S2 && (b = e.hash(b));
    const { r: H, s: q2 } = U2, P2 = L(b), K2 = i2.inv(q2), et = i2.create(P2 * K2), Z = i2.create(H * K2), z = t.BASE.multiplyUnsafe(et).add(C3.multiplyUnsafe(Z));
    return z.is0() ? false : i2.create(z.x) === H;
  }
  return Object.freeze({ getPublicKey: y3, getSharedSecret: R2, sign: d2, verify: m2, utils: w, Point: t, Signature: h3 });
}
function Rc(t) {
  const e = { a: t.a, b: t.b, p: t.Fp.ORDER, n: t.n, h: t.h, Gx: t.Gx, Gy: t.Gy }, n2 = t.Fp, r2 = Yt(e.n, t.nBitLength), o2 = { Fp: n2, Fn: r2, allowedPrivateKeyLengths: t.allowedPrivateKeyLengths, allowInfinityPoint: t.allowInfinityPoint, endo: t.endo, wrapPrivateKey: t.wrapPrivateKey, isTorsionFree: t.isTorsionFree, clearCofactor: t.clearCofactor, fromBytes: t.fromBytes, toBytes: t.toBytes };
  return { CURVE: e, curveOpts: o2 };
}
function $c(t) {
  const { CURVE: e, curveOpts: n2 } = Rc(t), r2 = { hash: t.hash, hmac: t.hmac, randomBytes: t.randomBytes, lowS: t.lowS, bits2int: t.bits2int, bits2int_modN: t.bits2int_modN };
  return { CURVE: e, curveOpts: n2, ecdsaOpts: r2 };
}
function Cc(t, e) {
  return Object.assign({}, e, { ProjectivePoint: e.Point, CURVE: t });
}
function Lc(t) {
  const { CURVE: e, curveOpts: n2, ecdsaOpts: r2 } = $c(t), o2 = _c(e, n2), s = Tc(o2, r2, n2);
  return Cc(t, s);
}
function Rn(t, e) {
  const n2 = (r2) => Lc({ ...t, hash: r2 });
  return { ...n2(e), create: n2 };
}
var $o = { p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"), n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), h: BigInt(1), a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"), b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5") };
var Co = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"), n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"), h: BigInt(1), a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"), b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"), Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"), Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f") };
var Lo = { p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"), h: BigInt(1), a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"), b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"), Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"), Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650") };
var jc = Yt($o.p);
var kc = Yt(Co.p);
var Pc = Yt(Lo.p);
var Hc = Rn({ ...$o, Fp: jc, lowS: false }, Ae);
Rn({ ...Co, Fp: kc, lowS: false }, Yi), Rn({ ...Lo, Fp: Pc, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, Wi);

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/core/dist/index.es.js
var import_window_getters2 = __toESM(require_cjs2());
var Ue2 = "wc";
var pe2 = "core";
var W2 = `${Ue2}@2:${pe2}:`;
var Qs = import_time2.FIVE_SECONDS * 1e3;
var Jt2 = "https://verify.walletconnect.org";
var be = Jt2;
var Xt2 = `${be}/v3`;
function cr2(r2, e) {
  if (r2.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i2 = 0; i2 < t.length; i2++) t[i2] = 255;
  for (var s = 0; s < r2.length; s++) {
    var n2 = r2.charAt(s), o2 = n2.charCodeAt(0);
    if (t[o2] !== 255) throw new TypeError(n2 + " is ambiguous");
    t[o2] = s;
  }
  var a = r2.length, c2 = r2.charAt(0), h3 = Math.log(a) / Math.log(256), l3 = Math.log(256) / Math.log(a);
  function p(u) {
    if (u instanceof Uint8Array || (ArrayBuffer.isView(u) ? u = new Uint8Array(u.buffer, u.byteOffset, u.byteLength) : Array.isArray(u) && (u = Uint8Array.from(u))), !(u instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u.length === 0) return "";
    for (var m2 = 0, D2 = 0, _ = 0, E2 = u.length; _ !== E2 && u[_] === 0; ) _++, m2++;
    for (var L = (E2 - _) * l3 + 1 >>> 0, I2 = new Uint8Array(L); _ !== E2; ) {
      for (var k2 = u[_], T = 0, S2 = L - 1; (k2 !== 0 || T < D2) && S2 !== -1; S2--, T++) k2 += 256 * I2[S2] >>> 0, I2[S2] = k2 % a >>> 0, k2 = k2 / a >>> 0;
      if (k2 !== 0) throw new Error("Non-zero carry");
      D2 = T, _++;
    }
    for (var O2 = L - D2; O2 !== L && I2[O2] === 0; ) O2++;
    for (var te = c2.repeat(m2); O2 < L; ++O2) te += r2.charAt(I2[O2]);
    return te;
  }
  function y3(u) {
    if (typeof u != "string") throw new TypeError("Expected String");
    if (u.length === 0) return new Uint8Array();
    var m2 = 0;
    if (u[m2] !== " ") {
      for (var D2 = 0, _ = 0; u[m2] === c2; ) D2++, m2++;
      for (var E2 = (u.length - m2) * h3 + 1 >>> 0, L = new Uint8Array(E2); u[m2]; ) {
        var I2 = t[u.charCodeAt(m2)];
        if (I2 === 255) return;
        for (var k2 = 0, T = E2 - 1; (I2 !== 0 || k2 < _) && T !== -1; T--, k2++) I2 += a * L[T] >>> 0, L[T] = I2 % 256 >>> 0, I2 = I2 / 256 >>> 0;
        if (I2 !== 0) throw new Error("Non-zero carry");
        _ = k2, m2++;
      }
      if (u[m2] !== " ") {
        for (var S2 = E2 - _; S2 !== E2 && L[S2] === 0; ) S2++;
        for (var O2 = new Uint8Array(D2 + (E2 - S2)), te = D2; S2 !== E2; ) O2[te++] = L[S2++];
        return O2;
      }
    }
  }
  function w(u) {
    var m2 = y3(u);
    if (m2) return m2;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p, decodeUnsafe: y3, decode: w };
}
var hr = cr2;
var lr = hr;
var ni2 = (r2) => {
  if (r2 instanceof Uint8Array && r2.constructor.name === "Uint8Array") return r2;
  if (r2 instanceof ArrayBuffer) return new Uint8Array(r2);
  if (ArrayBuffer.isView(r2)) return new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ur = (r2) => new TextEncoder().encode(r2);
var dr = (r2) => new TextDecoder().decode(r2);
var gr = class {
  constructor(e, t, i2) {
    this.name = e, this.prefix = t, this.baseEncode = i2;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var pr = class {
  constructor(e, t, i2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return oi2(this, e);
  }
};
var yr2 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return oi2(this, e);
  }
  decode(e) {
    const t = e[0], i2 = this.decoders[t];
    if (i2) return i2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var oi2 = (r2, e) => new yr2({ ...r2.decoders || { [r2.prefix]: r2 }, ...e.decoders || { [e.prefix]: e } });
var br = class {
  constructor(e, t, i2, s) {
    this.name = e, this.prefix = t, this.baseEncode = i2, this.baseDecode = s, this.encoder = new gr(e, t, i2), this.decoder = new pr(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Se = ({ name: r2, prefix: e, encode: t, decode: i2 }) => new br(r2, e, t, i2);
var me = ({ prefix: r2, name: e, alphabet: t }) => {
  const { encode: i2, decode: s } = lr(t, e);
  return Se({ prefix: r2, name: e, encode: i2, decode: (n2) => ni2(s(n2)) });
};
var mr2 = (r2, e, t, i2) => {
  const s = {};
  for (let l3 = 0; l3 < e.length; ++l3) s[e[l3]] = l3;
  let n2 = r2.length;
  for (; r2[n2 - 1] === "="; ) --n2;
  const o2 = new Uint8Array(n2 * t / 8 | 0);
  let a = 0, c2 = 0, h3 = 0;
  for (let l3 = 0; l3 < n2; ++l3) {
    const p = s[r2[l3]];
    if (p === void 0) throw new SyntaxError(`Non-${i2} character`);
    c2 = c2 << t | p, a += t, a >= 8 && (a -= 8, o2[h3++] = 255 & c2 >> a);
  }
  if (a >= t || 255 & c2 << 8 - a) throw new SyntaxError("Unexpected end of data");
  return o2;
};
var fr = (r2, e, t) => {
  const i2 = e[e.length - 1] === "=", s = (1 << t) - 1;
  let n2 = "", o2 = 0, a = 0;
  for (let c2 = 0; c2 < r2.length; ++c2) for (a = a << 8 | r2[c2], o2 += 8; o2 > t; ) o2 -= t, n2 += e[s & a >> o2];
  if (o2 && (n2 += e[s & a << t - o2]), i2) for (; n2.length * t & 7; ) n2 += "=";
  return n2;
};
var A2 = ({ name: r2, prefix: e, bitsPerChar: t, alphabet: i2 }) => Se({ prefix: e, name: r2, encode(s) {
  return fr(s, i2, t);
}, decode(s) {
  return mr2(s, i2, t, r2);
} });
var Dr = Se({ prefix: "\0", name: "identity", encode: (r2) => dr(r2), decode: (r2) => ur(r2) });
var vr2 = Object.freeze({ __proto__: null, identity: Dr });
var wr2 = A2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var _r2 = Object.freeze({ __proto__: null, base2: wr2 });
var Er2 = A2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Ir2 = Object.freeze({ __proto__: null, base8: Er2 });
var Tr2 = me({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Cr = Object.freeze({ __proto__: null, base10: Tr2 });
var Pr = A2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Sr2 = A2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Or2 = Object.freeze({ __proto__: null, base16: Pr, base16upper: Sr2 });
var Rr2 = A2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Ar2 = A2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var xr2 = A2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Nr2 = A2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var $r2 = A2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var zr = A2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Lr = A2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var kr = A2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var jr = A2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Ur2 = Object.freeze({ __proto__: null, base32: Rr2, base32upper: Ar2, base32pad: xr2, base32padupper: Nr2, base32hex: $r2, base32hexupper: zr, base32hexpad: Lr, base32hexpadupper: kr, base32z: jr });
var Fr = me({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Mr = me({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Kr = Object.freeze({ __proto__: null, base36: Fr, base36upper: Mr });
var Br2 = me({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Vr = me({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var qr = Object.freeze({ __proto__: null, base58btc: Br2, base58flickr: Vr });
var Gr = A2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Wr = A2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Hr = A2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Yr = A2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Jr = Object.freeze({ __proto__: null, base64: Gr, base64pad: Wr, base64url: Hr, base64urlpad: Yr });
var ai = Array.from("");
var Xr = ai.reduce((r2, e, t) => (r2[t] = e, r2), []);
var Zr = ai.reduce((r2, e, t) => (r2[e.codePointAt(0)] = t, r2), []);
function Qr2(r2) {
  return r2.reduce((e, t) => (e += Xr[t], e), "");
}
function en2(r2) {
  const e = [];
  for (const t of r2) {
    const i2 = Zr[t.codePointAt(0)];
    if (i2 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i2);
  }
  return new Uint8Array(e);
}
var tn2 = Se({ prefix: "", name: "base256emoji", encode: Qr2, decode: en2 });
var sn3 = Object.freeze({ __proto__: null, base256emoji: tn2 });
var rn2 = hi2;
var ci2 = 128;
var nn2 = 127;
var on2 = ~nn2;
var an = Math.pow(2, 31);
function hi2(r2, e, t) {
  e = e || [], t = t || 0;
  for (var i2 = t; r2 >= an; ) e[t++] = r2 & 255 | ci2, r2 /= 128;
  for (; r2 & on2; ) e[t++] = r2 & 255 | ci2, r2 >>>= 7;
  return e[t] = r2 | 0, hi2.bytes = t - i2 + 1, e;
}
var cn2 = Ve;
var hn = 128;
var li = 127;
function Ve(r2, i2) {
  var t = 0, i2 = i2 || 0, s = 0, n2 = i2, o2, a = r2.length;
  do {
    if (n2 >= a) throw Ve.bytes = 0, new RangeError("Could not decode varint");
    o2 = r2[n2++], t += s < 28 ? (o2 & li) << s : (o2 & li) * Math.pow(2, s), s += 7;
  } while (o2 >= hn);
  return Ve.bytes = n2 - i2, t;
}
var ln = Math.pow(2, 7);
var un = Math.pow(2, 14);
var dn = Math.pow(2, 21);
var gn = Math.pow(2, 28);
var pn = Math.pow(2, 35);
var yn2 = Math.pow(2, 42);
var bn2 = Math.pow(2, 49);
var mn2 = Math.pow(2, 56);
var fn2 = Math.pow(2, 63);
var Dn = function(r2) {
  return r2 < ln ? 1 : r2 < un ? 2 : r2 < dn ? 3 : r2 < gn ? 4 : r2 < pn ? 5 : r2 < yn2 ? 6 : r2 < bn2 ? 7 : r2 < mn2 ? 8 : r2 < fn2 ? 9 : 10;
};
var vn2 = { encode: rn2, decode: cn2, encodingLength: Dn };
var ui = vn2;
var di2 = (r2, e, t = 0) => (ui.encode(r2, e, t), e);
var gi = (r2) => ui.encodingLength(r2);
var qe = (r2, e) => {
  const t = e.byteLength, i2 = gi(r2), s = i2 + gi(t), n2 = new Uint8Array(s + t);
  return di2(r2, n2, 0), di2(t, n2, i2), n2.set(e, s), new wn2(r2, t, e, n2);
};
var wn2 = class {
  constructor(e, t, i2, s) {
    this.code = e, this.size = t, this.digest = i2, this.bytes = s;
  }
};
var pi2 = ({ name: r2, code: e, encode: t }) => new _n2(r2, e, t);
var _n2 = class {
  constructor(e, t, i2) {
    this.name = e, this.code = t, this.encode = i2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? qe(this.code, t) : t.then((i2) => qe(this.code, i2));
    } else throw Error("Unknown type, must be binary type");
  }
};
var yi2 = (r2) => async (e) => new Uint8Array(await crypto.subtle.digest(r2, e));
var En2 = pi2({ name: "sha2-256", code: 18, encode: yi2("SHA-256") });
var In2 = pi2({ name: "sha2-512", code: 19, encode: yi2("SHA-512") });
var Tn2 = Object.freeze({ __proto__: null, sha256: En2, sha512: In2 });
var bi2 = 0;
var Cn = "identity";
var mi2 = ni2;
var Pn = (r2) => qe(bi2, mi2(r2));
var Sn2 = { code: bi2, name: Cn, encode: mi2, digest: Pn };
var On2 = Object.freeze({ __proto__: null, identity: Sn2 });
new TextEncoder(), new TextDecoder();
var fi2 = { ...vr2, ..._r2, ...Ir2, ...Cr, ...Or2, ...Ur2, ...Kr, ...qr, ...Jr, ...sn3 };
({ ...Tn2, ...On2 });
function Di2(r2) {
  return globalThis.Buffer != null ? new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength) : r2;
}
function Rn2(r2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Di2(globalThis.Buffer.allocUnsafe(r2)) : new Uint8Array(r2);
}
function vi2(r2, e, t, i2) {
  return { name: r2, prefix: e, encoder: { name: r2, prefix: e, encode: t }, decoder: { decode: i2 } };
}
var wi2 = vi2("utf8", "u", (r2) => "u" + new TextDecoder("utf8").decode(r2), (r2) => new TextEncoder().encode(r2.substring(1)));
var Ge = vi2("ascii", "a", (r2) => {
  let e = "a";
  for (let t = 0; t < r2.length; t++) e += String.fromCharCode(r2[t]);
  return e;
}, (r2) => {
  r2 = r2.substring(1);
  const e = Rn2(r2.length);
  for (let t = 0; t < r2.length; t++) e[t] = r2.charCodeAt(t);
  return e;
});
var An2 = { utf8: wi2, "utf-8": wi2, hex: fi2.base16, latin1: Ge, ascii: Ge, binary: Ge, ...fi2 };

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events4 = __toESM(require_events());
var import_time3 = __toESM(require_cjs());
var Ce2 = "wc";
var ke2 = 2;
var De2 = "client";
var we = `${Ce2}@${ke2}:${De2}:`;
var _t2 = "wc";
var ft = "auth";
var le3 = `${_t2}@${1.5}:${ft}:`;
var pe3 = `${le3}:PUB_KEY`;

// node_modules/@reown/appkit-adapter-wagmi/node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events5 = __toESM(require_events());
var Mt2 = "wc";
var Bt2 = "universal_provider";
var F2 = `${Mt2}@2:${Bt2}:`;
var rt3 = "https://rpc.walletconnect.org/v1/";
var Gt2 = `${rt3}bundler`;

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/connectors/WalletConnectConnector.js
walletConnect.type = "walletConnect";
function walletConnect(parameters, appKit) {
  const isNewChainsStale = parameters.isNewChainsStale ?? true;
  let provider_;
  let accountsChanged;
  let chainChanged;
  let connect2;
  let displayUri;
  let sessionDelete;
  let disconnect2;
  return createConnector((config) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: walletConnect.type,
    async setup() {
      const provider = await this.getProvider().catch(() => null);
      if (!provider) {
        return;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
      if (!sessionDelete) {
        sessionDelete = this.onSessionDelete.bind(this);
        provider.on("session_delete", sessionDelete);
      }
    },
    async connect({ ...rest } = {}) {
      var _a2, _b, _c2;
      try {
        const caipNetworks = ChainController.getCaipNetworks();
        const provider = await this.getProvider();
        if (!provider) {
          throw new ProviderNotFoundError();
        }
        if (!displayUri) {
          displayUri = this.onDisplayUri;
          provider.on("display_uri", displayUri);
        }
        const isChainsStale = await this.isChainsStale();
        if (provider.session && isChainsStale) {
          await provider.disconnect();
        }
        const universalProviderConfigOverride = OptionsController.state.universalProviderConfigOverride;
        if (!provider.session || isChainsStale) {
          const namespaces = WcHelpersUtil.createNamespaces(caipNetworks, universalProviderConfigOverride);
          await provider.connect({
            optionalNamespaces: namespaces,
            ..."pairingTopic" in rest ? { pairingTopic: rest.pairingTopic } : {}
          });
          this.setRequestedChainsIds(caipNetworks.map((x) => Number(x.id)));
        }
        const accounts = await this.getAccounts();
        const requestChainId = await this.getChainId();
        const chains = (_c2 = (_b = (_a2 = provider.session) == null ? void 0 : _a2.namespaces) == null ? void 0 : _b["eip155"]) == null ? void 0 : _c2.chains;
        const isRequestedChainSupported = chains == null ? void 0 : chains.some((chain) => Number(chain.split(":")[1]) === requestChainId);
        let currentChainId = 1;
        if (isRequestedChainSupported) {
          currentChainId = requestChainId;
        } else if (chains == null ? void 0 : chains[0]) {
          currentChainId = Number(chains[0].split(":")[1]);
        }
        if (displayUri) {
          provider.removeListener("display_uri", displayUri);
          displayUri = void 0;
        }
        if (connect2) {
          provider.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
        if (!sessionDelete) {
          sessionDelete = this.onSessionDelete.bind(this);
          provider.on("session_delete", sessionDelete);
        }
        const defaultChain = universalProviderConfigOverride == null ? void 0 : universalProviderConfigOverride.defaultChain;
        provider.setDefaultChain(defaultChain ?? `eip155:${currentChainId}`);
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user rejected|connection request reset)/i.test(error == null ? void 0 : error.message)) {
          throw new UserRejectedRequestError(error);
        }
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      try {
        await (provider == null ? void 0 : provider.disconnect());
      } catch (error) {
        if (!/No matching key/i.test(error.message)) {
          throw error;
        }
      } finally {
        if (chainChanged) {
          provider == null ? void 0 : provider.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect2) {
          provider == null ? void 0 : provider.removeListener("disconnect", disconnect2);
          disconnect2 = void 0;
        }
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider == null ? void 0 : provider.on("connect", connect2);
        }
        if (accountsChanged) {
          provider == null ? void 0 : provider.removeListener("accountsChanged", accountsChanged);
          accountsChanged = void 0;
        }
        if (sessionDelete) {
          provider == null ? void 0 : provider.removeListener("session_delete", sessionDelete);
          sessionDelete = void 0;
        }
        this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      var _a2, _b, _c2;
      const provider = await this.getProvider();
      if (!((_a2 = provider == null ? void 0 : provider.session) == null ? void 0 : _a2.namespaces)) {
        return [];
      }
      const accountsList = (_c2 = (_b = provider == null ? void 0 : provider.session) == null ? void 0 : _b.namespaces[ConstantsUtil.CHAIN.EVM]) == null ? void 0 : _c2.accounts;
      const accounts = (accountsList == null ? void 0 : accountsList.map((account) => account.split(":")[2])) ?? [];
      const accountsAdded = /* @__PURE__ */ new Set();
      const deduplicatedAccounts = accounts.filter((account) => {
        const lowerCasedAccount = account == null ? void 0 : account.toLowerCase();
        if (accountsAdded.has(lowerCasedAccount)) {
          return false;
        }
        accountsAdded.add(lowerCasedAccount);
        return true;
      });
      return deduplicatedAccounts;
    },
    async getProvider({ chainId } = {}) {
      var _a2, _b;
      if (!provider_) {
        provider_ = await appKit.getUniversalProvider();
        provider_ == null ? void 0 : provider_.events.setMaxListeners(Number.POSITIVE_INFINITY);
      }
      const activeNamespace = StorageUtil.getActiveNamespace();
      const currentChainId = (_a2 = appKit.getCaipNetwork()) == null ? void 0 : _a2.id;
      if (chainId && currentChainId !== chainId && activeNamespace) {
        const storedCaipNetworkId = StorageUtil.getStoredActiveCaipNetworkId();
        const appKitCaipNetworks = activeNamespace ? appKit.getCaipNetworks(activeNamespace) : [];
        const storedCaipNetwork = appKitCaipNetworks == null ? void 0 : appKitCaipNetworks.find((n2) => n2.id === storedCaipNetworkId);
        if (storedCaipNetwork && storedCaipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM) {
          await ((_b = this.switchChain) == null ? void 0 : _b.call(this, { chainId: Number(storedCaipNetwork.id) }));
        }
      }
      return provider_;
    },
    async getChainId() {
      var _a2, _b, _c2, _d;
      const chainId = (_a2 = appKit.getCaipNetwork(ConstantsUtil.CHAIN.EVM)) == null ? void 0 : _a2.id;
      if (chainId) {
        return chainId;
      }
      const provider = await this.getProvider();
      const chain = (_d = (_c2 = (_b = provider.session) == null ? void 0 : _b.namespaces[ConstantsUtil.CHAIN.EVM]) == null ? void 0 : _c2.chains) == null ? void 0 : _d[0];
      const network = ChainController.getCaipNetworks().find((c2) => c2.id === chain);
      return network == null ? void 0 : network.id;
    },
    async isAuthorized() {
      try {
        const [accounts, provider] = await Promise.all([this.getAccounts(), this.getProvider()]);
        if (!accounts.length) {
          return false;
        }
        const isChainsStale = await this.isChainsStale();
        if (isChainsStale && provider.session) {
          await provider.disconnect().catch(() => {
          });
          return false;
        }
        return true;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a2, _b, _c2, _d;
      const provider = await this.getProvider();
      if (!provider) {
        throw new ProviderNotFoundError();
      }
      const chainToSwitch = ChainController.getCaipNetworks().find((x) => x.id === chainId);
      if (!chainToSwitch) {
        throw new SwitchChainError(new ChainNotConfiguredError());
      }
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chainId) }]
        });
        if (chainToSwitch == null ? void 0 : chainToSwitch.caipNetworkId) {
          provider.setDefaultChain(chainToSwitch == null ? void 0 : chainToSwitch.caipNetworkId);
        }
        config.emitter.emit("change", { chainId: Number(chainId) });
        const requestedChains = await this.getRequestedChainsIds();
        this.setRequestedChainsIds([...requestedChains, chainId]);
        return { ...chainToSwitch, id: chainToSwitch.id };
      } catch (err) {
        const error = err;
        if (/(?:user rejected)/iu.test(error.message)) {
          throw new UserRejectedRequestError(error);
        }
        try {
          let blockExplorerUrls;
          if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls) {
            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
          } else {
            blockExplorerUrls = ((_a2 = chainToSwitch.blockExplorers) == null ? void 0 : _a2.default.url) ? [(_b = chainToSwitch.blockExplorers) == null ? void 0 : _b.default.url] : [];
          }
          const rpcUrls = ((_d = (_c2 = chainToSwitch.rpcUrls) == null ? void 0 : _c2["chainDefault"]) == null ? void 0 : _d.http) || [];
          const addEthereumChain = {
            blockExplorerUrls,
            chainId: numberToHex(chainId),
            chainName: chainToSwitch.name,
            iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
            nativeCurrency: chainToSwitch.nativeCurrency,
            rpcUrls
          };
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [addEthereumChain]
          });
          const requestedChains = await this.getRequestedChainsIds();
          this.setRequestedChainsIds([...requestedChains, chainId]);
          return { ...chainToSwitch, id: chainToSwitch.id };
        } catch (e) {
          throw new UserRejectedRequestError(e);
        }
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        this.onDisconnect();
      } else {
        config.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
      }
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    onConnect(_connectInfo) {
      this.setRequestedChainsIds(ChainController.getCaipNetworks().map((x) => Number(x.id)));
    },
    async onDisconnect(_error) {
      this.setRequestedChainsIds([]);
      config.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (sessionDelete) {
        provider.removeListener("session_delete", sessionDelete);
        sessionDelete = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
    },
    onDisplayUri(uri) {
      config.emitter.emit("message", { type: "display_uri", data: uri });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      var _a2, _b, _c2;
      if (!((_a2 = provider_ == null ? void 0 : provider_.session) == null ? void 0 : _a2.namespaces)) {
        return [];
      }
      const accounts = (_c2 = (_b = provider_ == null ? void 0 : provider_.session) == null ? void 0 : _b.namespaces[ConstantsUtil.CHAIN.EVM]) == null ? void 0 : _c2.accounts;
      const chainIds = (accounts == null ? void 0 : accounts.map((account) => Number.parseInt(account.split(":")[1] ?? ""))) ?? [];
      return chainIds;
    },
    async getRequestedChainsIds() {
      var _a2;
      const chainIds = await ((_a2 = config.storage) == null ? void 0 : _a2.getItem(this.requestedChainsStorageKey)) ?? [];
      return [...new Set(chainIds)];
    },
    async isChainsStale() {
      if (!isNewChainsStale) {
        return false;
      }
      const connectorChains = config.chains.map((x) => x.id);
      const namespaceChains = this.getNamespaceChainsIds();
      if (namespaceChains.length && !namespaceChains.some((id) => connectorChains.includes(id))) {
        return false;
      }
      const requestedChains = await this.getRequestedChainsIds();
      return !connectorChains.every((id) => requestedChains.includes(Number(id)));
    },
    async setRequestedChainsIds(chains) {
      var _a2;
      await ((_a2 = config.storage) == null ? void 0 : _a2.setItem(this.requestedChainsStorageKey, chains));
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  }));
}

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/utils/LimitterUtil.js
var state = proxy({
  pendingTransactions: 0
});
var LimitterUtil = {
  state,
  subscribeKey(key, callback) {
    return subscribeKey(state, key, callback);
  },
  increase(value) {
    state[value] += 1;
  },
  decrease(value) {
    state[value] -= 1;
  },
  reset(value) {
    state[value] = 0;
  }
};

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/utils/helpers.js
async function getSafeConnector(connectors) {
  if (CoreHelperUtil.isSafeApp()) {
    const { safe } = await import("./exports-W7M7IDFH.js");
    if (safe && !connectors.some((c2) => c2.type === "safe")) {
      const safeConnector = safe();
      return safeConnector;
    }
  }
  return null;
}
async function getCoinbaseConnector(connectors) {
  try {
    const { coinbaseWallet } = await import("./exports-W7M7IDFH.js");
    if (coinbaseWallet && !connectors.some((c2) => c2.id === "coinbaseWalletSDK")) {
      return coinbaseWallet();
    }
  } catch (error) {
    console.error("Failed to import Coinbase Wallet SDK:", error);
  }
  return null;
}

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/client.js
var DEFAULT_PENDING_TRANSACTIONS_FILTER = {
  enable: false,
  pollingInterval: 3e4
};
var WagmiAdapter = class extends AdapterBlueprint {
  constructor(configParams) {
    const networks = CaipNetworksUtil.extendCaipNetworks(configParams.networks, {
      projectId: configParams.projectId,
      customNetworkImageUrls: {},
      customRpcUrls: configParams.customRpcUrls
    });
    super();
    this.balancePromises = {};
    this.namespace = ConstantsUtil.CHAIN.EVM;
    this.adapterType = ConstantsUtil.ADAPTER_TYPES.WAGMI;
    this.projectId = configParams.projectId;
    this.pendingTransactionsFilter = {
      ...DEFAULT_PENDING_TRANSACTIONS_FILTER,
      ...configParams.pendingTransactionsFilter ?? {}
    };
    this.createConfig({ ...configParams, networks });
    this.checkChainId();
  }
  construct(_options) {
    this.checkChainId();
    this.setupWatchers();
  }
  async getAccounts(params) {
    var _a2;
    const connector = this.getWagmiConnector(params.id);
    if (!connector) {
      return { accounts: [] };
    }
    if (connector.id === ConstantsUtil.CONNECTOR_ID.AUTH) {
      const provider = await connector.getProvider();
      if (!(provider == null ? void 0 : provider.user)) {
        return { accounts: [] };
      }
      const { address: address2, accounts } = provider.user;
      return Promise.resolve({
        accounts: (accounts || [{ address: address2, type: "eoa" }]).map((account) => CoreHelperUtil.createAccount("eip155", account.address, account.type))
      });
    }
    const { addresses, address } = getAccount(this.wagmiConfig);
    return Promise.resolve({
      accounts: (_a2 = [...new Set(addresses || [address])]) == null ? void 0 : _a2.map((val) => CoreHelperUtil.createAccount("eip155", val || "", "eoa"))
    });
  }
  checkChainId() {
    const { chainId } = getAccount(this.wagmiConfig);
    if (chainId) {
      this.emit("switchNetwork", {
        chainId
      });
    }
  }
  getWagmiConnector(id) {
    return this.wagmiConfig.connectors.find((c2) => c2.id === id);
  }
  createConfig(configParams) {
    this.wagmiChains = configParams.networks.filter((caipNetwork) => caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM);
    const transports = {};
    const connectors = [...configParams.connectors ?? []];
    this.wagmiChains.forEach((element) => {
      var _a2, _b;
      const fromTransportProp = (_a2 = configParams.transports) == null ? void 0 : _a2[element.id];
      const caipNetworkId = CaipNetworksUtil.getCaipNetworkId(element);
      if (fromTransportProp) {
        transports[element.id] = CaipNetworksUtil.extendWagmiTransports(element, configParams.projectId, fromTransportProp);
      } else {
        transports[element.id] = CaipNetworksUtil.getViemTransport(element, configParams.projectId, (_b = configParams.customRpcUrls) == null ? void 0 : _b[caipNetworkId]);
      }
    });
    this.wagmiConfig = createConfig({
      ...configParams,
      chains: this.wagmiChains,
      connectors,
      transports
    });
  }
  setupWatchPendingTransactions() {
    if (!this.pendingTransactionsFilter.enable || this.unwatchPendingTransactions) {
      return;
    }
    this.unwatchPendingTransactions = watchPendingTransactions(this.wagmiConfig, {
      pollingInterval: this.pendingTransactionsFilter.pollingInterval,
      onError: () => {
      },
      onTransactions: () => {
        this.emit("pendingTransactions");
        LimitterUtil.increase("pendingTransactions");
      }
    });
    const unsubscribe = LimitterUtil.subscribeKey("pendingTransactions", (val) => {
      var _a2;
      if (val >= ConstantsUtil.LIMITS.PENDING_TRANSACTIONS) {
        (_a2 = this.unwatchPendingTransactions) == null ? void 0 : _a2.call(this);
        unsubscribe();
      }
    });
  }
  setupWatchers() {
    watchConnections(this.wagmiConfig, {
      onChange: (connections) => {
        this.clearConnections();
        this.addConnection(...connections.map((connection) => {
          const caipNetwork = this.getCaipNetworks().find((network) => network.id === connection.chainId);
          const isAuth = connection.connector.id === ConstantsUtil.CONNECTOR_ID.AUTH;
          return {
            accounts: connection.accounts.map((account) => ({
              address: this.toChecksummedAddress(account)
            })),
            caipNetwork,
            connectorId: connection.connector.id,
            auth: isAuth ? {
              name: StorageUtil.getConnectedSocialProvider(),
              username: StorageUtil.getConnectedSocialUsername()
            } : void 0
          };
        }));
      }
    });
    watchAccount(this.wagmiConfig, {
      onChange: (accountData, prevAccountData) => {
        var _a2;
        if (accountData.status === "disconnected" && prevAccountData.address) {
          this.emit("disconnect");
        }
        if ((accountData == null ? void 0 : accountData.chainId) && (accountData == null ? void 0 : accountData.chainId) !== (prevAccountData == null ? void 0 : prevAccountData.chainId)) {
          this.emit("switchNetwork", {
            chainId: accountData.chainId
          });
        }
        if (accountData.status === "connected") {
          const hasAccountChanged = accountData.address !== (prevAccountData == null ? void 0 : prevAccountData.address);
          const hasConnectorChanged = accountData.connector.id !== ((_a2 = prevAccountData.connector) == null ? void 0 : _a2.id);
          const hasConnectionStatusChanged = prevAccountData.status !== "connected";
          if (hasAccountChanged || hasConnectorChanged || hasConnectionStatusChanged) {
            this.setupWatchPendingTransactions();
            this.handleAccountChanged({
              address: accountData.address,
              chainId: accountData.chainId,
              connector: accountData.connector
            });
          }
        }
      }
    });
  }
  async addThirdPartyConnectors(options) {
    const thirdPartyConnectors = [];
    if (options.enableCoinbase !== false) {
      const coinbaseConnector = await getCoinbaseConnector(this.wagmiConfig.connectors);
      if (coinbaseConnector) {
        thirdPartyConnectors.push(coinbaseConnector);
      }
    }
    const safeConnector = await getSafeConnector(this.wagmiConfig.connectors);
    if (safeConnector) {
      thirdPartyConnectors.push(safeConnector);
    }
    await Promise.all(thirdPartyConnectors.map((connector) => {
      const cnctr = this.wagmiConfig._internal.connectors.setup(connector);
      this.wagmiConfig._internal.connectors.setState((prev) => [...prev, cnctr]);
      return this.addWagmiConnector(cnctr, options);
    }));
  }
  addWagmiConnectors(options, appKit) {
    var _a2, _b, _c2, _d;
    const customConnectors = [];
    if (options.enableWalletConnect !== false) {
      customConnectors.push(walletConnect(options, appKit));
    }
    if (options.enableInjected !== false) {
      customConnectors.push(injected({ shimDisconnect: true }));
    }
    const isEmailEnabled = ((_a2 = appKit == null ? void 0 : appKit.remoteFeatures) == null ? void 0 : _a2.email) ?? ((_b = appKit == null ? void 0 : appKit.features) == null ? void 0 : _b.email) ?? true;
    const socials = ((_c2 = appKit == null ? void 0 : appKit.remoteFeatures) == null ? void 0 : _c2.socials) ?? ((_d = appKit == null ? void 0 : appKit.features) == null ? void 0 : _d.socials);
    const socialsEnabled = Array.isArray(socials) && (socials == null ? void 0 : socials.length) > 0;
    if (isEmailEnabled || socialsEnabled) {
      customConnectors.push(authConnector({
        chains: this.wagmiChains,
        options: { projectId: options.projectId, enableAuthLogger: options.enableAuthLogger }
      }));
    }
    customConnectors.forEach((connector) => {
      const cnctr = this.wagmiConfig._internal.connectors.setup(connector);
      this.wagmiConfig._internal.connectors.setState((prev) => [...prev, cnctr]);
    });
  }
  async handleAccountChanged({ address, chainId, connector }) {
    if (!this.namespace) {
      throw new Error("WagmiAdapter:handleAccountChanged - namespace is required");
    }
    const provider = await connector.getProvider().catch(() => void 0);
    this.emit("accountChanged", {
      address: this.toChecksummedAddress(address),
      chainId,
      connector: {
        id: connector.id,
        name: PresetsUtil.ConnectorNamesMap[connector.id] ?? connector.name,
        imageId: PresetsUtil.ConnectorImageIds[connector.id],
        type: PresetsUtil.ConnectorTypesMap[connector.type] ?? "EXTERNAL",
        info: connector.id === ConstantsUtil.CONNECTOR_ID.INJECTED ? void 0 : { rdns: connector.id },
        provider,
        chain: this.namespace,
        chains: []
      }
    });
  }
  async signMessage(params) {
    try {
      const signature = await signMessage(this.wagmiConfig, {
        message: params.message,
        account: params.address
      });
      return { signature };
    } catch (error) {
      throw new Error("WagmiAdapter:signMessage - Sign message failed");
    }
  }
  async sendTransaction(params) {
    const { chainId, address } = getAccount(this.wagmiConfig);
    const txParams = {
      account: address,
      to: params.to,
      value: Number.isNaN(Number(params.value)) ? BigInt(0) : BigInt(params.value),
      gas: params.gas ? BigInt(params.gas) : void 0,
      gasPrice: params.gasPrice ? BigInt(params.gasPrice) : void 0,
      data: params.data,
      chainId,
      type: "legacy",
      parameters: ["nonce"]
    };
    await prepareTransactionRequest(this.wagmiConfig, txParams);
    const tx = await sendTransaction(this.wagmiConfig, txParams);
    await waitForTransactionReceipt(this.wagmiConfig, { hash: tx, timeout: 25e3 });
    return { hash: tx };
  }
  async writeContract(params) {
    var _a2;
    const { caipNetwork, ...data } = params;
    const chainId = Number(NetworkUtil.caipNetworkIdToNumber(caipNetwork.caipNetworkId));
    const tx = await writeContract(this.wagmiConfig, {
      chain: (_a2 = this.wagmiChains) == null ? void 0 : _a2[chainId],
      chainId,
      address: data.tokenAddress,
      account: data.fromAddress,
      abi: data.abi,
      functionName: data.method,
      args: data.args,
      __mode: "prepared"
    });
    return { hash: tx };
  }
  async estimateGas(params) {
    try {
      const result = await estimateGas(this.wagmiConfig, {
        account: params.address,
        to: params.to,
        data: params.data,
        type: "legacy"
      });
      return { gas: result };
    } catch (error) {
      throw new Error("WagmiAdapter:estimateGas - error estimating gas");
    }
  }
  parseUnits(params) {
    return parseUnits(params.value, params.decimals);
  }
  formatUnits(params) {
    return formatUnits(params.value, params.decimals);
  }
  async addWagmiConnector(connector, options) {
    var _a2;
    if (!this.namespace) {
      throw new Error("WagmiAdapter:addWagmiConnector - namespace is required");
    }
    if (connector.type === ConstantsUtil.CONNECTOR_ID.INJECTED && options.enableEIP6963 === false) {
      return;
    }
    if (connector.id === ConstantsUtil.CONNECTOR_ID.AUTH || connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
      return;
    }
    const provider = await connector.getProvider().catch(() => void 0);
    this.addConnector({
      id: connector.id,
      explorerId: PresetsUtil.ConnectorExplorerIds[connector.id],
      imageUrl: ((_a2 = options == null ? void 0 : options.connectorImages) == null ? void 0 : _a2[connector.id]) ?? connector.icon,
      name: PresetsUtil.ConnectorNamesMap[connector.id] ?? connector.name,
      imageId: PresetsUtil.ConnectorImageIds[connector.id],
      type: PresetsUtil.ConnectorTypesMap[connector.type] ?? "EXTERNAL",
      info: connector.id === ConstantsUtil.CONNECTOR_ID.INJECTED ? void 0 : { rdns: connector.id },
      provider,
      chain: this.namespace,
      chains: []
    });
  }
  async syncConnectors(options, appKit) {
    watchConnectors(this.wagmiConfig, {
      onChange: (connectors) => {
        connectors.forEach((connector) => this.addWagmiConnector(connector, options));
      }
    });
    this.addWagmiConnectors(options, appKit);
    await Promise.all(this.wagmiConfig.connectors.map((connector) => this.addWagmiConnector(connector, options)));
    this.addThirdPartyConnectors(options);
  }
  async syncConnections() {
    return Promise.resolve();
  }
  async syncConnection(params) {
    var _a2, _b;
    const { id, chainId } = params;
    const connections = getConnections(this.wagmiConfig);
    const connection = connections.find((c2) => c2.connector.id === id);
    const connector = this.getWagmiConnector(id);
    const provider = await (connector == null ? void 0 : connector.getProvider());
    const isSafeApp = CoreHelperUtil.isSafeApp();
    if (isSafeApp && id === ConstantsUtil.CONNECTOR_ID.SAFE && !(connection == null ? void 0 : connection.accounts.length)) {
      const safeAppConnector = this.getWagmiConnector("safe");
      if (safeAppConnector) {
        const res = await connect(this.wagmiConfig, {
          connector: safeAppConnector,
          chainId: Number(chainId)
        });
        const safeProvider = await safeAppConnector.getProvider();
        return {
          chainId: Number(chainId),
          address: this.toChecksummedAddress(res.accounts[0]),
          provider: safeProvider,
          type: (_a2 = connection == null ? void 0 : connection.connector.type) == null ? void 0 : _a2.toUpperCase(),
          id: connection == null ? void 0 : connection.connector.id
        };
      }
    }
    return {
      chainId: Number(connection == null ? void 0 : connection.chainId),
      address: this.toChecksummedAddress(connection == null ? void 0 : connection.accounts[0]),
      provider,
      type: (_b = connection == null ? void 0 : connection.connector.type) == null ? void 0 : _b.toUpperCase(),
      id: connection == null ? void 0 : connection.connector.id
    };
  }
  async connectWalletConnect(chainId) {
    try {
      const walletConnectConnector = this.getWalletConnectConnector();
      await walletConnectConnector.authenticate();
      const wagmiConnector = this.getWagmiConnector("walletConnect");
      if (!wagmiConnector) {
        throw new Error("UniversalAdapter:connectWalletConnect - connector not found");
      }
      const res = await connect(this.wagmiConfig, {
        connector: wagmiConnector,
        chainId: chainId ? Number(chainId) : void 0
      });
      if (res.chainId !== Number(chainId)) {
        await switchChain(this.wagmiConfig, { chainId: res.chainId });
      }
      return { clientId: await walletConnectConnector.provider.client.core.crypto.getClientId() };
    } catch (err) {
      if (err instanceof UserRejectedRequestError) {
        throw new Error(err.shortMessage);
      }
      throw err;
    }
  }
  async connect(params) {
    var _a2, _b, _c2, _d, _e2;
    const { id, address, provider, type, info, chainId, socialUri } = params;
    const connector = this.getWagmiConnector(id);
    if (!connector) {
      throw new Error("connectionControllerClient:connectExternal - connector is undefined");
    }
    if (provider && info && connector.id === ConstantsUtil.CONNECTOR_ID.EIP6963) {
      (_a2 = connector.setEip6963Wallet) == null ? void 0 : _a2.call(connector, { provider, info });
    }
    const connection = (_c2 = (_b = this.wagmiConfig.state) == null ? void 0 : _b.connections) == null ? void 0 : _c2.get(connector.uid);
    if (connection) {
      await ((_d = this.wagmiConfig.storage) == null ? void 0 : _d.setItem("recentConnectorId", connector.id));
      const sortedAccounts = [...connection.accounts].sort((a, b) => {
        if (HelpersUtil.isLowerCaseMatch(a, address)) {
          return -1;
        }
        if (HelpersUtil.isLowerCaseMatch(b, address)) {
          return 1;
        }
        return 0;
      });
      (_e2 = this.wagmiConfig) == null ? void 0 : _e2.setState((x) => ({
        ...x,
        connections: new Map(x.connections).set(connector.uid, {
          accounts: sortedAccounts,
          chainId: connection.chainId,
          connector: connection.connector
        }),
        current: connector.uid,
        status: "connected"
      }));
      return {
        address: this.toChecksummedAddress(sortedAccounts[0]),
        chainId: connection.chainId,
        provider,
        type,
        id
      };
    }
    const res = await connect(this.wagmiConfig, {
      connector,
      chainId: chainId ? Number(chainId) : void 0,
      socialUri
    });
    return {
      address: this.toChecksummedAddress(res.accounts[0]),
      chainId: res.chainId,
      provider,
      type,
      id
    };
  }
  get connections() {
    return Array.from(this.wagmiConfig.state.connections.values()).map((connection) => ({
      accounts: connection.accounts.map((account) => ({
        address: this.toChecksummedAddress(account)
      })),
      connectorId: connection.connector.id
    }));
  }
  async reconnect(params) {
    const { id } = params;
    const connector = this.getWagmiConnector(id);
    if (!connector) {
      throw new Error("connectionControllerClient:connectExternal - connector is undefined");
    }
    await reconnect(this.wagmiConfig, {
      connectors: [connector]
    });
  }
  async getBalance(params) {
    const address = params.address;
    const caipNetwork = this.getCaipNetworks().find((network) => network.id === params.chainId);
    if (!address) {
      return Promise.resolve({ balance: "0.00", symbol: "ETH" });
    }
    if (caipNetwork && this.wagmiConfig) {
      const caipAddress = `${caipNetwork.caipNetworkId}:${params.address}`;
      const cachedPromise = this.balancePromises[caipAddress];
      if (cachedPromise) {
        return cachedPromise;
      }
      const cachedBalance = StorageUtil.getNativeBalanceCacheForCaipAddress(caipAddress);
      if (cachedBalance) {
        return { balance: cachedBalance.balance, symbol: cachedBalance.symbol };
      }
      this.balancePromises[caipAddress] = new Promise(async (resolve) => {
        var _a2, _b;
        try {
          const chainId = Number(params.chainId);
          const balance = await getBalance(this.wagmiConfig, {
            address: params.address,
            chainId,
            token: (_b = (_a2 = params.tokens) == null ? void 0 : _a2[caipNetwork.caipNetworkId]) == null ? void 0 : _b.address
          });
          StorageUtil.updateNativeBalanceCache({
            caipAddress,
            balance: balance.formatted,
            symbol: balance.symbol,
            timestamp: Date.now()
          });
          resolve({ balance: balance.formatted, symbol: balance.symbol });
        } catch (error) {
          console.warn("Appkit:WagmiAdapter:getBalance - Error getting balance", error);
          resolve({ balance: "0.00", symbol: "ETH" });
        }
      }).finally(() => {
        delete this.balancePromises[caipAddress];
      });
      return this.balancePromises[caipAddress] || { balance: "0.00", symbol: "ETH" };
    }
    return { balance: "", symbol: "" };
  }
  getWalletConnectProvider() {
    var _a2;
    return (_a2 = this.getWagmiConnector("walletConnect")) == null ? void 0 : _a2["provider"];
  }
  async disconnect(params) {
    if (params.id) {
      const connector = this.getWagmiConnector(params.id);
      const connections = getConnections(this.wagmiConfig);
      const connection = connections.find((c2) => HelpersUtil.isLowerCaseMatch(c2.connector.id, params.id));
      await disconnect(this.wagmiConfig, { connector });
      if (OptionsController.state.enableReconnect === false) {
        this.deleteConnection(params.id);
      }
      if (connection) {
        return {
          connections: [
            {
              accounts: connection.accounts.map((account) => ({
                address: this.toChecksummedAddress(account)
              })),
              connectorId: connection.connector.id
            }
          ]
        };
      }
      return { connections: [] };
    }
    return this.disconnectAll();
  }
  async disconnectAll() {
    const wagmiConnections = getConnections(this.wagmiConfig);
    const connections = await Promise.allSettled(wagmiConnections.map(async (connection) => {
      const connector = this.getWagmiConnector(connection.connector.id);
      if (connector) {
        await disconnect(this.wagmiConfig, { connector });
      }
      return connection;
    }));
    this.wagmiConfig.state.connections.clear();
    return {
      connections: connections.filter((connection) => connection.status === "fulfilled").map(({ value: connection }) => ({
        accounts: connection.accounts.map((account) => ({
          address: this.toChecksummedAddress(account)
        })),
        connectorId: connection.connector.id
      }))
    };
  }
  async switchNetwork(params) {
    var _a2, _b, _c2, _d, _e2, _f2, _g, _h, _i2, _j;
    const { caipNetwork } = params;
    const wagmiChain = this.wagmiConfig.chains.find((chain) => chain.id.toString() === caipNetwork.id.toString());
    await switchChain(this.wagmiConfig, {
      chainId: caipNetwork.id,
      addEthereumChainParameter: {
        chainName: (wagmiChain == null ? void 0 : wagmiChain.name) ?? caipNetwork.name,
        nativeCurrency: (wagmiChain == null ? void 0 : wagmiChain.nativeCurrency) ?? caipNetwork.nativeCurrency,
        rpcUrls: [
          ((_c2 = (_b = (_a2 = caipNetwork.rpcUrls) == null ? void 0 : _a2["chainDefault"]) == null ? void 0 : _b.http) == null ? void 0 : _c2[0]) ?? ((_f2 = (_e2 = (_d = wagmiChain == null ? void 0 : wagmiChain.rpcUrls) == null ? void 0 : _d.default) == null ? void 0 : _e2.http) == null ? void 0 : _f2[0]) ?? ""
        ],
        blockExplorerUrls: [
          ((_h = (_g = wagmiChain == null ? void 0 : wagmiChain.blockExplorers) == null ? void 0 : _g.default) == null ? void 0 : _h.url) ?? ((_j = (_i2 = caipNetwork.blockExplorers) == null ? void 0 : _i2.default) == null ? void 0 : _j.url) ?? ""
        ]
      }
    });
    await super.switchNetwork(params);
  }
  async getCapabilities(params) {
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:getCapabilities - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:getCapabilities - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:getCapabilities - provider is undefined");
    }
    return await provider.request({ method: "wallet_getCapabilities", params: [params] });
  }
  async grantPermissions(params) {
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:grantPermissions - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:grantPermissions - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:grantPermissions - provider is undefined");
    }
    return provider.request({ method: "wallet_grantPermissions", params });
  }
  async revokePermissions(params) {
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:revokePermissions - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:revokePermissions - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:revokePermissions - provider is undefined");
    }
    return provider.request({ method: "wallet_revokePermissions", params });
  }
  async walletGetAssets(params) {
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:walletGetAssets - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:walletGetAssets - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:walletGetAssets - provider is undefined");
    }
    return provider.request({ method: "wallet_getAssets", params: [params] });
  }
  setAuthProvider(authProvider) {
    if (!this.namespace) {
      throw new Error("WagmiAdapter:setAuthProvider - namespace is required");
    }
    this.addConnector({
      id: ConstantsUtil.CONNECTOR_ID.AUTH,
      type: "AUTH",
      name: ConstantsUtil.CONNECTOR_NAMES.AUTH,
      provider: authProvider,
      imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.AUTH],
      chain: this.namespace,
      chains: []
    });
  }
  async setUniversalProvider(universalProvider) {
    universalProvider.on("connect", () => {
      const connections = getConnections(this.wagmiConfig);
      const connector = this.getWagmiConnector("walletConnect");
      if (connector && !connections.find((c2) => c2.connector.id === connector.id)) {
        if (ChainController.state.activeChain === "eip155") {
          return;
        }
        reconnect(this.wagmiConfig, {
          connectors: [connector]
        });
      }
    });
    this.addConnector(new WalletConnectConnector({
      provider: universalProvider,
      caipNetworks: this.getCaipNetworks(),
      namespace: "eip155"
    }));
    return Promise.resolve();
  }
  toChecksummedAddress(address) {
    return checksumAddress(address.toLowerCase());
  }
};
export {
  WagmiAdapter,
  authConnector
};
/*! Bundled license information:

@walletconnect/utils/dist/index.es.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@reown_appkit-adapter-wagmi.js.map
